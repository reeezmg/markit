
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Distributor
 * 
 */
export type Distributor = $Result.DefaultSelection<Prisma.$DistributorPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Pipeline
 * 
 */
export type Pipeline = $Result.DefaultSelection<Prisma.$PipelinePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Subcategory
 * 
 */
export type Subcategory = $Result.DefaultSelection<Prisma.$SubcategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Variant
 * 
 */
export type Variant = $Result.DefaultSelection<Prisma.$VariantPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model TokenEntry
 * 
 */
export type TokenEntry = $Result.DefaultSelection<Prisma.$TokenEntryPayload>
/**
 * Model Entry
 * 
 */
export type Entry = $Result.DefaultSelection<Prisma.$EntryPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model CompanyUser
 * 
 */
export type CompanyUser = $Result.DefaultSelection<Prisma.$CompanyUserPayload>
/**
 * Model CompanyClient
 * 
 */
export type CompanyClient = $Result.DefaultSelection<Prisma.$CompanyClientPayload>
/**
 * Model UserConversation
 * 
 */
export type UserConversation = $Result.DefaultSelection<Prisma.$UserConversationPayload>
/**
 * Model ClientConversation
 * 
 */
export type ClientConversation = $Result.DefaultSelection<Prisma.$ClientConversationPayload>
/**
 * Model UserClient
 * 
 */
export type UserClient = $Result.DefaultSelection<Prisma.$UserClientPayload>
/**
 * Model DistributorCompany
 * 
 */
export type DistributorCompany = $Result.DefaultSelection<Prisma.$DistributorCompanyPayload>
/**
 * Model VariantSizeBarcode
 * 
 */
export type VariantSizeBarcode = $Result.DefaultSelection<Prisma.$VariantSizeBarcodePayload>
/**
 * Model EmailOtp
 * 
 */
export type EmailOtp = $Result.DefaultSelection<Prisma.$EmailOtpPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CompanyType: {
  seller: 'seller',
  buyer: 'buyer'
};

export type CompanyType = (typeof CompanyType)[keyof typeof CompanyType]


export const UserRole: {
  admin: 'admin',
  user: 'user'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TaxType: {
  FIXED: 'FIXED',
  VARIABLE: 'VARIABLE'
};

export type TaxType = (typeof TaxType)[keyof typeof TaxType]


export const paymentType: {
  Credit: 'Credit',
  Cash: 'Cash'
};

export type paymentType = (typeof paymentType)[keyof typeof paymentType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  PAID: 'PAID',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const OrderType: {
  STANDARD: 'STANDARD',
  BOOKING: 'BOOKING',
  TRY_AT_HOME: 'TRY_AT_HOME',
  BILL: 'BILL'
};

export type OrderType = (typeof OrderType)[keyof typeof OrderType]


export const OrderStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  PACKED: 'PACKED',
  DELIVERED: 'DELIVERED',
  CANCELED: 'CANCELED',
  OUTOFSTOCK: 'OUTOFSTOCK',
  BOOKED: 'BOOKED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMode: {
  CASH: 'CASH',
  CARD: 'CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  UPI: 'UPI'
};

export type PaymentMode = (typeof PaymentMode)[keyof typeof PaymentMode]


export const NotificationType: {
  ORDER_RECEIVED: 'ORDER_RECEIVED',
  BILL_CREATED: 'BILL_CREATED',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',
  EXPENSE_CREATED: 'EXPENSE_CREATED',
  INVENTORY_LOW: 'INVENTORY_LOW',
  SHIPMENT_SENT: 'SHIPMENT_SENT',
  SYSTEM_ALERT: 'SYSTEM_ALERT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type CompanyType = $Enums.CompanyType

export const CompanyType: typeof $Enums.CompanyType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TaxType = $Enums.TaxType

export const TaxType: typeof $Enums.TaxType

export type paymentType = $Enums.paymentType

export const paymentType: typeof $Enums.paymentType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type OrderType = $Enums.OrderType

export const OrderType: typeof $Enums.OrderType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMode = $Enums.PaymentMode

export const PaymentMode: typeof $Enums.PaymentMode

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.distributor`: Exposes CRUD operations for the **Distributor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Distributors
    * const distributors = await prisma.distributor.findMany()
    * ```
    */
  get distributor(): Prisma.DistributorDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): Prisma.PipelineDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.subcategory`: Exposes CRUD operations for the **Subcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subcategories
    * const subcategories = await prisma.subcategory.findMany()
    * ```
    */
  get subcategory(): Prisma.SubcategoryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.variant`: Exposes CRUD operations for the **Variant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variants
    * const variants = await prisma.variant.findMany()
    * ```
    */
  get variant(): Prisma.VariantDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs>;

  /**
   * `prisma.tokenEntry`: Exposes CRUD operations for the **TokenEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenEntries
    * const tokenEntries = await prisma.tokenEntry.findMany()
    * ```
    */
  get tokenEntry(): Prisma.TokenEntryDelegate<ExtArgs>;

  /**
   * `prisma.entry`: Exposes CRUD operations for the **Entry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entries
    * const entries = await prisma.entry.findMany()
    * ```
    */
  get entry(): Prisma.EntryDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.companyUser`: Exposes CRUD operations for the **CompanyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyUsers
    * const companyUsers = await prisma.companyUser.findMany()
    * ```
    */
  get companyUser(): Prisma.CompanyUserDelegate<ExtArgs>;

  /**
   * `prisma.companyClient`: Exposes CRUD operations for the **CompanyClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyClients
    * const companyClients = await prisma.companyClient.findMany()
    * ```
    */
  get companyClient(): Prisma.CompanyClientDelegate<ExtArgs>;

  /**
   * `prisma.userConversation`: Exposes CRUD operations for the **UserConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConversations
    * const userConversations = await prisma.userConversation.findMany()
    * ```
    */
  get userConversation(): Prisma.UserConversationDelegate<ExtArgs>;

  /**
   * `prisma.clientConversation`: Exposes CRUD operations for the **ClientConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientConversations
    * const clientConversations = await prisma.clientConversation.findMany()
    * ```
    */
  get clientConversation(): Prisma.ClientConversationDelegate<ExtArgs>;

  /**
   * `prisma.userClient`: Exposes CRUD operations for the **UserClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserClients
    * const userClients = await prisma.userClient.findMany()
    * ```
    */
  get userClient(): Prisma.UserClientDelegate<ExtArgs>;

  /**
   * `prisma.distributorCompany`: Exposes CRUD operations for the **DistributorCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DistributorCompanies
    * const distributorCompanies = await prisma.distributorCompany.findMany()
    * ```
    */
  get distributorCompany(): Prisma.DistributorCompanyDelegate<ExtArgs>;

  /**
   * `prisma.variantSizeBarcode`: Exposes CRUD operations for the **VariantSizeBarcode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariantSizeBarcodes
    * const variantSizeBarcodes = await prisma.variantSizeBarcode.findMany()
    * ```
    */
  get variantSizeBarcode(): Prisma.VariantSizeBarcodeDelegate<ExtArgs>;

  /**
   * `prisma.emailOtp`: Exposes CRUD operations for the **EmailOtp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailOtps
    * const emailOtps = await prisma.emailOtp.findMany()
    * ```
    */
  get emailOtp(): Prisma.EmailOtpDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    Distributor: 'Distributor',
    User: 'User',
    Client: 'Client',
    Pipeline: 'Pipeline',
    Category: 'Category',
    Subcategory: 'Subcategory',
    Product: 'Product',
    Variant: 'Variant',
    Item: 'Item',
    PurchaseOrder: 'PurchaseOrder',
    Bill: 'Bill',
    TokenEntry: 'TokenEntry',
    Entry: 'Entry',
    Account: 'Account',
    ExpenseCategory: 'ExpenseCategory',
    Expense: 'Expense',
    Payment: 'Payment',
    Address: 'Address',
    Conversation: 'Conversation',
    Message: 'Message',
    CompanyUser: 'CompanyUser',
    CompanyClient: 'CompanyClient',
    UserConversation: 'UserConversation',
    ClientConversation: 'ClientConversation',
    UserClient: 'UserClient',
    DistributorCompany: 'DistributorCompany',
    VariantSizeBarcode: 'VariantSizeBarcode',
    EmailOtp: 'EmailOtp',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "company" | "distributor" | "user" | "client" | "pipeline" | "category" | "subcategory" | "product" | "variant" | "item" | "purchaseOrder" | "bill" | "tokenEntry" | "entry" | "account" | "expenseCategory" | "expense" | "payment" | "address" | "conversation" | "message" | "companyUser" | "companyClient" | "userConversation" | "clientConversation" | "userClient" | "distributorCompany" | "variantSizeBarcode" | "emailOtp" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Distributor: {
        payload: Prisma.$DistributorPayload<ExtArgs>
        fields: Prisma.DistributorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          findFirst: {
            args: Prisma.DistributorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          findMany: {
            args: Prisma.DistributorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>[]
          }
          create: {
            args: Prisma.DistributorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          createMany: {
            args: Prisma.DistributorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistributorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>[]
          }
          delete: {
            args: Prisma.DistributorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          update: {
            args: Prisma.DistributorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          deleteMany: {
            args: Prisma.DistributorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          aggregate: {
            args: Prisma.DistributorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributor>
          }
          groupBy: {
            args: Prisma.DistributorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributorCountArgs<ExtArgs>
            result: $Utils.Optional<DistributorCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Pipeline: {
        payload: Prisma.$PipelinePayload<ExtArgs>
        fields: Prisma.PipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findFirst: {
            args: Prisma.PipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findMany: {
            args: Prisma.PipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          create: {
            args: Prisma.PipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          createMany: {
            args: Prisma.PipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          delete: {
            args: Prisma.PipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          update: {
            args: Prisma.PipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          deleteMany: {
            args: Prisma.PipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          aggregate: {
            args: Prisma.PipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipeline>
          }
          groupBy: {
            args: Prisma.PipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Subcategory: {
        payload: Prisma.$SubcategoryPayload<ExtArgs>
        fields: Prisma.SubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findFirst: {
            args: Prisma.SubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findMany: {
            args: Prisma.SubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          create: {
            args: Prisma.SubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          createMany: {
            args: Prisma.SubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          delete: {
            args: Prisma.SubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          update: {
            args: Prisma.SubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          aggregate: {
            args: Prisma.SubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubcategory>
          }
          groupBy: {
            args: Prisma.SubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Variant: {
        payload: Prisma.$VariantPayload<ExtArgs>
        fields: Prisma.VariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          findFirst: {
            args: Prisma.VariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          findMany: {
            args: Prisma.VariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          create: {
            args: Prisma.VariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          createMany: {
            args: Prisma.VariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          delete: {
            args: Prisma.VariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          update: {
            args: Prisma.VariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          deleteMany: {
            args: Prisma.VariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          aggregate: {
            args: Prisma.VariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariant>
          }
          groupBy: {
            args: Prisma.VariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantCountArgs<ExtArgs>
            result: $Utils.Optional<VariantCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      TokenEntry: {
        payload: Prisma.$TokenEntryPayload<ExtArgs>
        fields: Prisma.TokenEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>
          }
          findFirst: {
            args: Prisma.TokenEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>
          }
          findMany: {
            args: Prisma.TokenEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>[]
          }
          create: {
            args: Prisma.TokenEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>
          }
          createMany: {
            args: Prisma.TokenEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>[]
          }
          delete: {
            args: Prisma.TokenEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>
          }
          update: {
            args: Prisma.TokenEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>
          }
          deleteMany: {
            args: Prisma.TokenEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenEntryPayload>
          }
          aggregate: {
            args: Prisma.TokenEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenEntry>
          }
          groupBy: {
            args: Prisma.TokenEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenEntryCountArgs<ExtArgs>
            result: $Utils.Optional<TokenEntryCountAggregateOutputType> | number
          }
        }
      }
      Entry: {
        payload: Prisma.$EntryPayload<ExtArgs>
        fields: Prisma.EntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          findFirst: {
            args: Prisma.EntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          findMany: {
            args: Prisma.EntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>[]
          }
          create: {
            args: Prisma.EntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          createMany: {
            args: Prisma.EntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>[]
          }
          delete: {
            args: Prisma.EntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          update: {
            args: Prisma.EntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          deleteMany: {
            args: Prisma.EntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          aggregate: {
            args: Prisma.EntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntry>
          }
          groupBy: {
            args: Prisma.EntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntryCountArgs<ExtArgs>
            result: $Utils.Optional<EntryCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      CompanyUser: {
        payload: Prisma.$CompanyUserPayload<ExtArgs>
        fields: Prisma.CompanyUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findFirst: {
            args: Prisma.CompanyUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findMany: {
            args: Prisma.CompanyUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          create: {
            args: Prisma.CompanyUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          createMany: {
            args: Prisma.CompanyUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          delete: {
            args: Prisma.CompanyUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          update: {
            args: Prisma.CompanyUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          deleteMany: {
            args: Prisma.CompanyUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          aggregate: {
            args: Prisma.CompanyUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyUser>
          }
          groupBy: {
            args: Prisma.CompanyUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyUserCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyUserCountAggregateOutputType> | number
          }
        }
      }
      CompanyClient: {
        payload: Prisma.$CompanyClientPayload<ExtArgs>
        fields: Prisma.CompanyClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>
          }
          findFirst: {
            args: Prisma.CompanyClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>
          }
          findMany: {
            args: Prisma.CompanyClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>[]
          }
          create: {
            args: Prisma.CompanyClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>
          }
          createMany: {
            args: Prisma.CompanyClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>[]
          }
          delete: {
            args: Prisma.CompanyClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>
          }
          update: {
            args: Prisma.CompanyClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>
          }
          deleteMany: {
            args: Prisma.CompanyClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyClientPayload>
          }
          aggregate: {
            args: Prisma.CompanyClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyClient>
          }
          groupBy: {
            args: Prisma.CompanyClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyClientCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyClientCountAggregateOutputType> | number
          }
        }
      }
      UserConversation: {
        payload: Prisma.$UserConversationPayload<ExtArgs>
        fields: Prisma.UserConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>
          }
          findFirst: {
            args: Prisma.UserConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>
          }
          findMany: {
            args: Prisma.UserConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>[]
          }
          create: {
            args: Prisma.UserConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>
          }
          createMany: {
            args: Prisma.UserConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>[]
          }
          delete: {
            args: Prisma.UserConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>
          }
          update: {
            args: Prisma.UserConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>
          }
          deleteMany: {
            args: Prisma.UserConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationPayload>
          }
          aggregate: {
            args: Prisma.UserConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConversation>
          }
          groupBy: {
            args: Prisma.UserConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConversationCountArgs<ExtArgs>
            result: $Utils.Optional<UserConversationCountAggregateOutputType> | number
          }
        }
      }
      ClientConversation: {
        payload: Prisma.$ClientConversationPayload<ExtArgs>
        fields: Prisma.ClientConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>
          }
          findFirst: {
            args: Prisma.ClientConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>
          }
          findMany: {
            args: Prisma.ClientConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>[]
          }
          create: {
            args: Prisma.ClientConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>
          }
          createMany: {
            args: Prisma.ClientConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>[]
          }
          delete: {
            args: Prisma.ClientConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>
          }
          update: {
            args: Prisma.ClientConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>
          }
          deleteMany: {
            args: Prisma.ClientConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientConversationPayload>
          }
          aggregate: {
            args: Prisma.ClientConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientConversation>
          }
          groupBy: {
            args: Prisma.ClientConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ClientConversationCountAggregateOutputType> | number
          }
        }
      }
      UserClient: {
        payload: Prisma.$UserClientPayload<ExtArgs>
        fields: Prisma.UserClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>
          }
          findFirst: {
            args: Prisma.UserClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>
          }
          findMany: {
            args: Prisma.UserClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>[]
          }
          create: {
            args: Prisma.UserClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>
          }
          createMany: {
            args: Prisma.UserClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>[]
          }
          delete: {
            args: Prisma.UserClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>
          }
          update: {
            args: Prisma.UserClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>
          }
          deleteMany: {
            args: Prisma.UserClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClientPayload>
          }
          aggregate: {
            args: Prisma.UserClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserClient>
          }
          groupBy: {
            args: Prisma.UserClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserClientCountArgs<ExtArgs>
            result: $Utils.Optional<UserClientCountAggregateOutputType> | number
          }
        }
      }
      DistributorCompany: {
        payload: Prisma.$DistributorCompanyPayload<ExtArgs>
        fields: Prisma.DistributorCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributorCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributorCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>
          }
          findFirst: {
            args: Prisma.DistributorCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributorCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>
          }
          findMany: {
            args: Prisma.DistributorCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>[]
          }
          create: {
            args: Prisma.DistributorCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>
          }
          createMany: {
            args: Prisma.DistributorCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistributorCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>[]
          }
          delete: {
            args: Prisma.DistributorCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>
          }
          update: {
            args: Prisma.DistributorCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>
          }
          deleteMany: {
            args: Prisma.DistributorCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributorCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributorCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorCompanyPayload>
          }
          aggregate: {
            args: Prisma.DistributorCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributorCompany>
          }
          groupBy: {
            args: Prisma.DistributorCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributorCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributorCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<DistributorCompanyCountAggregateOutputType> | number
          }
        }
      }
      VariantSizeBarcode: {
        payload: Prisma.$VariantSizeBarcodePayload<ExtArgs>
        fields: Prisma.VariantSizeBarcodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantSizeBarcodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantSizeBarcodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>
          }
          findFirst: {
            args: Prisma.VariantSizeBarcodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantSizeBarcodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>
          }
          findMany: {
            args: Prisma.VariantSizeBarcodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>[]
          }
          create: {
            args: Prisma.VariantSizeBarcodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>
          }
          createMany: {
            args: Prisma.VariantSizeBarcodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantSizeBarcodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>[]
          }
          delete: {
            args: Prisma.VariantSizeBarcodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>
          }
          update: {
            args: Prisma.VariantSizeBarcodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>
          }
          deleteMany: {
            args: Prisma.VariantSizeBarcodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantSizeBarcodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VariantSizeBarcodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantSizeBarcodePayload>
          }
          aggregate: {
            args: Prisma.VariantSizeBarcodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariantSizeBarcode>
          }
          groupBy: {
            args: Prisma.VariantSizeBarcodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantSizeBarcodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantSizeBarcodeCountArgs<ExtArgs>
            result: $Utils.Optional<VariantSizeBarcodeCountAggregateOutputType> | number
          }
        }
      }
      EmailOtp: {
        payload: Prisma.$EmailOtpPayload<ExtArgs>
        fields: Prisma.EmailOtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailOtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailOtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>
          }
          findFirst: {
            args: Prisma.EmailOtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailOtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>
          }
          findMany: {
            args: Prisma.EmailOtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>[]
          }
          create: {
            args: Prisma.EmailOtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>
          }
          createMany: {
            args: Prisma.EmailOtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailOtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>[]
          }
          delete: {
            args: Prisma.EmailOtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>
          }
          update: {
            args: Prisma.EmailOtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>
          }
          deleteMany: {
            args: Prisma.EmailOtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailOtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailOtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailOtpPayload>
          }
          aggregate: {
            args: Prisma.EmailOtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailOtp>
          }
          groupBy: {
            args: Prisma.EmailOtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailOtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailOtpCountArgs<ExtArgs>
            result: $Utils.Optional<EmailOtpCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    clients: number
    products: number
    categories: number
    subcategories: number
    bills: number
    tokenbills: number
    accounts: number
    expenseCategories: number
    expenses: number
    payment: number
    variants: number
    purchaseOrders: number
    items: number
    notifications: number
    distributor: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    clients?: boolean | CompanyCountOutputTypeCountClientsArgs
    products?: boolean | CompanyCountOutputTypeCountProductsArgs
    categories?: boolean | CompanyCountOutputTypeCountCategoriesArgs
    subcategories?: boolean | CompanyCountOutputTypeCountSubcategoriesArgs
    bills?: boolean | CompanyCountOutputTypeCountBillsArgs
    tokenbills?: boolean | CompanyCountOutputTypeCountTokenbillsArgs
    accounts?: boolean | CompanyCountOutputTypeCountAccountsArgs
    expenseCategories?: boolean | CompanyCountOutputTypeCountExpenseCategoriesArgs
    expenses?: boolean | CompanyCountOutputTypeCountExpensesArgs
    payment?: boolean | CompanyCountOutputTypeCountPaymentArgs
    variants?: boolean | CompanyCountOutputTypeCountVariantsArgs
    purchaseOrders?: boolean | CompanyCountOutputTypeCountPurchaseOrdersArgs
    items?: boolean | CompanyCountOutputTypeCountItemsArgs
    notifications?: boolean | CompanyCountOutputTypeCountNotificationsArgs
    distributor?: boolean | CompanyCountOutputTypeCountDistributorArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyClientWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTokenbillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenEntryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExpenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDistributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributorCompanyWhereInput
  }


  /**
   * Count Type DistributorCountOutputType
   */

  export type DistributorCountOutputType = {
    companies: number
    purchaseorders: number
  }

  export type DistributorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | DistributorCountOutputTypeCountCompaniesArgs
    purchaseorders?: boolean | DistributorCountOutputTypeCountPurchaseordersArgs
  }

  // Custom InputTypes
  /**
   * DistributorCountOutputType without action
   */
  export type DistributorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCountOutputType
     */
    select?: DistributorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistributorCountOutputType without action
   */
  export type DistributorCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributorCompanyWhereInput
  }

  /**
   * DistributorCountOutputType without action
   */
  export type DistributorCountOutputTypeCountPurchaseordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    companies: number
    notifications: number
    conversations: number
    clients: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    clients?: boolean | UserCountOutputTypeCountClientsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClientWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    companies: number
    address: number
    conversations: number
    users: number
    notifications: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | ClientCountOutputTypeCountCompaniesArgs
    address?: boolean | ClientCountOutputTypeCountAddressArgs
    conversations?: boolean | ClientCountOutputTypeCountConversationsArgs
    users?: boolean | ClientCountOutputTypeCountUsersArgs
    notifications?: boolean | ClientCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyClientWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientConversationWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClientWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PipelineCountOutputType
   */

  export type PipelineCountOutputType = {
    newClients: number
    prospectClients: number
    viewingClients: number
    rejectClients: number
    closeClients: number
  }

  export type PipelineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newClients?: boolean | PipelineCountOutputTypeCountNewClientsArgs
    prospectClients?: boolean | PipelineCountOutputTypeCountProspectClientsArgs
    viewingClients?: boolean | PipelineCountOutputTypeCountViewingClientsArgs
    rejectClients?: boolean | PipelineCountOutputTypeCountRejectClientsArgs
    closeClients?: boolean | PipelineCountOutputTypeCountCloseClientsArgs
  }

  // Custom InputTypes
  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineCountOutputType
     */
    select?: PipelineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountNewClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountProspectClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountViewingClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountRejectClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountCloseClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    subcategories: number
    entries: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    subcategories?: boolean | CategoryCountOutputTypeCountSubcategoriesArgs
    entries?: boolean | CategoryCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntryWhereInput
  }


  /**
   * Count Type SubcategoryCountOutputType
   */

  export type SubcategoryCountOutputType = {
    products: number
  }

  export type SubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SubcategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcategoryCountOutputType
     */
    select?: SubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
  }


  /**
   * Count Type VariantCountOutputType
   */

  export type VariantCountOutputType = {
    items: number
    entries: number
    VariantSizeBarcode: number
  }

  export type VariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | VariantCountOutputTypeCountItemsArgs
    entries?: boolean | VariantCountOutputTypeCountEntriesArgs
    VariantSizeBarcode?: boolean | VariantCountOutputTypeCountVariantSizeBarcodeArgs
  }

  // Custom InputTypes
  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantCountOutputType
     */
    select?: VariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntryWhereInput
  }

  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeCountVariantSizeBarcodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantSizeBarcodeWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    products: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PurchaseOrderCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type BillCountOutputType
   */

  export type BillCountOutputType = {
    entries: number
  }

  export type BillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | BillCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillCountOutputType
     */
    select?: BillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntryWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    bill: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | AccountCountOutputTypeCountBillArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type ExpenseCategoryCountOutputType
   */

  export type ExpenseCategoryCountOutputType = {
    expenses: number
  }

  export type ExpenseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategoryCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategoryCountOutputType
     */
    select?: ExpenseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    bill: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | AddressCountOutputTypeCountBillArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountBillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    users: number
    clients: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    users?: boolean | ConversationCountOutputTypeCountUsersArgs
    clients?: boolean | ConversationCountOutputTypeCountClientsArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientConversationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    storecode: number | null
    tiktokAccessTokenExpireIn: number | null
    tiktokRefreshTokenExpireIn: number | null
    billCounter: number | null
    barcodeCounter: number | null
  }

  export type CompanySumAggregateOutputType = {
    storecode: number | null
    tiktokAccessTokenExpireIn: number | null
    tiktokRefreshTokenExpireIn: number | null
    billCounter: number | null
    barcodeCounter: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    storecode: number | null
    storeUniqueName: string | null
    logo: string | null
    description: string | null
    shopifyStoreName: string | null
    shopifyAccessToken: string | null
    tiktokCipher: string | null
    tiktokStoreName: string | null
    tiktokAccessToken: string | null
    tiktokAccessTokenExpireIn: number | null
    tiktokRefreshToken: string | null
    tiktokRefreshTokenExpireIn: number | null
    images: string | null
    isTaxIncluded: boolean | null
    status: boolean | null
    type: $Enums.CompanyType | null
    accHolderName: string | null
    ifsc: string | null
    accountNo: string | null
    bankName: string | null
    gstin: string | null
    upiId: string | null
    billCounter: number | null
    barcodeCounter: number | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    storecode: number | null
    storeUniqueName: string | null
    logo: string | null
    description: string | null
    shopifyStoreName: string | null
    shopifyAccessToken: string | null
    tiktokCipher: string | null
    tiktokStoreName: string | null
    tiktokAccessToken: string | null
    tiktokAccessTokenExpireIn: number | null
    tiktokRefreshToken: string | null
    tiktokRefreshTokenExpireIn: number | null
    images: string | null
    isTaxIncluded: boolean | null
    status: boolean | null
    type: $Enums.CompanyType | null
    accHolderName: string | null
    ifsc: string | null
    accountNo: string | null
    bankName: string | null
    gstin: string | null
    upiId: string | null
    billCounter: number | null
    barcodeCounter: number | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    storecode: number
    storeUniqueName: number
    logo: number
    description: number
    shopifyStoreName: number
    shopifyAccessToken: number
    tiktokCipher: number
    tiktokStoreName: number
    tiktokAccessToken: number
    tiktokAccessTokenExpireIn: number
    tiktokRefreshToken: number
    tiktokRefreshTokenExpireIn: number
    images: number
    isTaxIncluded: number
    status: number
    type: number
    accHolderName: number
    ifsc: number
    accountNo: number
    bankName: number
    gstin: number
    upiId: number
    billCounter: number
    barcodeCounter: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    storecode?: true
    tiktokAccessTokenExpireIn?: true
    tiktokRefreshTokenExpireIn?: true
    billCounter?: true
    barcodeCounter?: true
  }

  export type CompanySumAggregateInputType = {
    storecode?: true
    tiktokAccessTokenExpireIn?: true
    tiktokRefreshTokenExpireIn?: true
    billCounter?: true
    barcodeCounter?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    storecode?: true
    storeUniqueName?: true
    logo?: true
    description?: true
    shopifyStoreName?: true
    shopifyAccessToken?: true
    tiktokCipher?: true
    tiktokStoreName?: true
    tiktokAccessToken?: true
    tiktokAccessTokenExpireIn?: true
    tiktokRefreshToken?: true
    tiktokRefreshTokenExpireIn?: true
    images?: true
    isTaxIncluded?: true
    status?: true
    type?: true
    accHolderName?: true
    ifsc?: true
    accountNo?: true
    bankName?: true
    gstin?: true
    upiId?: true
    billCounter?: true
    barcodeCounter?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    storecode?: true
    storeUniqueName?: true
    logo?: true
    description?: true
    shopifyStoreName?: true
    shopifyAccessToken?: true
    tiktokCipher?: true
    tiktokStoreName?: true
    tiktokAccessToken?: true
    tiktokAccessTokenExpireIn?: true
    tiktokRefreshToken?: true
    tiktokRefreshTokenExpireIn?: true
    images?: true
    isTaxIncluded?: true
    status?: true
    type?: true
    accHolderName?: true
    ifsc?: true
    accountNo?: true
    bankName?: true
    gstin?: true
    upiId?: true
    billCounter?: true
    barcodeCounter?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    storecode?: true
    storeUniqueName?: true
    logo?: true
    description?: true
    shopifyStoreName?: true
    shopifyAccessToken?: true
    tiktokCipher?: true
    tiktokStoreName?: true
    tiktokAccessToken?: true
    tiktokAccessTokenExpireIn?: true
    tiktokRefreshToken?: true
    tiktokRefreshTokenExpireIn?: true
    images?: true
    isTaxIncluded?: true
    status?: true
    type?: true
    accHolderName?: true
    ifsc?: true
    accountNo?: true
    bankName?: true
    gstin?: true
    upiId?: true
    billCounter?: true
    barcodeCounter?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    storecode: number
    storeUniqueName: string | null
    logo: string | null
    description: string | null
    shopifyStoreName: string | null
    shopifyAccessToken: string | null
    tiktokCipher: string | null
    tiktokStoreName: string | null
    tiktokAccessToken: string | null
    tiktokAccessTokenExpireIn: number | null
    tiktokRefreshToken: string | null
    tiktokRefreshTokenExpireIn: number | null
    images: string | null
    isTaxIncluded: boolean
    status: boolean
    type: $Enums.CompanyType
    accHolderName: string | null
    ifsc: string | null
    accountNo: string | null
    bankName: string | null
    gstin: string | null
    upiId: string | null
    billCounter: number
    barcodeCounter: number
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storecode?: boolean
    storeUniqueName?: boolean
    logo?: boolean
    description?: boolean
    shopifyStoreName?: boolean
    shopifyAccessToken?: boolean
    tiktokCipher?: boolean
    tiktokStoreName?: boolean
    tiktokAccessToken?: boolean
    tiktokAccessTokenExpireIn?: boolean
    tiktokRefreshToken?: boolean
    tiktokRefreshTokenExpireIn?: boolean
    images?: boolean
    isTaxIncluded?: boolean
    status?: boolean
    type?: boolean
    accHolderName?: boolean
    ifsc?: boolean
    accountNo?: boolean
    bankName?: boolean
    gstin?: boolean
    upiId?: boolean
    billCounter?: boolean
    barcodeCounter?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    clients?: boolean | Company$clientsArgs<ExtArgs>
    products?: boolean | Company$productsArgs<ExtArgs>
    categories?: boolean | Company$categoriesArgs<ExtArgs>
    subcategories?: boolean | Company$subcategoriesArgs<ExtArgs>
    bills?: boolean | Company$billsArgs<ExtArgs>
    tokenbills?: boolean | Company$tokenbillsArgs<ExtArgs>
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    expenseCategories?: boolean | Company$expenseCategoriesArgs<ExtArgs>
    expenses?: boolean | Company$expensesArgs<ExtArgs>
    payment?: boolean | Company$paymentArgs<ExtArgs>
    variants?: boolean | Company$variantsArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    items?: boolean | Company$itemsArgs<ExtArgs>
    pipeline?: boolean | Company$pipelineArgs<ExtArgs>
    notifications?: boolean | Company$notificationsArgs<ExtArgs>
    address?: boolean | Company$addressArgs<ExtArgs>
    distributor?: boolean | Company$distributorArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storecode?: boolean
    storeUniqueName?: boolean
    logo?: boolean
    description?: boolean
    shopifyStoreName?: boolean
    shopifyAccessToken?: boolean
    tiktokCipher?: boolean
    tiktokStoreName?: boolean
    tiktokAccessToken?: boolean
    tiktokAccessTokenExpireIn?: boolean
    tiktokRefreshToken?: boolean
    tiktokRefreshTokenExpireIn?: boolean
    images?: boolean
    isTaxIncluded?: boolean
    status?: boolean
    type?: boolean
    accHolderName?: boolean
    ifsc?: boolean
    accountNo?: boolean
    bankName?: boolean
    gstin?: boolean
    upiId?: boolean
    billCounter?: boolean
    barcodeCounter?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    storecode?: boolean
    storeUniqueName?: boolean
    logo?: boolean
    description?: boolean
    shopifyStoreName?: boolean
    shopifyAccessToken?: boolean
    tiktokCipher?: boolean
    tiktokStoreName?: boolean
    tiktokAccessToken?: boolean
    tiktokAccessTokenExpireIn?: boolean
    tiktokRefreshToken?: boolean
    tiktokRefreshTokenExpireIn?: boolean
    images?: boolean
    isTaxIncluded?: boolean
    status?: boolean
    type?: boolean
    accHolderName?: boolean
    ifsc?: boolean
    accountNo?: boolean
    bankName?: boolean
    gstin?: boolean
    upiId?: boolean
    billCounter?: boolean
    barcodeCounter?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    clients?: boolean | Company$clientsArgs<ExtArgs>
    products?: boolean | Company$productsArgs<ExtArgs>
    categories?: boolean | Company$categoriesArgs<ExtArgs>
    subcategories?: boolean | Company$subcategoriesArgs<ExtArgs>
    bills?: boolean | Company$billsArgs<ExtArgs>
    tokenbills?: boolean | Company$tokenbillsArgs<ExtArgs>
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    expenseCategories?: boolean | Company$expenseCategoriesArgs<ExtArgs>
    expenses?: boolean | Company$expensesArgs<ExtArgs>
    payment?: boolean | Company$paymentArgs<ExtArgs>
    variants?: boolean | Company$variantsArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    items?: boolean | Company$itemsArgs<ExtArgs>
    pipeline?: boolean | Company$pipelineArgs<ExtArgs>
    notifications?: boolean | Company$notificationsArgs<ExtArgs>
    address?: boolean | Company$addressArgs<ExtArgs>
    distributor?: boolean | Company$distributorArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$CompanyUserPayload<ExtArgs>[]
      clients: Prisma.$CompanyClientPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      subcategories: Prisma.$SubcategoryPayload<ExtArgs>[]
      bills: Prisma.$BillPayload<ExtArgs>[]
      tokenbills: Prisma.$TokenEntryPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      expenseCategories: Prisma.$ExpenseCategoryPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs>[]
      variants: Prisma.$VariantPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      items: Prisma.$ItemPayload<ExtArgs>[]
      pipeline: Prisma.$PipelinePayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      address: Prisma.$AddressPayload<ExtArgs> | null
      distributor: Prisma.$DistributorCompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      storecode: number
      storeUniqueName: string | null
      logo: string | null
      description: string | null
      shopifyStoreName: string | null
      shopifyAccessToken: string | null
      tiktokCipher: string | null
      tiktokStoreName: string | null
      tiktokAccessToken: string | null
      tiktokAccessTokenExpireIn: number | null
      tiktokRefreshToken: string | null
      tiktokRefreshTokenExpireIn: number | null
      images: string | null
      isTaxIncluded: boolean
      status: boolean
      type: $Enums.CompanyType
      accHolderName: string | null
      ifsc: string | null
      accountNo: string | null
      bankName: string | null
      gstin: string | null
      upiId: string | null
      billCounter: number
      barcodeCounter: number
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany"> | Null>
    clients<T extends Company$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Company$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Company$productsArgs<ExtArgs> = {}>(args?: Subset<T, Company$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends Company$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    subcategories<T extends Company$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany"> | Null>
    bills<T extends Company$billsArgs<ExtArgs> = {}>(args?: Subset<T, Company$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany"> | Null>
    tokenbills<T extends Company$tokenbillsArgs<ExtArgs> = {}>(args?: Subset<T, Company$tokenbillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends Company$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    expenseCategories<T extends Company$expenseCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$expenseCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Company$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Company$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    payment<T extends Company$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Company$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    variants<T extends Company$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Company$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Company$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    items<T extends Company$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Company$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany"> | Null>
    pipeline<T extends Company$pipelineArgs<ExtArgs> = {}>(args?: Subset<T, Company$pipelineArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends Company$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    address<T extends Company$addressArgs<ExtArgs> = {}>(args?: Subset<T, Company$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    distributor<T extends Company$distributorArgs<ExtArgs> = {}>(args?: Subset<T, Company$distributorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly storecode: FieldRef<"Company", 'Int'>
    readonly storeUniqueName: FieldRef<"Company", 'String'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly shopifyStoreName: FieldRef<"Company", 'String'>
    readonly shopifyAccessToken: FieldRef<"Company", 'String'>
    readonly tiktokCipher: FieldRef<"Company", 'String'>
    readonly tiktokStoreName: FieldRef<"Company", 'String'>
    readonly tiktokAccessToken: FieldRef<"Company", 'String'>
    readonly tiktokAccessTokenExpireIn: FieldRef<"Company", 'Int'>
    readonly tiktokRefreshToken: FieldRef<"Company", 'String'>
    readonly tiktokRefreshTokenExpireIn: FieldRef<"Company", 'Int'>
    readonly images: FieldRef<"Company", 'String'>
    readonly isTaxIncluded: FieldRef<"Company", 'Boolean'>
    readonly status: FieldRef<"Company", 'Boolean'>
    readonly type: FieldRef<"Company", 'CompanyType'>
    readonly accHolderName: FieldRef<"Company", 'String'>
    readonly ifsc: FieldRef<"Company", 'String'>
    readonly accountNo: FieldRef<"Company", 'String'>
    readonly bankName: FieldRef<"Company", 'String'>
    readonly gstin: FieldRef<"Company", 'String'>
    readonly upiId: FieldRef<"Company", 'String'>
    readonly billCounter: FieldRef<"Company", 'Int'>
    readonly barcodeCounter: FieldRef<"Company", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * Company.clients
   */
  export type Company$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    where?: CompanyClientWhereInput
    orderBy?: CompanyClientOrderByWithRelationInput | CompanyClientOrderByWithRelationInput[]
    cursor?: CompanyClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyClientScalarFieldEnum | CompanyClientScalarFieldEnum[]
  }

  /**
   * Company.products
   */
  export type Company$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Company.categories
   */
  export type Company$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Company.subcategories
   */
  export type Company$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    cursor?: SubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Company.bills
   */
  export type Company$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Company.tokenbills
   */
  export type Company$tokenbillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    where?: TokenEntryWhereInput
    orderBy?: TokenEntryOrderByWithRelationInput | TokenEntryOrderByWithRelationInput[]
    cursor?: TokenEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenEntryScalarFieldEnum | TokenEntryScalarFieldEnum[]
  }

  /**
   * Company.accounts
   */
  export type Company$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Company.expenseCategories
   */
  export type Company$expenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    cursor?: ExpenseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * Company.expenses
   */
  export type Company$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Company.payment
   */
  export type Company$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Company.variants
   */
  export type Company$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    cursor?: VariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Company.purchaseOrders
   */
  export type Company$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Company.items
   */
  export type Company$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Company.pipeline
   */
  export type Company$pipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
  }

  /**
   * Company.notifications
   */
  export type Company$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Company.address
   */
  export type Company$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Company.distributor
   */
  export type Company$distributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    where?: DistributorCompanyWhereInput
    orderBy?: DistributorCompanyOrderByWithRelationInput | DistributorCompanyOrderByWithRelationInput[]
    cursor?: DistributorCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistributorCompanyScalarFieldEnum | DistributorCompanyScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Distributor
   */

  export type AggregateDistributor = {
    _count: DistributorCountAggregateOutputType | null
    _min: DistributorMinAggregateOutputType | null
    _max: DistributorMaxAggregateOutputType | null
  }

  export type DistributorMinAggregateOutputType = {
    id: string | null
    name: string | null
    images: string | null
    status: boolean | null
    accHolderName: string | null
    ifsc: string | null
    accountNo: string | null
    bankName: string | null
    gstin: string | null
  }

  export type DistributorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    images: string | null
    status: boolean | null
    accHolderName: string | null
    ifsc: string | null
    accountNo: string | null
    bankName: string | null
    gstin: string | null
  }

  export type DistributorCountAggregateOutputType = {
    id: number
    name: number
    images: number
    status: number
    accHolderName: number
    ifsc: number
    accountNo: number
    bankName: number
    gstin: number
    _all: number
  }


  export type DistributorMinAggregateInputType = {
    id?: true
    name?: true
    images?: true
    status?: true
    accHolderName?: true
    ifsc?: true
    accountNo?: true
    bankName?: true
    gstin?: true
  }

  export type DistributorMaxAggregateInputType = {
    id?: true
    name?: true
    images?: true
    status?: true
    accHolderName?: true
    ifsc?: true
    accountNo?: true
    bankName?: true
    gstin?: true
  }

  export type DistributorCountAggregateInputType = {
    id?: true
    name?: true
    images?: true
    status?: true
    accHolderName?: true
    ifsc?: true
    accountNo?: true
    bankName?: true
    gstin?: true
    _all?: true
  }

  export type DistributorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distributor to aggregate.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Distributors
    **/
    _count?: true | DistributorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributorMaxAggregateInputType
  }

  export type GetDistributorAggregateType<T extends DistributorAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributor[P]>
      : GetScalarType<T[P], AggregateDistributor[P]>
  }




  export type DistributorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributorWhereInput
    orderBy?: DistributorOrderByWithAggregationInput | DistributorOrderByWithAggregationInput[]
    by: DistributorScalarFieldEnum[] | DistributorScalarFieldEnum
    having?: DistributorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributorCountAggregateInputType | true
    _min?: DistributorMinAggregateInputType
    _max?: DistributorMaxAggregateInputType
  }

  export type DistributorGroupByOutputType = {
    id: string
    name: string
    images: string | null
    status: boolean
    accHolderName: string | null
    ifsc: string | null
    accountNo: string | null
    bankName: string | null
    gstin: string | null
    _count: DistributorCountAggregateOutputType | null
    _min: DistributorMinAggregateOutputType | null
    _max: DistributorMaxAggregateOutputType | null
  }

  type GetDistributorGroupByPayload<T extends DistributorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributorGroupByOutputType[P]>
            : GetScalarType<T[P], DistributorGroupByOutputType[P]>
        }
      >
    >


  export type DistributorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    images?: boolean
    status?: boolean
    accHolderName?: boolean
    ifsc?: boolean
    accountNo?: boolean
    bankName?: boolean
    gstin?: boolean
    companies?: boolean | Distributor$companiesArgs<ExtArgs>
    purchaseorders?: boolean | Distributor$purchaseordersArgs<ExtArgs>
    address?: boolean | Distributor$addressArgs<ExtArgs>
    _count?: boolean | DistributorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributor"]>

  export type DistributorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    images?: boolean
    status?: boolean
    accHolderName?: boolean
    ifsc?: boolean
    accountNo?: boolean
    bankName?: boolean
    gstin?: boolean
  }, ExtArgs["result"]["distributor"]>

  export type DistributorSelectScalar = {
    id?: boolean
    name?: boolean
    images?: boolean
    status?: boolean
    accHolderName?: boolean
    ifsc?: boolean
    accountNo?: boolean
    bankName?: boolean
    gstin?: boolean
  }

  export type DistributorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | Distributor$companiesArgs<ExtArgs>
    purchaseorders?: boolean | Distributor$purchaseordersArgs<ExtArgs>
    address?: boolean | Distributor$addressArgs<ExtArgs>
    _count?: boolean | DistributorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistributorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DistributorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Distributor"
    objects: {
      companies: Prisma.$DistributorCompanyPayload<ExtArgs>[]
      purchaseorders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      address: Prisma.$AddressPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      images: string | null
      status: boolean
      accHolderName: string | null
      ifsc: string | null
      accountNo: string | null
      bankName: string | null
      gstin: string | null
    }, ExtArgs["result"]["distributor"]>
    composites: {}
  }

  type DistributorGetPayload<S extends boolean | null | undefined | DistributorDefaultArgs> = $Result.GetResult<Prisma.$DistributorPayload, S>

  type DistributorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistributorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistributorCountAggregateInputType | true
    }

  export interface DistributorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Distributor'], meta: { name: 'Distributor' } }
    /**
     * Find zero or one Distributor that matches the filter.
     * @param {DistributorFindUniqueArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributorFindUniqueArgs>(args: SelectSubset<T, DistributorFindUniqueArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Distributor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistributorFindUniqueOrThrowArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributorFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Distributor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindFirstArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributorFindFirstArgs>(args?: SelectSubset<T, DistributorFindFirstArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Distributor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindFirstOrThrowArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributorFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Distributors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Distributors
     * const distributors = await prisma.distributor.findMany()
     * 
     * // Get first 10 Distributors
     * const distributors = await prisma.distributor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributorWithIdOnly = await prisma.distributor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistributorFindManyArgs>(args?: SelectSubset<T, DistributorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Distributor.
     * @param {DistributorCreateArgs} args - Arguments to create a Distributor.
     * @example
     * // Create one Distributor
     * const Distributor = await prisma.distributor.create({
     *   data: {
     *     // ... data to create a Distributor
     *   }
     * })
     * 
     */
    create<T extends DistributorCreateArgs>(args: SelectSubset<T, DistributorCreateArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Distributors.
     * @param {DistributorCreateManyArgs} args - Arguments to create many Distributors.
     * @example
     * // Create many Distributors
     * const distributor = await prisma.distributor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributorCreateManyArgs>(args?: SelectSubset<T, DistributorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Distributors and returns the data saved in the database.
     * @param {DistributorCreateManyAndReturnArgs} args - Arguments to create many Distributors.
     * @example
     * // Create many Distributors
     * const distributor = await prisma.distributor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Distributors and only return the `id`
     * const distributorWithIdOnly = await prisma.distributor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistributorCreateManyAndReturnArgs>(args?: SelectSubset<T, DistributorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Distributor.
     * @param {DistributorDeleteArgs} args - Arguments to delete one Distributor.
     * @example
     * // Delete one Distributor
     * const Distributor = await prisma.distributor.delete({
     *   where: {
     *     // ... filter to delete one Distributor
     *   }
     * })
     * 
     */
    delete<T extends DistributorDeleteArgs>(args: SelectSubset<T, DistributorDeleteArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Distributor.
     * @param {DistributorUpdateArgs} args - Arguments to update one Distributor.
     * @example
     * // Update one Distributor
     * const distributor = await prisma.distributor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributorUpdateArgs>(args: SelectSubset<T, DistributorUpdateArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Distributors.
     * @param {DistributorDeleteManyArgs} args - Arguments to filter Distributors to delete.
     * @example
     * // Delete a few Distributors
     * const { count } = await prisma.distributor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributorDeleteManyArgs>(args?: SelectSubset<T, DistributorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Distributors
     * const distributor = await prisma.distributor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributorUpdateManyArgs>(args: SelectSubset<T, DistributorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Distributor.
     * @param {DistributorUpsertArgs} args - Arguments to update or create a Distributor.
     * @example
     * // Update or create a Distributor
     * const distributor = await prisma.distributor.upsert({
     *   create: {
     *     // ... data to create a Distributor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Distributor we want to update
     *   }
     * })
     */
    upsert<T extends DistributorUpsertArgs>(args: SelectSubset<T, DistributorUpsertArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Distributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCountArgs} args - Arguments to filter Distributors to count.
     * @example
     * // Count the number of Distributors
     * const count = await prisma.distributor.count({
     *   where: {
     *     // ... the filter for the Distributors we want to count
     *   }
     * })
    **/
    count<T extends DistributorCountArgs>(
      args?: Subset<T, DistributorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Distributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributorAggregateArgs>(args: Subset<T, DistributorAggregateArgs>): Prisma.PrismaPromise<GetDistributorAggregateType<T>>

    /**
     * Group by Distributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributorGroupByArgs['orderBy'] }
        : { orderBy?: DistributorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Distributor model
   */
  readonly fields: DistributorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Distributor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends Distributor$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Distributor$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseorders<T extends Distributor$purchaseordersArgs<ExtArgs> = {}>(args?: Subset<T, Distributor$purchaseordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    address<T extends Distributor$addressArgs<ExtArgs> = {}>(args?: Subset<T, Distributor$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Distributor model
   */ 
  interface DistributorFieldRefs {
    readonly id: FieldRef<"Distributor", 'String'>
    readonly name: FieldRef<"Distributor", 'String'>
    readonly images: FieldRef<"Distributor", 'String'>
    readonly status: FieldRef<"Distributor", 'Boolean'>
    readonly accHolderName: FieldRef<"Distributor", 'String'>
    readonly ifsc: FieldRef<"Distributor", 'String'>
    readonly accountNo: FieldRef<"Distributor", 'String'>
    readonly bankName: FieldRef<"Distributor", 'String'>
    readonly gstin: FieldRef<"Distributor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Distributor findUnique
   */
  export type DistributorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor findUniqueOrThrow
   */
  export type DistributorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor findFirst
   */
  export type DistributorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distributors.
     */
    distinct?: DistributorScalarFieldEnum | DistributorScalarFieldEnum[]
  }

  /**
   * Distributor findFirstOrThrow
   */
  export type DistributorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distributors.
     */
    distinct?: DistributorScalarFieldEnum | DistributorScalarFieldEnum[]
  }

  /**
   * Distributor findMany
   */
  export type DistributorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributors to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    distinct?: DistributorScalarFieldEnum | DistributorScalarFieldEnum[]
  }

  /**
   * Distributor create
   */
  export type DistributorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The data needed to create a Distributor.
     */
    data: XOR<DistributorCreateInput, DistributorUncheckedCreateInput>
  }

  /**
   * Distributor createMany
   */
  export type DistributorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Distributors.
     */
    data: DistributorCreateManyInput | DistributorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Distributor createManyAndReturn
   */
  export type DistributorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Distributors.
     */
    data: DistributorCreateManyInput | DistributorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Distributor update
   */
  export type DistributorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The data needed to update a Distributor.
     */
    data: XOR<DistributorUpdateInput, DistributorUncheckedUpdateInput>
    /**
     * Choose, which Distributor to update.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor updateMany
   */
  export type DistributorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Distributors.
     */
    data: XOR<DistributorUpdateManyMutationInput, DistributorUncheckedUpdateManyInput>
    /**
     * Filter which Distributors to update
     */
    where?: DistributorWhereInput
  }

  /**
   * Distributor upsert
   */
  export type DistributorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The filter to search for the Distributor to update in case it exists.
     */
    where: DistributorWhereUniqueInput
    /**
     * In case the Distributor found by the `where` argument doesn't exist, create a new Distributor with this data.
     */
    create: XOR<DistributorCreateInput, DistributorUncheckedCreateInput>
    /**
     * In case the Distributor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributorUpdateInput, DistributorUncheckedUpdateInput>
  }

  /**
   * Distributor delete
   */
  export type DistributorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter which Distributor to delete.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor deleteMany
   */
  export type DistributorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distributors to delete
     */
    where?: DistributorWhereInput
  }

  /**
   * Distributor.companies
   */
  export type Distributor$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    where?: DistributorCompanyWhereInput
    orderBy?: DistributorCompanyOrderByWithRelationInput | DistributorCompanyOrderByWithRelationInput[]
    cursor?: DistributorCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistributorCompanyScalarFieldEnum | DistributorCompanyScalarFieldEnum[]
  }

  /**
   * Distributor.purchaseorders
   */
  export type Distributor$purchaseordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Distributor.address
   */
  export type Distributor$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Distributor without action
   */
  export type DistributorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    status: boolean | null
    role: $Enums.UserRole | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    status: boolean | null
    role: $Enums.UserRole | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    status: number
    role: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    status?: true
    role?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    status?: true
    role?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    status?: true
    role?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    password: string
    status: boolean
    role: $Enums.UserRole
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    image?: boolean
    companies?: boolean | User$companiesArgs<ExtArgs>
    address?: boolean | User$addressArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    image?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    image?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | User$companiesArgs<ExtArgs>
    address?: boolean | User$addressArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      companies: Prisma.$CompanyUserPayload<ExtArgs>[]
      address: Prisma.$AddressPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      conversations: Prisma.$UserConversationPayload<ExtArgs>[]
      clients: Prisma.$UserClientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      password: string
      status: boolean
      role: $Enums.UserRole
      image: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany"> | Null>
    address<T extends User$addressArgs<ExtArgs> = {}>(args?: Subset<T, User$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findMany"> | Null>
    clients<T extends User$clientsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly image: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * User.address
   */
  export type User$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    where?: UserConversationWhereInput
    orderBy?: UserConversationOrderByWithRelationInput | UserConversationOrderByWithRelationInput[]
    cursor?: UserConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConversationScalarFieldEnum | UserConversationScalarFieldEnum[]
  }

  /**
   * User.clients
   */
  export type User$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    where?: UserClientWhereInput
    orderBy?: UserClientOrderByWithRelationInput | UserClientOrderByWithRelationInput[]
    cursor?: UserClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserClientScalarFieldEnum | UserClientScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    phone: string | null
    status: boolean | null
    pipelineStatus: string | null
    newPipelineId: string | null
    prospectPipelineId: string | null
    viewingPipelineId: string | null
    rejectPipelineId: string | null
    closePipelineId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    phone: string | null
    status: boolean | null
    pipelineStatus: string | null
    newPipelineId: string | null
    prospectPipelineId: string | null
    viewingPipelineId: string | null
    rejectPipelineId: string | null
    closePipelineId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    phone: number
    status: number
    pipelineStatus: number
    newPipelineId: number
    prospectPipelineId: number
    viewingPipelineId: number
    rejectPipelineId: number
    closePipelineId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    phone?: true
    status?: true
    pipelineStatus?: true
    newPipelineId?: true
    prospectPipelineId?: true
    viewingPipelineId?: true
    rejectPipelineId?: true
    closePipelineId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    phone?: true
    status?: true
    pipelineStatus?: true
    newPipelineId?: true
    prospectPipelineId?: true
    viewingPipelineId?: true
    rejectPipelineId?: true
    closePipelineId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    phone?: true
    status?: true
    pipelineStatus?: true
    newPipelineId?: true
    prospectPipelineId?: true
    viewingPipelineId?: true
    rejectPipelineId?: true
    closePipelineId?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    email: string | null
    name: string
    password: string | null
    phone: string
    status: boolean
    pipelineStatus: string
    newPipelineId: string | null
    prospectPipelineId: string | null
    viewingPipelineId: string | null
    rejectPipelineId: string | null
    closePipelineId: string | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    status?: boolean
    pipelineStatus?: boolean
    newPipelineId?: boolean
    prospectPipelineId?: boolean
    viewingPipelineId?: boolean
    rejectPipelineId?: boolean
    closePipelineId?: boolean
    companies?: boolean | Client$companiesArgs<ExtArgs>
    address?: boolean | Client$addressArgs<ExtArgs>
    bill?: boolean | Client$billArgs<ExtArgs>
    conversations?: boolean | Client$conversationsArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    newPipeline?: boolean | Client$newPipelineArgs<ExtArgs>
    prospectPipeline?: boolean | Client$prospectPipelineArgs<ExtArgs>
    viewingPipeline?: boolean | Client$viewingPipelineArgs<ExtArgs>
    rejectPipeline?: boolean | Client$rejectPipelineArgs<ExtArgs>
    closePipeline?: boolean | Client$closePipelineArgs<ExtArgs>
    notifications?: boolean | Client$notificationsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    status?: boolean
    pipelineStatus?: boolean
    newPipelineId?: boolean
    prospectPipelineId?: boolean
    viewingPipelineId?: boolean
    rejectPipelineId?: boolean
    closePipelineId?: boolean
    newPipeline?: boolean | Client$newPipelineArgs<ExtArgs>
    prospectPipeline?: boolean | Client$prospectPipelineArgs<ExtArgs>
    viewingPipeline?: boolean | Client$viewingPipelineArgs<ExtArgs>
    rejectPipeline?: boolean | Client$rejectPipelineArgs<ExtArgs>
    closePipeline?: boolean | Client$closePipelineArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    status?: boolean
    pipelineStatus?: boolean
    newPipelineId?: boolean
    prospectPipelineId?: boolean
    viewingPipelineId?: boolean
    rejectPipelineId?: boolean
    closePipelineId?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | Client$companiesArgs<ExtArgs>
    address?: boolean | Client$addressArgs<ExtArgs>
    bill?: boolean | Client$billArgs<ExtArgs>
    conversations?: boolean | Client$conversationsArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    newPipeline?: boolean | Client$newPipelineArgs<ExtArgs>
    prospectPipeline?: boolean | Client$prospectPipelineArgs<ExtArgs>
    viewingPipeline?: boolean | Client$viewingPipelineArgs<ExtArgs>
    rejectPipeline?: boolean | Client$rejectPipelineArgs<ExtArgs>
    closePipeline?: boolean | Client$closePipelineArgs<ExtArgs>
    notifications?: boolean | Client$notificationsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newPipeline?: boolean | Client$newPipelineArgs<ExtArgs>
    prospectPipeline?: boolean | Client$prospectPipelineArgs<ExtArgs>
    viewingPipeline?: boolean | Client$viewingPipelineArgs<ExtArgs>
    rejectPipeline?: boolean | Client$rejectPipelineArgs<ExtArgs>
    closePipeline?: boolean | Client$closePipelineArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      companies: Prisma.$CompanyClientPayload<ExtArgs>[]
      address: Prisma.$AddressPayload<ExtArgs>[]
      bill: Prisma.$BillPayload<ExtArgs> | null
      conversations: Prisma.$ClientConversationPayload<ExtArgs>[]
      users: Prisma.$UserClientPayload<ExtArgs>[]
      newPipeline: Prisma.$PipelinePayload<ExtArgs> | null
      prospectPipeline: Prisma.$PipelinePayload<ExtArgs> | null
      viewingPipeline: Prisma.$PipelinePayload<ExtArgs> | null
      rejectPipeline: Prisma.$PipelinePayload<ExtArgs> | null
      closePipeline: Prisma.$PipelinePayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      name: string
      password: string | null
      phone: string
      status: boolean
      pipelineStatus: string
      newPipelineId: string | null
      prospectPipelineId: string | null
      viewingPipelineId: string | null
      rejectPipelineId: string | null
      closePipelineId: string | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends Client$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findMany"> | Null>
    address<T extends Client$addressArgs<ExtArgs> = {}>(args?: Subset<T, Client$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany"> | Null>
    bill<T extends Client$billArgs<ExtArgs> = {}>(args?: Subset<T, Client$billArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    conversations<T extends Client$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Client$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Client$usersArgs<ExtArgs> = {}>(args?: Subset<T, Client$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findMany"> | Null>
    newPipeline<T extends Client$newPipelineArgs<ExtArgs> = {}>(args?: Subset<T, Client$newPipelineArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prospectPipeline<T extends Client$prospectPipelineArgs<ExtArgs> = {}>(args?: Subset<T, Client$prospectPipelineArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    viewingPipeline<T extends Client$viewingPipelineArgs<ExtArgs> = {}>(args?: Subset<T, Client$viewingPipelineArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rejectPipeline<T extends Client$rejectPipelineArgs<ExtArgs> = {}>(args?: Subset<T, Client$rejectPipelineArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    closePipeline<T extends Client$closePipelineArgs<ExtArgs> = {}>(args?: Subset<T, Client$closePipelineArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends Client$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Client$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly password: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'Boolean'>
    readonly pipelineStatus: FieldRef<"Client", 'String'>
    readonly newPipelineId: FieldRef<"Client", 'String'>
    readonly prospectPipelineId: FieldRef<"Client", 'String'>
    readonly viewingPipelineId: FieldRef<"Client", 'String'>
    readonly rejectPipelineId: FieldRef<"Client", 'String'>
    readonly closePipelineId: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.companies
   */
  export type Client$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    where?: CompanyClientWhereInput
    orderBy?: CompanyClientOrderByWithRelationInput | CompanyClientOrderByWithRelationInput[]
    cursor?: CompanyClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyClientScalarFieldEnum | CompanyClientScalarFieldEnum[]
  }

  /**
   * Client.address
   */
  export type Client$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Client.bill
   */
  export type Client$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
  }

  /**
   * Client.conversations
   */
  export type Client$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    where?: ClientConversationWhereInput
    orderBy?: ClientConversationOrderByWithRelationInput | ClientConversationOrderByWithRelationInput[]
    cursor?: ClientConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientConversationScalarFieldEnum | ClientConversationScalarFieldEnum[]
  }

  /**
   * Client.users
   */
  export type Client$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    where?: UserClientWhereInput
    orderBy?: UserClientOrderByWithRelationInput | UserClientOrderByWithRelationInput[]
    cursor?: UserClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserClientScalarFieldEnum | UserClientScalarFieldEnum[]
  }

  /**
   * Client.newPipeline
   */
  export type Client$newPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
  }

  /**
   * Client.prospectPipeline
   */
  export type Client$prospectPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
  }

  /**
   * Client.viewingPipeline
   */
  export type Client$viewingPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
  }

  /**
   * Client.rejectPipeline
   */
  export type Client$rejectPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
  }

  /**
   * Client.closePipeline
   */
  export type Client$closePipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
  }

  /**
   * Client.notifications
   */
  export type Client$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Pipeline
   */

  export type AggregatePipeline = {
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  export type PipelineMinAggregateOutputType = {
    id: string | null
    companyId: string | null
  }

  export type PipelineMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
  }

  export type PipelineCountAggregateOutputType = {
    id: number
    companyId: number
    _all: number
  }


  export type PipelineMinAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type PipelineMaxAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type PipelineCountAggregateInputType = {
    id?: true
    companyId?: true
    _all?: true
  }

  export type PipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipeline to aggregate.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineMaxAggregateInputType
  }

  export type GetPipelineAggregateType<T extends PipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipeline[P]>
      : GetScalarType<T[P], AggregatePipeline[P]>
  }




  export type PipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithAggregationInput | PipelineOrderByWithAggregationInput[]
    by: PipelineScalarFieldEnum[] | PipelineScalarFieldEnum
    having?: PipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineCountAggregateInputType | true
    _min?: PipelineMinAggregateInputType
    _max?: PipelineMaxAggregateInputType
  }

  export type PipelineGroupByOutputType = {
    id: string
    companyId: string
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  type GetPipelineGroupByPayload<T extends PipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineGroupByOutputType[P]>
        }
      >
    >


  export type PipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    newClients?: boolean | Pipeline$newClientsArgs<ExtArgs>
    prospectClients?: boolean | Pipeline$prospectClientsArgs<ExtArgs>
    viewingClients?: boolean | Pipeline$viewingClientsArgs<ExtArgs>
    rejectClients?: boolean | Pipeline$rejectClientsArgs<ExtArgs>
    closeClients?: boolean | Pipeline$closeClientsArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectScalar = {
    id?: boolean
    companyId?: boolean
  }

  export type PipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    newClients?: boolean | Pipeline$newClientsArgs<ExtArgs>
    prospectClients?: boolean | Pipeline$prospectClientsArgs<ExtArgs>
    viewingClients?: boolean | Pipeline$viewingClientsArgs<ExtArgs>
    rejectClients?: boolean | Pipeline$rejectClientsArgs<ExtArgs>
    closeClients?: boolean | Pipeline$closeClientsArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipeline"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      newClients: Prisma.$ClientPayload<ExtArgs>[]
      prospectClients: Prisma.$ClientPayload<ExtArgs>[]
      viewingClients: Prisma.$ClientPayload<ExtArgs>[]
      rejectClients: Prisma.$ClientPayload<ExtArgs>[]
      closeClients: Prisma.$ClientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
    }, ExtArgs["result"]["pipeline"]>
    composites: {}
  }

  type PipelineGetPayload<S extends boolean | null | undefined | PipelineDefaultArgs> = $Result.GetResult<Prisma.$PipelinePayload, S>

  type PipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PipelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PipelineCountAggregateInputType | true
    }

  export interface PipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipeline'], meta: { name: 'Pipeline' } }
    /**
     * Find zero or one Pipeline that matches the filter.
     * @param {PipelineFindUniqueArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineFindUniqueArgs>(args: SelectSubset<T, PipelineFindUniqueArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pipeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PipelineFindUniqueOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineFindFirstArgs>(args?: SelectSubset<T, PipelineFindFirstArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipeline.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineFindManyArgs>(args?: SelectSubset<T, PipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pipeline.
     * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
     * @example
     * // Create one Pipeline
     * const Pipeline = await prisma.pipeline.create({
     *   data: {
     *     // ... data to create a Pipeline
     *   }
     * })
     * 
     */
    create<T extends PipelineCreateArgs>(args: SelectSubset<T, PipelineCreateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pipelines.
     * @param {PipelineCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineCreateManyArgs>(args?: SelectSubset<T, PipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pipelines and returns the data saved in the database.
     * @param {PipelineCreateManyAndReturnArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pipeline.
     * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
     * @example
     * // Delete one Pipeline
     * const Pipeline = await prisma.pipeline.delete({
     *   where: {
     *     // ... filter to delete one Pipeline
     *   }
     * })
     * 
     */
    delete<T extends PipelineDeleteArgs>(args: SelectSubset<T, PipelineDeleteArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pipeline.
     * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
     * @example
     * // Update one Pipeline
     * const pipeline = await prisma.pipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineUpdateArgs>(args: SelectSubset<T, PipelineUpdateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineDeleteManyArgs>(args?: SelectSubset<T, PipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineUpdateManyArgs>(args: SelectSubset<T, PipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pipeline.
     * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
     * @example
     * // Update or create a Pipeline
     * const pipeline = await prisma.pipeline.upsert({
     *   create: {
     *     // ... data to create a Pipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipeline we want to update
     *   }
     * })
     */
    upsert<T extends PipelineUpsertArgs>(args: SelectSubset<T, PipelineUpsertArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipeline.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelineCountArgs>(
      args?: Subset<T, PipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineAggregateArgs>(args: Subset<T, PipelineAggregateArgs>): Prisma.PrismaPromise<GetPipelineAggregateType<T>>

    /**
     * Group by Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineGroupByArgs['orderBy'] }
        : { orderBy?: PipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipeline model
   */
  readonly fields: PipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    newClients<T extends Pipeline$newClientsArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$newClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    prospectClients<T extends Pipeline$prospectClientsArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$prospectClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    viewingClients<T extends Pipeline$viewingClientsArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$viewingClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    rejectClients<T extends Pipeline$rejectClientsArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$rejectClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    closeClients<T extends Pipeline$closeClientsArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$closeClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipeline model
   */ 
  interface PipelineFieldRefs {
    readonly id: FieldRef<"Pipeline", 'String'>
    readonly companyId: FieldRef<"Pipeline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pipeline findUnique
   */
  export type PipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findUniqueOrThrow
   */
  export type PipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findFirst
   */
  export type PipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findFirstOrThrow
   */
  export type PipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findMany
   */
  export type PipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline create
   */
  export type PipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipeline.
     */
    data: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
  }

  /**
   * Pipeline createMany
   */
  export type PipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipeline createManyAndReturn
   */
  export type PipelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline update
   */
  export type PipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipeline.
     */
    data: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
    /**
     * Choose, which Pipeline to update.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline updateMany
   */
  export type PipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
  }

  /**
   * Pipeline upsert
   */
  export type PipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipeline to update in case it exists.
     */
    where: PipelineWhereUniqueInput
    /**
     * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
     */
    create: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
    /**
     * In case the Pipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
  }

  /**
   * Pipeline delete
   */
  export type PipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter which Pipeline to delete.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline deleteMany
   */
  export type PipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelineWhereInput
  }

  /**
   * Pipeline.newClients
   */
  export type Pipeline$newClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Pipeline.prospectClients
   */
  export type Pipeline$prospectClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Pipeline.viewingClients
   */
  export type Pipeline$viewingClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Pipeline.rejectClients
   */
  export type Pipeline$rejectClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Pipeline.closeClients
   */
  export type Pipeline$closeClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Pipeline without action
   */
  export type PipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    fixedTax: number | null
    thresholdAmount: number | null
    taxBelowThreshold: number | null
    taxAboveThreshold: number | null
  }

  export type CategorySumAggregateOutputType = {
    fixedTax: number | null
    thresholdAmount: number | null
    taxBelowThreshold: number | null
    taxAboveThreshold: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    status: boolean | null
    image: string | null
    companyId: string | null
    hsn: string | null
    taxType: $Enums.TaxType | null
    fixedTax: number | null
    thresholdAmount: number | null
    taxBelowThreshold: number | null
    taxAboveThreshold: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    status: boolean | null
    image: string | null
    companyId: string | null
    hsn: string | null
    taxType: $Enums.TaxType | null
    fixedTax: number | null
    thresholdAmount: number | null
    taxBelowThreshold: number | null
    taxAboveThreshold: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    status: number
    image: number
    companyId: number
    hsn: number
    taxType: number
    fixedTax: number
    thresholdAmount: number
    taxBelowThreshold: number
    taxAboveThreshold: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    fixedTax?: true
    thresholdAmount?: true
    taxBelowThreshold?: true
    taxAboveThreshold?: true
  }

  export type CategorySumAggregateInputType = {
    fixedTax?: true
    thresholdAmount?: true
    taxBelowThreshold?: true
    taxAboveThreshold?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    status?: true
    image?: true
    companyId?: true
    hsn?: true
    taxType?: true
    fixedTax?: true
    thresholdAmount?: true
    taxBelowThreshold?: true
    taxAboveThreshold?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    status?: true
    image?: true
    companyId?: true
    hsn?: true
    taxType?: true
    fixedTax?: true
    thresholdAmount?: true
    taxBelowThreshold?: true
    taxAboveThreshold?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    status?: true
    image?: true
    companyId?: true
    hsn?: true
    taxType?: true
    fixedTax?: true
    thresholdAmount?: true
    taxBelowThreshold?: true
    taxAboveThreshold?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    status: boolean
    image: string | null
    companyId: string
    hsn: string | null
    taxType: $Enums.TaxType
    fixedTax: number | null
    thresholdAmount: number | null
    taxBelowThreshold: number | null
    taxAboveThreshold: number | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    image?: boolean
    companyId?: boolean
    hsn?: boolean
    taxType?: boolean
    fixedTax?: boolean
    thresholdAmount?: boolean
    taxBelowThreshold?: boolean
    taxAboveThreshold?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    entries?: boolean | Category$entriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    image?: boolean
    companyId?: boolean
    hsn?: boolean
    taxType?: boolean
    fixedTax?: boolean
    thresholdAmount?: boolean
    taxBelowThreshold?: boolean
    taxAboveThreshold?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    image?: boolean
    companyId?: boolean
    hsn?: boolean
    taxType?: boolean
    fixedTax?: boolean
    thresholdAmount?: boolean
    taxBelowThreshold?: boolean
    taxAboveThreshold?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    entries?: boolean | Category$entriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      subcategories: Prisma.$SubcategoryPayload<ExtArgs>[]
      entries: Prisma.$EntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      status: boolean
      image: string | null
      companyId: string
      hsn: string | null
      taxType: $Enums.TaxType
      fixedTax: number | null
      thresholdAmount: number | null
      taxBelowThreshold: number | null
      taxAboveThreshold: number | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    subcategories<T extends Category$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany"> | Null>
    entries<T extends Category$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly status: FieldRef<"Category", 'Boolean'>
    readonly image: FieldRef<"Category", 'String'>
    readonly companyId: FieldRef<"Category", 'String'>
    readonly hsn: FieldRef<"Category", 'String'>
    readonly taxType: FieldRef<"Category", 'TaxType'>
    readonly fixedTax: FieldRef<"Category", 'Float'>
    readonly thresholdAmount: FieldRef<"Category", 'Float'>
    readonly taxBelowThreshold: FieldRef<"Category", 'Float'>
    readonly taxAboveThreshold: FieldRef<"Category", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category.subcategories
   */
  export type Category$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    cursor?: SubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Category.entries
   */
  export type Category$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    where?: EntryWhereInput
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    cursor?: EntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Subcategory
   */

  export type AggregateSubcategory = {
    _count: SubcategoryCountAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  export type SubcategoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    status: boolean | null
    image: string | null
    companyId: string | null
    categoryId: string | null
  }

  export type SubcategoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    status: boolean | null
    image: string | null
    companyId: string | null
    categoryId: string | null
  }

  export type SubcategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    status: number
    image: number
    companyId: number
    categoryId: number
    _all: number
  }


  export type SubcategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    status?: true
    image?: true
    companyId?: true
    categoryId?: true
  }

  export type SubcategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    status?: true
    image?: true
    companyId?: true
    categoryId?: true
  }

  export type SubcategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    status?: true
    image?: true
    companyId?: true
    categoryId?: true
    _all?: true
  }

  export type SubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategory to aggregate.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subcategories
    **/
    _count?: true | SubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubcategoryMaxAggregateInputType
  }

  export type GetSubcategoryAggregateType<T extends SubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubcategory[P]>
      : GetScalarType<T[P], AggregateSubcategory[P]>
  }




  export type SubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithAggregationInput | SubcategoryOrderByWithAggregationInput[]
    by: SubcategoryScalarFieldEnum[] | SubcategoryScalarFieldEnum
    having?: SubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubcategoryCountAggregateInputType | true
    _min?: SubcategoryMinAggregateInputType
    _max?: SubcategoryMaxAggregateInputType
  }

  export type SubcategoryGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    status: boolean
    image: string | null
    companyId: string
    categoryId: string | null
    _count: SubcategoryCountAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  type GetSubcategoryGroupByPayload<T extends SubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    image?: boolean
    companyId?: boolean
    categoryId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    products?: boolean | Subcategory$productsArgs<ExtArgs>
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    image?: boolean
    companyId?: boolean
    categoryId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    image?: boolean
    companyId?: boolean
    categoryId?: boolean
  }

  export type SubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    products?: boolean | Subcategory$productsArgs<ExtArgs>
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }

  export type $SubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subcategory"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      status: boolean
      image: string | null
      companyId: string
      categoryId: string | null
    }, ExtArgs["result"]["subcategory"]>
    composites: {}
  }

  type SubcategoryGetPayload<S extends boolean | null | undefined | SubcategoryDefaultArgs> = $Result.GetResult<Prisma.$SubcategoryPayload, S>

  type SubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubcategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubcategoryCountAggregateInputType | true
    }

  export interface SubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subcategory'], meta: { name: 'Subcategory' } }
    /**
     * Find zero or one Subcategory that matches the filter.
     * @param {SubcategoryFindUniqueArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubcategoryFindUniqueArgs>(args: SelectSubset<T, SubcategoryFindUniqueArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subcategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubcategoryFindUniqueOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubcategoryFindFirstArgs>(args?: SelectSubset<T, SubcategoryFindFirstArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subcategories
     * const subcategories = await prisma.subcategory.findMany()
     * 
     * // Get first 10 Subcategories
     * const subcategories = await prisma.subcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubcategoryFindManyArgs>(args?: SelectSubset<T, SubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subcategory.
     * @param {SubcategoryCreateArgs} args - Arguments to create a Subcategory.
     * @example
     * // Create one Subcategory
     * const Subcategory = await prisma.subcategory.create({
     *   data: {
     *     // ... data to create a Subcategory
     *   }
     * })
     * 
     */
    create<T extends SubcategoryCreateArgs>(args: SelectSubset<T, SubcategoryCreateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subcategories.
     * @param {SubcategoryCreateManyArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubcategoryCreateManyArgs>(args?: SelectSubset<T, SubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subcategories and returns the data saved in the database.
     * @param {SubcategoryCreateManyAndReturnArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subcategory.
     * @param {SubcategoryDeleteArgs} args - Arguments to delete one Subcategory.
     * @example
     * // Delete one Subcategory
     * const Subcategory = await prisma.subcategory.delete({
     *   where: {
     *     // ... filter to delete one Subcategory
     *   }
     * })
     * 
     */
    delete<T extends SubcategoryDeleteArgs>(args: SelectSubset<T, SubcategoryDeleteArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subcategory.
     * @param {SubcategoryUpdateArgs} args - Arguments to update one Subcategory.
     * @example
     * // Update one Subcategory
     * const subcategory = await prisma.subcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubcategoryUpdateArgs>(args: SelectSubset<T, SubcategoryUpdateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subcategories.
     * @param {SubcategoryDeleteManyArgs} args - Arguments to filter Subcategories to delete.
     * @example
     * // Delete a few Subcategories
     * const { count } = await prisma.subcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubcategoryDeleteManyArgs>(args?: SelectSubset<T, SubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubcategoryUpdateManyArgs>(args: SelectSubset<T, SubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subcategory.
     * @param {SubcategoryUpsertArgs} args - Arguments to update or create a Subcategory.
     * @example
     * // Update or create a Subcategory
     * const subcategory = await prisma.subcategory.upsert({
     *   create: {
     *     // ... data to create a Subcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subcategory we want to update
     *   }
     * })
     */
    upsert<T extends SubcategoryUpsertArgs>(args: SelectSubset<T, SubcategoryUpsertArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryCountArgs} args - Arguments to filter Subcategories to count.
     * @example
     * // Count the number of Subcategories
     * const count = await prisma.subcategory.count({
     *   where: {
     *     // ... the filter for the Subcategories we want to count
     *   }
     * })
    **/
    count<T extends SubcategoryCountArgs>(
      args?: Subset<T, SubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubcategoryAggregateArgs>(args: Subset<T, SubcategoryAggregateArgs>): Prisma.PrismaPromise<GetSubcategoryAggregateType<T>>

    /**
     * Group by Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subcategory model
   */
  readonly fields: SubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    products<T extends Subcategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends Subcategory$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subcategory model
   */ 
  interface SubcategoryFieldRefs {
    readonly id: FieldRef<"Subcategory", 'String'>
    readonly createdAt: FieldRef<"Subcategory", 'DateTime'>
    readonly updatedAt: FieldRef<"Subcategory", 'DateTime'>
    readonly name: FieldRef<"Subcategory", 'String'>
    readonly description: FieldRef<"Subcategory", 'String'>
    readonly status: FieldRef<"Subcategory", 'Boolean'>
    readonly image: FieldRef<"Subcategory", 'String'>
    readonly companyId: FieldRef<"Subcategory", 'String'>
    readonly categoryId: FieldRef<"Subcategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subcategory findUnique
   */
  export type SubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findUniqueOrThrow
   */
  export type SubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findFirst
   */
  export type SubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findFirstOrThrow
   */
  export type SubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findMany
   */
  export type SubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategories to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory create
   */
  export type SubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Subcategory.
     */
    data: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
  }

  /**
   * Subcategory createMany
   */
  export type SubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subcategory createManyAndReturn
   */
  export type SubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory update
   */
  export type SubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Subcategory.
     */
    data: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
    /**
     * Choose, which Subcategory to update.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory updateMany
   */
  export type SubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
  }

  /**
   * Subcategory upsert
   */
  export type SubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Subcategory to update in case it exists.
     */
    where: SubcategoryWhereUniqueInput
    /**
     * In case the Subcategory found by the `where` argument doesn't exist, create a new Subcategory with this data.
     */
    create: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
    /**
     * In case the Subcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
  }

  /**
   * Subcategory delete
   */
  export type SubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter which Subcategory to delete.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory deleteMany
   */
  export type SubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategories to delete
     */
    where?: SubcategoryWhereInput
  }

  /**
   * Subcategory.products
   */
  export type Subcategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Subcategory.category
   */
  export type Subcategory$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Subcategory without action
   */
  export type SubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    rating: number | null
  }

  export type ProductSumAggregateOutputType = {
    rating: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    brand: string | null
    status: boolean | null
    rating: number | null
    description: string | null
    companyId: string | null
    categoryId: string | null
    subcategoryId: string | null
    purchaseorderId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    brand: string | null
    status: boolean | null
    rating: number | null
    description: string | null
    companyId: string | null
    categoryId: string | null
    subcategoryId: string | null
    purchaseorderId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    brand: number
    status: number
    rating: number
    description: number
    companyId: number
    categoryId: number
    subcategoryId: number
    purchaseorderId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    rating?: true
  }

  export type ProductSumAggregateInputType = {
    rating?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    brand?: true
    status?: true
    rating?: true
    description?: true
    companyId?: true
    categoryId?: true
    subcategoryId?: true
    purchaseorderId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    brand?: true
    status?: true
    rating?: true
    description?: true
    companyId?: true
    categoryId?: true
    subcategoryId?: true
    purchaseorderId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    brand?: true
    status?: true
    rating?: true
    description?: true
    companyId?: true
    categoryId?: true
    subcategoryId?: true
    purchaseorderId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    brand: string | null
    status: boolean
    rating: number | null
    description: string | null
    companyId: string
    categoryId: string | null
    subcategoryId: string | null
    purchaseorderId: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    brand?: boolean
    status?: boolean
    rating?: boolean
    description?: boolean
    companyId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    purchaseorderId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    subcategory?: boolean | Product$subcategoryArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    purchaseorder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    brand?: boolean
    status?: boolean
    rating?: boolean
    description?: boolean
    companyId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    purchaseorderId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    subcategory?: boolean | Product$subcategoryArgs<ExtArgs>
    purchaseorder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    brand?: boolean
    status?: boolean
    rating?: boolean
    description?: boolean
    companyId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    purchaseorderId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    subcategory?: boolean | Product$subcategoryArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    purchaseorder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    subcategory?: boolean | Product$subcategoryArgs<ExtArgs>
    purchaseorder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      subcategory: Prisma.$SubcategoryPayload<ExtArgs> | null
      variants: Prisma.$VariantPayload<ExtArgs>[]
      purchaseorder: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      brand: string | null
      status: boolean
      rating: number | null
      description: string | null
      companyId: string
      categoryId: string | null
      subcategoryId: string | null
      purchaseorderId: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subcategory<T extends Product$subcategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$subcategoryArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseorder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly name: FieldRef<"Product", 'String'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'Boolean'>
    readonly rating: FieldRef<"Product", 'Float'>
    readonly description: FieldRef<"Product", 'String'>
    readonly companyId: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly subcategoryId: FieldRef<"Product", 'String'>
    readonly purchaseorderId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.subcategory
   */
  export type Product$subcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    cursor?: VariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Variant
   */

  export type AggregateVariant = {
    _count: VariantCountAggregateOutputType | null
    _avg: VariantAvgAggregateOutputType | null
    _sum: VariantSumAggregateOutputType | null
    _min: VariantMinAggregateOutputType | null
    _max: VariantMaxAggregateOutputType | null
  }

  export type VariantAvgAggregateOutputType = {
    sprice: number | null
    pprice: number | null
    qty: number | null
    discount: number | null
    dprice: number | null
    tax: number | null
  }

  export type VariantSumAggregateOutputType = {
    sprice: number | null
    pprice: number | null
    qty: number | null
    discount: number | null
    dprice: number | null
    tax: number | null
  }

  export type VariantMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
    status: boolean | null
    sprice: number | null
    pprice: number | null
    qty: number | null
    discount: number | null
    dprice: number | null
    tax: number | null
    productId: string | null
    companyId: string | null
  }

  export type VariantMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
    status: boolean | null
    sprice: number | null
    pprice: number | null
    qty: number | null
    discount: number | null
    dprice: number | null
    tax: number | null
    productId: string | null
    companyId: string | null
  }

  export type VariantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    code: number
    status: number
    sprice: number
    pprice: number
    qty: number
    discount: number
    dprice: number
    sizes: number
    images: number
    tax: number
    productId: number
    companyId: number
    _all: number
  }


  export type VariantAvgAggregateInputType = {
    sprice?: true
    pprice?: true
    qty?: true
    discount?: true
    dprice?: true
    tax?: true
  }

  export type VariantSumAggregateInputType = {
    sprice?: true
    pprice?: true
    qty?: true
    discount?: true
    dprice?: true
    tax?: true
  }

  export type VariantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    status?: true
    sprice?: true
    pprice?: true
    qty?: true
    discount?: true
    dprice?: true
    tax?: true
    productId?: true
    companyId?: true
  }

  export type VariantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    status?: true
    sprice?: true
    pprice?: true
    qty?: true
    discount?: true
    dprice?: true
    tax?: true
    productId?: true
    companyId?: true
  }

  export type VariantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    status?: true
    sprice?: true
    pprice?: true
    qty?: true
    discount?: true
    dprice?: true
    sizes?: true
    images?: true
    tax?: true
    productId?: true
    companyId?: true
    _all?: true
  }

  export type VariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant to aggregate.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variants
    **/
    _count?: true | VariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantMaxAggregateInputType
  }

  export type GetVariantAggregateType<T extends VariantAggregateArgs> = {
        [P in keyof T & keyof AggregateVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariant[P]>
      : GetScalarType<T[P], AggregateVariant[P]>
  }




  export type VariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithAggregationInput | VariantOrderByWithAggregationInput[]
    by: VariantScalarFieldEnum[] | VariantScalarFieldEnum
    having?: VariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantCountAggregateInputType | true
    _avg?: VariantAvgAggregateInputType
    _sum?: VariantSumAggregateInputType
    _min?: VariantMinAggregateInputType
    _max?: VariantMaxAggregateInputType
  }

  export type VariantGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    code: string | null
    status: boolean
    sprice: number
    pprice: number | null
    qty: number | null
    discount: number | null
    dprice: number | null
    sizes: JsonValue | null
    images: string[]
    tax: number
    productId: string
    companyId: string
    _count: VariantCountAggregateOutputType | null
    _avg: VariantAvgAggregateOutputType | null
    _sum: VariantSumAggregateOutputType | null
    _min: VariantMinAggregateOutputType | null
    _max: VariantMaxAggregateOutputType | null
  }

  type GetVariantGroupByPayload<T extends VariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantGroupByOutputType[P]>
            : GetScalarType<T[P], VariantGroupByOutputType[P]>
        }
      >
    >


  export type VariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    sprice?: boolean
    pprice?: boolean
    qty?: boolean
    discount?: boolean
    dprice?: boolean
    sizes?: boolean
    images?: boolean
    tax?: boolean
    productId?: boolean
    companyId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    items?: boolean | Variant$itemsArgs<ExtArgs>
    entries?: boolean | Variant$entriesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    VariantSizeBarcode?: boolean | Variant$VariantSizeBarcodeArgs<ExtArgs>
    _count?: boolean | VariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    sprice?: boolean
    pprice?: boolean
    qty?: boolean
    discount?: boolean
    dprice?: boolean
    sizes?: boolean
    images?: boolean
    tax?: boolean
    productId?: boolean
    companyId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    sprice?: boolean
    pprice?: boolean
    qty?: boolean
    discount?: boolean
    dprice?: boolean
    sizes?: boolean
    images?: boolean
    tax?: boolean
    productId?: boolean
    companyId?: boolean
  }

  export type VariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    items?: boolean | Variant$itemsArgs<ExtArgs>
    entries?: boolean | Variant$entriesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    VariantSizeBarcode?: boolean | Variant$VariantSizeBarcodeArgs<ExtArgs>
    _count?: boolean | VariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $VariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      items: Prisma.$ItemPayload<ExtArgs>[]
      entries: Prisma.$EntryPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      VariantSizeBarcode: Prisma.$VariantSizeBarcodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      code: string | null
      status: boolean
      sprice: number
      pprice: number | null
      qty: number | null
      discount: number | null
      dprice: number | null
      sizes: Prisma.JsonValue | null
      images: string[]
      tax: number
      productId: string
      companyId: string
    }, ExtArgs["result"]["variant"]>
    composites: {}
  }

  type VariantGetPayload<S extends boolean | null | undefined | VariantDefaultArgs> = $Result.GetResult<Prisma.$VariantPayload, S>

  type VariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VariantCountAggregateInputType | true
    }

  export interface VariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variant'], meta: { name: 'Variant' } }
    /**
     * Find zero or one Variant that matches the filter.
     * @param {VariantFindUniqueArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantFindUniqueArgs>(args: SelectSubset<T, VariantFindUniqueArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Variant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VariantFindUniqueOrThrowArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Variant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindFirstArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantFindFirstArgs>(args?: SelectSubset<T, VariantFindFirstArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Variant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindFirstOrThrowArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variants
     * const variants = await prisma.variant.findMany()
     * 
     * // Get first 10 Variants
     * const variants = await prisma.variant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantWithIdOnly = await prisma.variant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantFindManyArgs>(args?: SelectSubset<T, VariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Variant.
     * @param {VariantCreateArgs} args - Arguments to create a Variant.
     * @example
     * // Create one Variant
     * const Variant = await prisma.variant.create({
     *   data: {
     *     // ... data to create a Variant
     *   }
     * })
     * 
     */
    create<T extends VariantCreateArgs>(args: SelectSubset<T, VariantCreateArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Variants.
     * @param {VariantCreateManyArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variant = await prisma.variant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantCreateManyArgs>(args?: SelectSubset<T, VariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variants and returns the data saved in the database.
     * @param {VariantCreateManyAndReturnArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variant = await prisma.variant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variants and only return the `id`
     * const variantWithIdOnly = await prisma.variant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Variant.
     * @param {VariantDeleteArgs} args - Arguments to delete one Variant.
     * @example
     * // Delete one Variant
     * const Variant = await prisma.variant.delete({
     *   where: {
     *     // ... filter to delete one Variant
     *   }
     * })
     * 
     */
    delete<T extends VariantDeleteArgs>(args: SelectSubset<T, VariantDeleteArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Variant.
     * @param {VariantUpdateArgs} args - Arguments to update one Variant.
     * @example
     * // Update one Variant
     * const variant = await prisma.variant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantUpdateArgs>(args: SelectSubset<T, VariantUpdateArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Variants.
     * @param {VariantDeleteManyArgs} args - Arguments to filter Variants to delete.
     * @example
     * // Delete a few Variants
     * const { count } = await prisma.variant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantDeleteManyArgs>(args?: SelectSubset<T, VariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variants
     * const variant = await prisma.variant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantUpdateManyArgs>(args: SelectSubset<T, VariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Variant.
     * @param {VariantUpsertArgs} args - Arguments to update or create a Variant.
     * @example
     * // Update or create a Variant
     * const variant = await prisma.variant.upsert({
     *   create: {
     *     // ... data to create a Variant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variant we want to update
     *   }
     * })
     */
    upsert<T extends VariantUpsertArgs>(args: SelectSubset<T, VariantUpsertArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantCountArgs} args - Arguments to filter Variants to count.
     * @example
     * // Count the number of Variants
     * const count = await prisma.variant.count({
     *   where: {
     *     // ... the filter for the Variants we want to count
     *   }
     * })
    **/
    count<T extends VariantCountArgs>(
      args?: Subset<T, VariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantAggregateArgs>(args: Subset<T, VariantAggregateArgs>): Prisma.PrismaPromise<GetVariantAggregateType<T>>

    /**
     * Group by Variant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantGroupByArgs['orderBy'] }
        : { orderBy?: VariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variant model
   */
  readonly fields: VariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Variant$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Variant$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany"> | Null>
    entries<T extends Variant$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Variant$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    VariantSizeBarcode<T extends Variant$VariantSizeBarcodeArgs<ExtArgs> = {}>(args?: Subset<T, Variant$VariantSizeBarcodeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variant model
   */ 
  interface VariantFieldRefs {
    readonly id: FieldRef<"Variant", 'String'>
    readonly createdAt: FieldRef<"Variant", 'DateTime'>
    readonly updatedAt: FieldRef<"Variant", 'DateTime'>
    readonly name: FieldRef<"Variant", 'String'>
    readonly code: FieldRef<"Variant", 'String'>
    readonly status: FieldRef<"Variant", 'Boolean'>
    readonly sprice: FieldRef<"Variant", 'Float'>
    readonly pprice: FieldRef<"Variant", 'Float'>
    readonly qty: FieldRef<"Variant", 'Int'>
    readonly discount: FieldRef<"Variant", 'Float'>
    readonly dprice: FieldRef<"Variant", 'Float'>
    readonly sizes: FieldRef<"Variant", 'Json'>
    readonly images: FieldRef<"Variant", 'String[]'>
    readonly tax: FieldRef<"Variant", 'Float'>
    readonly productId: FieldRef<"Variant", 'String'>
    readonly companyId: FieldRef<"Variant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Variant findUnique
   */
  export type VariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant findUniqueOrThrow
   */
  export type VariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant findFirst
   */
  export type VariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant findFirstOrThrow
   */
  export type VariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant findMany
   */
  export type VariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant create
   */
  export type VariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The data needed to create a Variant.
     */
    data: XOR<VariantCreateInput, VariantUncheckedCreateInput>
  }

  /**
   * Variant createMany
   */
  export type VariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variants.
     */
    data: VariantCreateManyInput | VariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variant createManyAndReturn
   */
  export type VariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Variants.
     */
    data: VariantCreateManyInput | VariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant update
   */
  export type VariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The data needed to update a Variant.
     */
    data: XOR<VariantUpdateInput, VariantUncheckedUpdateInput>
    /**
     * Choose, which Variant to update.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant updateMany
   */
  export type VariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantWhereInput
  }

  /**
   * Variant upsert
   */
  export type VariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The filter to search for the Variant to update in case it exists.
     */
    where: VariantWhereUniqueInput
    /**
     * In case the Variant found by the `where` argument doesn't exist, create a new Variant with this data.
     */
    create: XOR<VariantCreateInput, VariantUncheckedCreateInput>
    /**
     * In case the Variant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantUpdateInput, VariantUncheckedUpdateInput>
  }

  /**
   * Variant delete
   */
  export type VariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter which Variant to delete.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant deleteMany
   */
  export type VariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variants to delete
     */
    where?: VariantWhereInput
  }

  /**
   * Variant.items
   */
  export type Variant$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Variant.entries
   */
  export type Variant$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    where?: EntryWhereInput
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    cursor?: EntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Variant.VariantSizeBarcode
   */
  export type Variant$VariantSizeBarcodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    where?: VariantSizeBarcodeWhereInput
    orderBy?: VariantSizeBarcodeOrderByWithRelationInput | VariantSizeBarcodeOrderByWithRelationInput[]
    cursor?: VariantSizeBarcodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantSizeBarcodeScalarFieldEnum | VariantSizeBarcodeScalarFieldEnum[]
  }

  /**
   * Variant without action
   */
  export type VariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    barcode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    variantId: string | null
    status: string | null
    size: string | null
    companyId: string | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    barcode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    variantId: string | null
    status: string | null
    size: string | null
    companyId: string | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    barcode: number
    createdAt: number
    updatedAt: number
    variantId: number
    status: number
    size: number
    companyId: number
    _all: number
  }


  export type ItemMinAggregateInputType = {
    id?: true
    barcode?: true
    createdAt?: true
    updatedAt?: true
    variantId?: true
    status?: true
    size?: true
    companyId?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    barcode?: true
    createdAt?: true
    updatedAt?: true
    variantId?: true
    status?: true
    size?: true
    companyId?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    barcode?: true
    createdAt?: true
    updatedAt?: true
    variantId?: true
    status?: true
    size?: true
    companyId?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    barcode: string | null
    createdAt: Date
    updatedAt: Date
    variantId: string
    status: string
    size: string | null
    companyId: string
    _count: ItemCountAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barcode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variantId?: boolean
    status?: boolean
    size?: boolean
    companyId?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    entry?: boolean | Item$entryArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barcode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variantId?: boolean
    status?: boolean
    size?: boolean
    companyId?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    barcode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variantId?: boolean
    status?: boolean
    size?: boolean
    companyId?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    entry?: boolean | Item$entryArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      variant: Prisma.$VariantPayload<ExtArgs>
      entry: Prisma.$EntryPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barcode: string | null
      createdAt: Date
      updatedAt: Date
      variantId: string
      status: string
      size: string | null
      companyId: string
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends VariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariantDefaultArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    entry<T extends Item$entryArgs<ExtArgs> = {}>(args?: Subset<T, Item$entryArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly barcode: FieldRef<"Item", 'String'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
    readonly variantId: FieldRef<"Item", 'String'>
    readonly status: FieldRef<"Item", 'String'>
    readonly size: FieldRef<"Item", 'String'>
    readonly companyId: FieldRef<"Item", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }

  /**
   * Item.entry
   */
  export type Item$entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    where?: EntryWhereInput
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    distributorId: string | null
    paymentType: $Enums.paymentType | null
    companyId: string | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    distributorId: string | null
    paymentType: $Enums.paymentType | null
    companyId: string | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    distributorId: number
    paymentType: number
    companyId: number
    _all: number
  }


  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributorId?: true
    paymentType?: true
    companyId?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributorId?: true
    paymentType?: true
    companyId?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributorId?: true
    paymentType?: true
    companyId?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    distributorId: string | null
    paymentType: $Enums.paymentType | null
    companyId: string
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributorId?: boolean
    paymentType?: boolean
    companyId?: boolean
    products?: boolean | PurchaseOrder$productsArgs<ExtArgs>
    distributor?: boolean | PurchaseOrder$distributorArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributorId?: boolean
    paymentType?: boolean
    companyId?: boolean
    distributor?: boolean | PurchaseOrder$distributorArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributorId?: boolean
    paymentType?: boolean
    companyId?: boolean
  }

  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PurchaseOrder$productsArgs<ExtArgs>
    distributor?: boolean | PurchaseOrder$distributorArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    distributor?: boolean | PurchaseOrder$distributorArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      distributor: Prisma.$DistributorPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      distributorId: string | null
      paymentType: $Enums.paymentType | null
      companyId: string
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends PurchaseOrder$productsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    distributor<T extends PurchaseOrder$distributorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$distributorArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */ 
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly distributorId: FieldRef<"PurchaseOrder", 'String'>
    readonly paymentType: FieldRef<"PurchaseOrder", 'paymentType'>
    readonly companyId: FieldRef<"PurchaseOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder.products
   */
  export type PurchaseOrder$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.distributor
   */
  export type PurchaseOrder$distributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    where?: DistributorWhereInput
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    invoiceNumber: number | null
    subtotal: number | null
    discount: number | null
    tax: number | null
    grandTotal: number | null
    deliveryFees: number | null
  }

  export type BillSumAggregateOutputType = {
    invoiceNumber: number | null
    subtotal: number | null
    discount: number | null
    tax: number | null
    grandTotal: number | null
    deliveryFees: number | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    invoiceNumber: number | null
    subtotal: number | null
    discount: number | null
    tax: number | null
    grandTotal: number | null
    deliveryFees: number | null
    paymentMethod: string | null
    paymentStatus: $Enums.PaymentStatus | null
    transactionId: string | null
    notes: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    deleted: boolean | null
    bookingDate: Date | null
    returnDeadline: string | null
    companyId: string | null
    accountId: string | null
    clientId: string | null
    addressId: string | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    invoiceNumber: number | null
    subtotal: number | null
    discount: number | null
    tax: number | null
    grandTotal: number | null
    deliveryFees: number | null
    paymentMethod: string | null
    paymentStatus: $Enums.PaymentStatus | null
    transactionId: string | null
    notes: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    deleted: boolean | null
    bookingDate: Date | null
    returnDeadline: string | null
    companyId: string | null
    accountId: string | null
    clientId: string | null
    addressId: string | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    createdAt: number
    invoiceNumber: number
    subtotal: number
    discount: number
    tax: number
    grandTotal: number
    deliveryFees: number
    paymentMethod: number
    paymentStatus: number
    transactionId: number
    notes: number
    type: number
    status: number
    deleted: number
    bookingDate: number
    returnDeadline: number
    companyId: number
    accountId: number
    clientId: number
    addressId: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    invoiceNumber?: true
    subtotal?: true
    discount?: true
    tax?: true
    grandTotal?: true
    deliveryFees?: true
  }

  export type BillSumAggregateInputType = {
    invoiceNumber?: true
    subtotal?: true
    discount?: true
    tax?: true
    grandTotal?: true
    deliveryFees?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    createdAt?: true
    invoiceNumber?: true
    subtotal?: true
    discount?: true
    tax?: true
    grandTotal?: true
    deliveryFees?: true
    paymentMethod?: true
    paymentStatus?: true
    transactionId?: true
    notes?: true
    type?: true
    status?: true
    deleted?: true
    bookingDate?: true
    returnDeadline?: true
    companyId?: true
    accountId?: true
    clientId?: true
    addressId?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    createdAt?: true
    invoiceNumber?: true
    subtotal?: true
    discount?: true
    tax?: true
    grandTotal?: true
    deliveryFees?: true
    paymentMethod?: true
    paymentStatus?: true
    transactionId?: true
    notes?: true
    type?: true
    status?: true
    deleted?: true
    bookingDate?: true
    returnDeadline?: true
    companyId?: true
    accountId?: true
    clientId?: true
    addressId?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    createdAt?: true
    invoiceNumber?: true
    subtotal?: true
    discount?: true
    tax?: true
    grandTotal?: true
    deliveryFees?: true
    paymentMethod?: true
    paymentStatus?: true
    transactionId?: true
    notes?: true
    type?: true
    status?: true
    deleted?: true
    bookingDate?: true
    returnDeadline?: true
    companyId?: true
    accountId?: true
    clientId?: true
    addressId?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: string
    createdAt: Date
    invoiceNumber: number | null
    subtotal: number | null
    discount: number | null
    tax: number | null
    grandTotal: number | null
    deliveryFees: number | null
    paymentMethod: string | null
    paymentStatus: $Enums.PaymentStatus
    transactionId: string | null
    notes: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    deleted: boolean | null
    bookingDate: Date | null
    returnDeadline: string | null
    companyId: string
    accountId: string | null
    clientId: string | null
    addressId: string | null
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    invoiceNumber?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    grandTotal?: boolean
    deliveryFees?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    transactionId?: boolean
    notes?: boolean
    type?: boolean
    status?: boolean
    deleted?: boolean
    bookingDate?: boolean
    returnDeadline?: boolean
    companyId?: boolean
    accountId?: boolean
    clientId?: boolean
    addressId?: boolean
    entries?: boolean | Bill$entriesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    account?: boolean | Bill$accountArgs<ExtArgs>
    client?: boolean | Bill$clientArgs<ExtArgs>
    address?: boolean | Bill$addressArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    invoiceNumber?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    grandTotal?: boolean
    deliveryFees?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    transactionId?: boolean
    notes?: boolean
    type?: boolean
    status?: boolean
    deleted?: boolean
    bookingDate?: boolean
    returnDeadline?: boolean
    companyId?: boolean
    accountId?: boolean
    clientId?: boolean
    addressId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    account?: boolean | Bill$accountArgs<ExtArgs>
    client?: boolean | Bill$clientArgs<ExtArgs>
    address?: boolean | Bill$addressArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectScalar = {
    id?: boolean
    createdAt?: boolean
    invoiceNumber?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    grandTotal?: boolean
    deliveryFees?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    transactionId?: boolean
    notes?: boolean
    type?: boolean
    status?: boolean
    deleted?: boolean
    bookingDate?: boolean
    returnDeadline?: boolean
    companyId?: boolean
    accountId?: boolean
    clientId?: boolean
    addressId?: boolean
  }

  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | Bill$entriesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    account?: boolean | Bill$accountArgs<ExtArgs>
    client?: boolean | Bill$clientArgs<ExtArgs>
    address?: boolean | Bill$addressArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    account?: boolean | Bill$accountArgs<ExtArgs>
    client?: boolean | Bill$clientArgs<ExtArgs>
    address?: boolean | Bill$addressArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      entries: Prisma.$EntryPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      address: Prisma.$AddressPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      invoiceNumber: number | null
      subtotal: number | null
      discount: number | null
      tax: number | null
      grandTotal: number | null
      deliveryFees: number | null
      paymentMethod: string | null
      paymentStatus: $Enums.PaymentStatus
      transactionId: string | null
      notes: string | null
      type: $Enums.OrderType | null
      status: $Enums.OrderStatus | null
      deleted: boolean | null
      bookingDate: Date | null
      returnDeadline: string | null
      companyId: string
      accountId: string | null
      clientId: string | null
      addressId: string | null
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillCreateManyAndReturnArgs>(args?: SelectSubset<T, BillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends Bill$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Bill$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends Bill$accountArgs<ExtArgs> = {}>(args?: Subset<T, Bill$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends Bill$clientArgs<ExtArgs> = {}>(args?: Subset<T, Bill$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    address<T extends Bill$addressArgs<ExtArgs> = {}>(args?: Subset<T, Bill$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */ 
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'String'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
    readonly invoiceNumber: FieldRef<"Bill", 'Int'>
    readonly subtotal: FieldRef<"Bill", 'Float'>
    readonly discount: FieldRef<"Bill", 'Float'>
    readonly tax: FieldRef<"Bill", 'Float'>
    readonly grandTotal: FieldRef<"Bill", 'Float'>
    readonly deliveryFees: FieldRef<"Bill", 'Float'>
    readonly paymentMethod: FieldRef<"Bill", 'String'>
    readonly paymentStatus: FieldRef<"Bill", 'PaymentStatus'>
    readonly transactionId: FieldRef<"Bill", 'String'>
    readonly notes: FieldRef<"Bill", 'String'>
    readonly type: FieldRef<"Bill", 'OrderType'>
    readonly status: FieldRef<"Bill", 'OrderStatus'>
    readonly deleted: FieldRef<"Bill", 'Boolean'>
    readonly bookingDate: FieldRef<"Bill", 'DateTime'>
    readonly returnDeadline: FieldRef<"Bill", 'String'>
    readonly companyId: FieldRef<"Bill", 'String'>
    readonly accountId: FieldRef<"Bill", 'String'>
    readonly clientId: FieldRef<"Bill", 'String'>
    readonly addressId: FieldRef<"Bill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill createManyAndReturn
   */
  export type BillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
  }

  /**
   * Bill.entries
   */
  export type Bill$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    where?: EntryWhereInput
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    cursor?: EntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Bill.account
   */
  export type Bill$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Bill.client
   */
  export type Bill$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Bill.address
   */
  export type Bill$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model TokenEntry
   */

  export type AggregateTokenEntry = {
    _count: TokenEntryCountAggregateOutputType | null
    _avg: TokenEntryAvgAggregateOutputType | null
    _sum: TokenEntrySumAggregateOutputType | null
    _min: TokenEntryMinAggregateOutputType | null
    _max: TokenEntryMaxAggregateOutputType | null
  }

  export type TokenEntryAvgAggregateOutputType = {
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    totalQty: number | null
  }

  export type TokenEntrySumAggregateOutputType = {
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    totalQty: number | null
  }

  export type TokenEntryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    tokenNo: string | null
    companyId: string | null
    itemId: string | null
    variantId: string | null
    barcode: string | null
    categoryId: string | null
    size: string | null
    name: string | null
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    totalQty: number | null
  }

  export type TokenEntryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    tokenNo: string | null
    companyId: string | null
    itemId: string | null
    variantId: string | null
    barcode: string | null
    categoryId: string | null
    size: string | null
    name: string | null
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    totalQty: number | null
  }

  export type TokenEntryCountAggregateOutputType = {
    id: number
    createdAt: number
    tokenNo: number
    companyId: number
    itemId: number
    variantId: number
    barcode: number
    categoryId: number
    size: number
    name: number
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: number
    totalQty: number
    _all: number
  }


  export type TokenEntryAvgAggregateInputType = {
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    totalQty?: true
  }

  export type TokenEntrySumAggregateInputType = {
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    totalQty?: true
  }

  export type TokenEntryMinAggregateInputType = {
    id?: true
    createdAt?: true
    tokenNo?: true
    companyId?: true
    itemId?: true
    variantId?: true
    barcode?: true
    categoryId?: true
    size?: true
    name?: true
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    totalQty?: true
  }

  export type TokenEntryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    tokenNo?: true
    companyId?: true
    itemId?: true
    variantId?: true
    barcode?: true
    categoryId?: true
    size?: true
    name?: true
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    totalQty?: true
  }

  export type TokenEntryCountAggregateInputType = {
    id?: true
    createdAt?: true
    tokenNo?: true
    companyId?: true
    itemId?: true
    variantId?: true
    barcode?: true
    categoryId?: true
    size?: true
    name?: true
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    sizes?: true
    totalQty?: true
    _all?: true
  }

  export type TokenEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenEntry to aggregate.
     */
    where?: TokenEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenEntries to fetch.
     */
    orderBy?: TokenEntryOrderByWithRelationInput | TokenEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenEntries
    **/
    _count?: true | TokenEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenEntryMaxAggregateInputType
  }

  export type GetTokenEntryAggregateType<T extends TokenEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenEntry[P]>
      : GetScalarType<T[P], AggregateTokenEntry[P]>
  }




  export type TokenEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenEntryWhereInput
    orderBy?: TokenEntryOrderByWithAggregationInput | TokenEntryOrderByWithAggregationInput[]
    by: TokenEntryScalarFieldEnum[] | TokenEntryScalarFieldEnum
    having?: TokenEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenEntryCountAggregateInputType | true
    _avg?: TokenEntryAvgAggregateInputType
    _sum?: TokenEntrySumAggregateInputType
    _min?: TokenEntryMinAggregateInputType
    _max?: TokenEntryMaxAggregateInputType
  }

  export type TokenEntryGroupByOutputType = {
    id: string
    createdAt: Date
    tokenNo: string
    companyId: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonValue
    totalQty: number
    _count: TokenEntryCountAggregateOutputType | null
    _avg: TokenEntryAvgAggregateOutputType | null
    _sum: TokenEntrySumAggregateOutputType | null
    _min: TokenEntryMinAggregateOutputType | null
    _max: TokenEntryMaxAggregateOutputType | null
  }

  type GetTokenEntryGroupByPayload<T extends TokenEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenEntryGroupByOutputType[P]>
            : GetScalarType<T[P], TokenEntryGroupByOutputType[P]>
        }
      >
    >


  export type TokenEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    tokenNo?: boolean
    companyId?: boolean
    itemId?: boolean
    variantId?: boolean
    barcode?: boolean
    categoryId?: boolean
    size?: boolean
    name?: boolean
    qty?: boolean
    rate?: boolean
    discount?: boolean
    tax?: boolean
    value?: boolean
    sizes?: boolean
    totalQty?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenEntry"]>

  export type TokenEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    tokenNo?: boolean
    companyId?: boolean
    itemId?: boolean
    variantId?: boolean
    barcode?: boolean
    categoryId?: boolean
    size?: boolean
    name?: boolean
    qty?: boolean
    rate?: boolean
    discount?: boolean
    tax?: boolean
    value?: boolean
    sizes?: boolean
    totalQty?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenEntry"]>

  export type TokenEntrySelectScalar = {
    id?: boolean
    createdAt?: boolean
    tokenNo?: boolean
    companyId?: boolean
    itemId?: boolean
    variantId?: boolean
    barcode?: boolean
    categoryId?: boolean
    size?: boolean
    name?: boolean
    qty?: boolean
    rate?: boolean
    discount?: boolean
    tax?: boolean
    value?: boolean
    sizes?: boolean
    totalQty?: boolean
  }

  export type TokenEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type TokenEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $TokenEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenEntry"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      tokenNo: string
      companyId: string
      itemId: string
      variantId: string
      barcode: string
      categoryId: string
      size: string
      name: string
      qty: number
      rate: number
      discount: number
      tax: number
      value: number
      sizes: Prisma.JsonValue
      totalQty: number
    }, ExtArgs["result"]["tokenEntry"]>
    composites: {}
  }

  type TokenEntryGetPayload<S extends boolean | null | undefined | TokenEntryDefaultArgs> = $Result.GetResult<Prisma.$TokenEntryPayload, S>

  type TokenEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenEntryCountAggregateInputType | true
    }

  export interface TokenEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenEntry'], meta: { name: 'TokenEntry' } }
    /**
     * Find zero or one TokenEntry that matches the filter.
     * @param {TokenEntryFindUniqueArgs} args - Arguments to find a TokenEntry
     * @example
     * // Get one TokenEntry
     * const tokenEntry = await prisma.tokenEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenEntryFindUniqueArgs>(args: SelectSubset<T, TokenEntryFindUniqueArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenEntryFindUniqueOrThrowArgs} args - Arguments to find a TokenEntry
     * @example
     * // Get one TokenEntry
     * const tokenEntry = await prisma.tokenEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryFindFirstArgs} args - Arguments to find a TokenEntry
     * @example
     * // Get one TokenEntry
     * const tokenEntry = await prisma.tokenEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenEntryFindFirstArgs>(args?: SelectSubset<T, TokenEntryFindFirstArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryFindFirstOrThrowArgs} args - Arguments to find a TokenEntry
     * @example
     * // Get one TokenEntry
     * const tokenEntry = await prisma.tokenEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenEntries
     * const tokenEntries = await prisma.tokenEntry.findMany()
     * 
     * // Get first 10 TokenEntries
     * const tokenEntries = await prisma.tokenEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenEntryWithIdOnly = await prisma.tokenEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenEntryFindManyArgs>(args?: SelectSubset<T, TokenEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenEntry.
     * @param {TokenEntryCreateArgs} args - Arguments to create a TokenEntry.
     * @example
     * // Create one TokenEntry
     * const TokenEntry = await prisma.tokenEntry.create({
     *   data: {
     *     // ... data to create a TokenEntry
     *   }
     * })
     * 
     */
    create<T extends TokenEntryCreateArgs>(args: SelectSubset<T, TokenEntryCreateArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenEntries.
     * @param {TokenEntryCreateManyArgs} args - Arguments to create many TokenEntries.
     * @example
     * // Create many TokenEntries
     * const tokenEntry = await prisma.tokenEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenEntryCreateManyArgs>(args?: SelectSubset<T, TokenEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenEntries and returns the data saved in the database.
     * @param {TokenEntryCreateManyAndReturnArgs} args - Arguments to create many TokenEntries.
     * @example
     * // Create many TokenEntries
     * const tokenEntry = await prisma.tokenEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenEntries and only return the `id`
     * const tokenEntryWithIdOnly = await prisma.tokenEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenEntry.
     * @param {TokenEntryDeleteArgs} args - Arguments to delete one TokenEntry.
     * @example
     * // Delete one TokenEntry
     * const TokenEntry = await prisma.tokenEntry.delete({
     *   where: {
     *     // ... filter to delete one TokenEntry
     *   }
     * })
     * 
     */
    delete<T extends TokenEntryDeleteArgs>(args: SelectSubset<T, TokenEntryDeleteArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenEntry.
     * @param {TokenEntryUpdateArgs} args - Arguments to update one TokenEntry.
     * @example
     * // Update one TokenEntry
     * const tokenEntry = await prisma.tokenEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenEntryUpdateArgs>(args: SelectSubset<T, TokenEntryUpdateArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenEntries.
     * @param {TokenEntryDeleteManyArgs} args - Arguments to filter TokenEntries to delete.
     * @example
     * // Delete a few TokenEntries
     * const { count } = await prisma.tokenEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenEntryDeleteManyArgs>(args?: SelectSubset<T, TokenEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenEntries
     * const tokenEntry = await prisma.tokenEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenEntryUpdateManyArgs>(args: SelectSubset<T, TokenEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenEntry.
     * @param {TokenEntryUpsertArgs} args - Arguments to update or create a TokenEntry.
     * @example
     * // Update or create a TokenEntry
     * const tokenEntry = await prisma.tokenEntry.upsert({
     *   create: {
     *     // ... data to create a TokenEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenEntry we want to update
     *   }
     * })
     */
    upsert<T extends TokenEntryUpsertArgs>(args: SelectSubset<T, TokenEntryUpsertArgs<ExtArgs>>): Prisma__TokenEntryClient<$Result.GetResult<Prisma.$TokenEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryCountArgs} args - Arguments to filter TokenEntries to count.
     * @example
     * // Count the number of TokenEntries
     * const count = await prisma.tokenEntry.count({
     *   where: {
     *     // ... the filter for the TokenEntries we want to count
     *   }
     * })
    **/
    count<T extends TokenEntryCountArgs>(
      args?: Subset<T, TokenEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenEntryAggregateArgs>(args: Subset<T, TokenEntryAggregateArgs>): Prisma.PrismaPromise<GetTokenEntryAggregateType<T>>

    /**
     * Group by TokenEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenEntryGroupByArgs['orderBy'] }
        : { orderBy?: TokenEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenEntry model
   */
  readonly fields: TokenEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenEntry model
   */ 
  interface TokenEntryFieldRefs {
    readonly id: FieldRef<"TokenEntry", 'String'>
    readonly createdAt: FieldRef<"TokenEntry", 'DateTime'>
    readonly tokenNo: FieldRef<"TokenEntry", 'String'>
    readonly companyId: FieldRef<"TokenEntry", 'String'>
    readonly itemId: FieldRef<"TokenEntry", 'String'>
    readonly variantId: FieldRef<"TokenEntry", 'String'>
    readonly barcode: FieldRef<"TokenEntry", 'String'>
    readonly categoryId: FieldRef<"TokenEntry", 'String'>
    readonly size: FieldRef<"TokenEntry", 'String'>
    readonly name: FieldRef<"TokenEntry", 'String'>
    readonly qty: FieldRef<"TokenEntry", 'Int'>
    readonly rate: FieldRef<"TokenEntry", 'Int'>
    readonly discount: FieldRef<"TokenEntry", 'Int'>
    readonly tax: FieldRef<"TokenEntry", 'Int'>
    readonly value: FieldRef<"TokenEntry", 'Int'>
    readonly sizes: FieldRef<"TokenEntry", 'Json'>
    readonly totalQty: FieldRef<"TokenEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TokenEntry findUnique
   */
  export type TokenEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * Filter, which TokenEntry to fetch.
     */
    where: TokenEntryWhereUniqueInput
  }

  /**
   * TokenEntry findUniqueOrThrow
   */
  export type TokenEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * Filter, which TokenEntry to fetch.
     */
    where: TokenEntryWhereUniqueInput
  }

  /**
   * TokenEntry findFirst
   */
  export type TokenEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * Filter, which TokenEntry to fetch.
     */
    where?: TokenEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenEntries to fetch.
     */
    orderBy?: TokenEntryOrderByWithRelationInput | TokenEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenEntries.
     */
    cursor?: TokenEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenEntries.
     */
    distinct?: TokenEntryScalarFieldEnum | TokenEntryScalarFieldEnum[]
  }

  /**
   * TokenEntry findFirstOrThrow
   */
  export type TokenEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * Filter, which TokenEntry to fetch.
     */
    where?: TokenEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenEntries to fetch.
     */
    orderBy?: TokenEntryOrderByWithRelationInput | TokenEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenEntries.
     */
    cursor?: TokenEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenEntries.
     */
    distinct?: TokenEntryScalarFieldEnum | TokenEntryScalarFieldEnum[]
  }

  /**
   * TokenEntry findMany
   */
  export type TokenEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * Filter, which TokenEntries to fetch.
     */
    where?: TokenEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenEntries to fetch.
     */
    orderBy?: TokenEntryOrderByWithRelationInput | TokenEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenEntries.
     */
    cursor?: TokenEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenEntries.
     */
    skip?: number
    distinct?: TokenEntryScalarFieldEnum | TokenEntryScalarFieldEnum[]
  }

  /**
   * TokenEntry create
   */
  export type TokenEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenEntry.
     */
    data: XOR<TokenEntryCreateInput, TokenEntryUncheckedCreateInput>
  }

  /**
   * TokenEntry createMany
   */
  export type TokenEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenEntries.
     */
    data: TokenEntryCreateManyInput | TokenEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenEntry createManyAndReturn
   */
  export type TokenEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenEntries.
     */
    data: TokenEntryCreateManyInput | TokenEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenEntry update
   */
  export type TokenEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenEntry.
     */
    data: XOR<TokenEntryUpdateInput, TokenEntryUncheckedUpdateInput>
    /**
     * Choose, which TokenEntry to update.
     */
    where: TokenEntryWhereUniqueInput
  }

  /**
   * TokenEntry updateMany
   */
  export type TokenEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenEntries.
     */
    data: XOR<TokenEntryUpdateManyMutationInput, TokenEntryUncheckedUpdateManyInput>
    /**
     * Filter which TokenEntries to update
     */
    where?: TokenEntryWhereInput
  }

  /**
   * TokenEntry upsert
   */
  export type TokenEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenEntry to update in case it exists.
     */
    where: TokenEntryWhereUniqueInput
    /**
     * In case the TokenEntry found by the `where` argument doesn't exist, create a new TokenEntry with this data.
     */
    create: XOR<TokenEntryCreateInput, TokenEntryUncheckedCreateInput>
    /**
     * In case the TokenEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenEntryUpdateInput, TokenEntryUncheckedUpdateInput>
  }

  /**
   * TokenEntry delete
   */
  export type TokenEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
    /**
     * Filter which TokenEntry to delete.
     */
    where: TokenEntryWhereUniqueInput
  }

  /**
   * TokenEntry deleteMany
   */
  export type TokenEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenEntries to delete
     */
    where?: TokenEntryWhereInput
  }

  /**
   * TokenEntry without action
   */
  export type TokenEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenEntry
     */
    select?: TokenEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenEntryInclude<ExtArgs> | null
  }


  /**
   * Model Entry
   */

  export type AggregateEntry = {
    _count: EntryCountAggregateOutputType | null
    _avg: EntryAvgAggregateOutputType | null
    _sum: EntrySumAggregateOutputType | null
    _min: EntryMinAggregateOutputType | null
    _max: EntryMaxAggregateOutputType | null
  }

  export type EntryAvgAggregateOutputType = {
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
  }

  export type EntrySumAggregateOutputType = {
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
  }

  export type EntryMinAggregateOutputType = {
    id: string | null
    name: string | null
    barcode: string | null
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    size: string | null
    variantId: string | null
    outOfStock: boolean | null
    categoryId: string | null
    billId: string | null
    itemId: string | null
  }

  export type EntryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    barcode: string | null
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    size: string | null
    variantId: string | null
    outOfStock: boolean | null
    categoryId: string | null
    billId: string | null
    itemId: string | null
  }

  export type EntryCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    size: number
    variantId: number
    outOfStock: number
    categoryId: number
    billId: number
    itemId: number
    _all: number
  }


  export type EntryAvgAggregateInputType = {
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
  }

  export type EntrySumAggregateInputType = {
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
  }

  export type EntryMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    size?: true
    variantId?: true
    outOfStock?: true
    categoryId?: true
    billId?: true
    itemId?: true
  }

  export type EntryMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    size?: true
    variantId?: true
    outOfStock?: true
    categoryId?: true
    billId?: true
    itemId?: true
  }

  export type EntryCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    qty?: true
    rate?: true
    discount?: true
    tax?: true
    value?: true
    size?: true
    variantId?: true
    outOfStock?: true
    categoryId?: true
    billId?: true
    itemId?: true
    _all?: true
  }

  export type EntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entry to aggregate.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entries
    **/
    _count?: true | EntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntryMaxAggregateInputType
  }

  export type GetEntryAggregateType<T extends EntryAggregateArgs> = {
        [P in keyof T & keyof AggregateEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntry[P]>
      : GetScalarType<T[P], AggregateEntry[P]>
  }




  export type EntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntryWhereInput
    orderBy?: EntryOrderByWithAggregationInput | EntryOrderByWithAggregationInput[]
    by: EntryScalarFieldEnum[] | EntryScalarFieldEnum
    having?: EntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntryCountAggregateInputType | true
    _avg?: EntryAvgAggregateInputType
    _sum?: EntrySumAggregateInputType
    _min?: EntryMinAggregateInputType
    _max?: EntryMaxAggregateInputType
  }

  export type EntryGroupByOutputType = {
    id: string
    name: string | null
    barcode: string | null
    qty: number | null
    rate: number | null
    discount: number | null
    tax: number | null
    value: number | null
    size: string | null
    variantId: string | null
    outOfStock: boolean | null
    categoryId: string | null
    billId: string | null
    itemId: string | null
    _count: EntryCountAggregateOutputType | null
    _avg: EntryAvgAggregateOutputType | null
    _sum: EntrySumAggregateOutputType | null
    _min: EntryMinAggregateOutputType | null
    _max: EntryMaxAggregateOutputType | null
  }

  type GetEntryGroupByPayload<T extends EntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntryGroupByOutputType[P]>
            : GetScalarType<T[P], EntryGroupByOutputType[P]>
        }
      >
    >


  export type EntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    qty?: boolean
    rate?: boolean
    discount?: boolean
    tax?: boolean
    value?: boolean
    size?: boolean
    variantId?: boolean
    outOfStock?: boolean
    categoryId?: boolean
    billId?: boolean
    itemId?: boolean
    variant?: boolean | Entry$variantArgs<ExtArgs>
    category?: boolean | Entry$categoryArgs<ExtArgs>
    bill?: boolean | Entry$billArgs<ExtArgs>
    item?: boolean | Entry$itemArgs<ExtArgs>
  }, ExtArgs["result"]["entry"]>

  export type EntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    qty?: boolean
    rate?: boolean
    discount?: boolean
    tax?: boolean
    value?: boolean
    size?: boolean
    variantId?: boolean
    outOfStock?: boolean
    categoryId?: boolean
    billId?: boolean
    itemId?: boolean
    variant?: boolean | Entry$variantArgs<ExtArgs>
    category?: boolean | Entry$categoryArgs<ExtArgs>
    bill?: boolean | Entry$billArgs<ExtArgs>
    item?: boolean | Entry$itemArgs<ExtArgs>
  }, ExtArgs["result"]["entry"]>

  export type EntrySelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
    qty?: boolean
    rate?: boolean
    discount?: boolean
    tax?: boolean
    value?: boolean
    size?: boolean
    variantId?: boolean
    outOfStock?: boolean
    categoryId?: boolean
    billId?: boolean
    itemId?: boolean
  }

  export type EntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Entry$variantArgs<ExtArgs>
    category?: boolean | Entry$categoryArgs<ExtArgs>
    bill?: boolean | Entry$billArgs<ExtArgs>
    item?: boolean | Entry$itemArgs<ExtArgs>
  }
  export type EntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Entry$variantArgs<ExtArgs>
    category?: boolean | Entry$categoryArgs<ExtArgs>
    bill?: boolean | Entry$billArgs<ExtArgs>
    item?: boolean | Entry$itemArgs<ExtArgs>
  }

  export type $EntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entry"
    objects: {
      variant: Prisma.$VariantPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      bill: Prisma.$BillPayload<ExtArgs> | null
      item: Prisma.$ItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      barcode: string | null
      qty: number | null
      rate: number | null
      discount: number | null
      tax: number | null
      value: number | null
      size: string | null
      variantId: string | null
      outOfStock: boolean | null
      categoryId: string | null
      billId: string | null
      itemId: string | null
    }, ExtArgs["result"]["entry"]>
    composites: {}
  }

  type EntryGetPayload<S extends boolean | null | undefined | EntryDefaultArgs> = $Result.GetResult<Prisma.$EntryPayload, S>

  type EntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntryCountAggregateInputType | true
    }

  export interface EntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entry'], meta: { name: 'Entry' } }
    /**
     * Find zero or one Entry that matches the filter.
     * @param {EntryFindUniqueArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntryFindUniqueArgs>(args: SelectSubset<T, EntryFindUniqueArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Entry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntryFindUniqueOrThrowArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntryFindUniqueOrThrowArgs>(args: SelectSubset<T, EntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Entry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindFirstArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntryFindFirstArgs>(args?: SelectSubset<T, EntryFindFirstArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Entry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindFirstOrThrowArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntryFindFirstOrThrowArgs>(args?: SelectSubset<T, EntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entries
     * const entries = await prisma.entry.findMany()
     * 
     * // Get first 10 Entries
     * const entries = await prisma.entry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entryWithIdOnly = await prisma.entry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntryFindManyArgs>(args?: SelectSubset<T, EntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Entry.
     * @param {EntryCreateArgs} args - Arguments to create a Entry.
     * @example
     * // Create one Entry
     * const Entry = await prisma.entry.create({
     *   data: {
     *     // ... data to create a Entry
     *   }
     * })
     * 
     */
    create<T extends EntryCreateArgs>(args: SelectSubset<T, EntryCreateArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Entries.
     * @param {EntryCreateManyArgs} args - Arguments to create many Entries.
     * @example
     * // Create many Entries
     * const entry = await prisma.entry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntryCreateManyArgs>(args?: SelectSubset<T, EntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entries and returns the data saved in the database.
     * @param {EntryCreateManyAndReturnArgs} args - Arguments to create many Entries.
     * @example
     * // Create many Entries
     * const entry = await prisma.entry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entries and only return the `id`
     * const entryWithIdOnly = await prisma.entry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntryCreateManyAndReturnArgs>(args?: SelectSubset<T, EntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Entry.
     * @param {EntryDeleteArgs} args - Arguments to delete one Entry.
     * @example
     * // Delete one Entry
     * const Entry = await prisma.entry.delete({
     *   where: {
     *     // ... filter to delete one Entry
     *   }
     * })
     * 
     */
    delete<T extends EntryDeleteArgs>(args: SelectSubset<T, EntryDeleteArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Entry.
     * @param {EntryUpdateArgs} args - Arguments to update one Entry.
     * @example
     * // Update one Entry
     * const entry = await prisma.entry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntryUpdateArgs>(args: SelectSubset<T, EntryUpdateArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Entries.
     * @param {EntryDeleteManyArgs} args - Arguments to filter Entries to delete.
     * @example
     * // Delete a few Entries
     * const { count } = await prisma.entry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntryDeleteManyArgs>(args?: SelectSubset<T, EntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entries
     * const entry = await prisma.entry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntryUpdateManyArgs>(args: SelectSubset<T, EntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entry.
     * @param {EntryUpsertArgs} args - Arguments to update or create a Entry.
     * @example
     * // Update or create a Entry
     * const entry = await prisma.entry.upsert({
     *   create: {
     *     // ... data to create a Entry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entry we want to update
     *   }
     * })
     */
    upsert<T extends EntryUpsertArgs>(args: SelectSubset<T, EntryUpsertArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryCountArgs} args - Arguments to filter Entries to count.
     * @example
     * // Count the number of Entries
     * const count = await prisma.entry.count({
     *   where: {
     *     // ... the filter for the Entries we want to count
     *   }
     * })
    **/
    count<T extends EntryCountArgs>(
      args?: Subset<T, EntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntryAggregateArgs>(args: Subset<T, EntryAggregateArgs>): Prisma.PrismaPromise<GetEntryAggregateType<T>>

    /**
     * Group by Entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntryGroupByArgs['orderBy'] }
        : { orderBy?: EntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entry model
   */
  readonly fields: EntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends Entry$variantArgs<ExtArgs> = {}>(args?: Subset<T, Entry$variantArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    category<T extends Entry$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Entry$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bill<T extends Entry$billArgs<ExtArgs> = {}>(args?: Subset<T, Entry$billArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    item<T extends Entry$itemArgs<ExtArgs> = {}>(args?: Subset<T, Entry$itemArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entry model
   */ 
  interface EntryFieldRefs {
    readonly id: FieldRef<"Entry", 'String'>
    readonly name: FieldRef<"Entry", 'String'>
    readonly barcode: FieldRef<"Entry", 'String'>
    readonly qty: FieldRef<"Entry", 'Float'>
    readonly rate: FieldRef<"Entry", 'Float'>
    readonly discount: FieldRef<"Entry", 'Float'>
    readonly tax: FieldRef<"Entry", 'Float'>
    readonly value: FieldRef<"Entry", 'Float'>
    readonly size: FieldRef<"Entry", 'String'>
    readonly variantId: FieldRef<"Entry", 'String'>
    readonly outOfStock: FieldRef<"Entry", 'Boolean'>
    readonly categoryId: FieldRef<"Entry", 'String'>
    readonly billId: FieldRef<"Entry", 'String'>
    readonly itemId: FieldRef<"Entry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Entry findUnique
   */
  export type EntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry findUniqueOrThrow
   */
  export type EntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry findFirst
   */
  export type EntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entries.
     */
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry findFirstOrThrow
   */
  export type EntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entries.
     */
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry findMany
   */
  export type EntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * Filter, which Entries to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry create
   */
  export type EntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * The data needed to create a Entry.
     */
    data?: XOR<EntryCreateInput, EntryUncheckedCreateInput>
  }

  /**
   * Entry createMany
   */
  export type EntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entries.
     */
    data: EntryCreateManyInput | EntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entry createManyAndReturn
   */
  export type EntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Entries.
     */
    data: EntryCreateManyInput | EntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Entry update
   */
  export type EntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * The data needed to update a Entry.
     */
    data: XOR<EntryUpdateInput, EntryUncheckedUpdateInput>
    /**
     * Choose, which Entry to update.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry updateMany
   */
  export type EntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entries.
     */
    data: XOR<EntryUpdateManyMutationInput, EntryUncheckedUpdateManyInput>
    /**
     * Filter which Entries to update
     */
    where?: EntryWhereInput
  }

  /**
   * Entry upsert
   */
  export type EntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * The filter to search for the Entry to update in case it exists.
     */
    where: EntryWhereUniqueInput
    /**
     * In case the Entry found by the `where` argument doesn't exist, create a new Entry with this data.
     */
    create: XOR<EntryCreateInput, EntryUncheckedCreateInput>
    /**
     * In case the Entry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntryUpdateInput, EntryUncheckedUpdateInput>
  }

  /**
   * Entry delete
   */
  export type EntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
    /**
     * Filter which Entry to delete.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry deleteMany
   */
  export type EntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entries to delete
     */
    where?: EntryWhereInput
  }

  /**
   * Entry.variant
   */
  export type Entry$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    where?: VariantWhereInput
  }

  /**
   * Entry.category
   */
  export type Entry$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Entry.bill
   */
  export type Entry$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
  }

  /**
   * Entry.item
   */
  export type Entry$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Entry without action
   */
  export type EntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntryInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    companyId: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    companyId: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    companyId: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    companyId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    companyId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    companyId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    name: string
    phone: string
    companyId: string
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    companyId?: boolean
    bill?: boolean | Account$billArgs<ExtArgs>
    address?: boolean | Account$addressArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    companyId?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | Account$billArgs<ExtArgs>
    address?: boolean | Account$addressArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>[]
      address: Prisma.$AddressPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string
      companyId: string
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends Account$billArgs<ExtArgs> = {}>(args?: Subset<T, Account$billArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany"> | Null>
    address<T extends Account$addressArgs<ExtArgs> = {}>(args?: Subset<T, Account$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly phone: FieldRef<"Account", 'String'>
    readonly companyId: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.bill
   */
  export type Account$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Account.address
   */
  export type Account$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: string
    name: string
    status: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends ExpenseCategory$expensesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */ 
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'String'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly status: FieldRef<"ExpenseCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly companyId: FieldRef<"ExpenseCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
  }

  /**
   * ExpenseCategory.expenses
   */
  export type ExpenseCategory$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    taxAmount: number | null
    totalAmount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    taxAmount: number | null
    totalAmount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    expenseDate: Date | null
    note: string | null
    currency: string | null
    paymentMode: $Enums.PaymentMode | null
    status: string | null
    receipt: string | null
    receiptName: string | null
    taxAmount: number | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expensecategoryId: string | null
    companyId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    expenseDate: Date | null
    note: string | null
    currency: string | null
    paymentMode: $Enums.PaymentMode | null
    status: string | null
    receipt: string | null
    receiptName: string | null
    taxAmount: number | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expensecategoryId: string | null
    companyId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    expenseDate: number
    note: number
    currency: number
    paymentMode: number
    status: number
    receipt: number
    receiptName: number
    taxAmount: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    expensecategoryId: number
    companyId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    taxAmount?: true
    totalAmount?: true
  }

  export type ExpenseSumAggregateInputType = {
    taxAmount?: true
    totalAmount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    expenseDate?: true
    note?: true
    currency?: true
    paymentMode?: true
    status?: true
    receipt?: true
    receiptName?: true
    taxAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    expensecategoryId?: true
    companyId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    expenseDate?: true
    note?: true
    currency?: true
    paymentMode?: true
    status?: true
    receipt?: true
    receiptName?: true
    taxAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    expensecategoryId?: true
    companyId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    expenseDate?: true
    note?: true
    currency?: true
    paymentMode?: true
    status?: true
    receipt?: true
    receiptName?: true
    taxAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    expensecategoryId?: true
    companyId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    expenseDate: Date
    note: string | null
    currency: string
    paymentMode: $Enums.PaymentMode
    status: string
    receipt: string | null
    receiptName: string | null
    taxAmount: number | null
    totalAmount: number
    createdAt: Date
    updatedAt: Date
    expensecategoryId: string
    companyId: string
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseDate?: boolean
    note?: boolean
    currency?: boolean
    paymentMode?: boolean
    status?: boolean
    receipt?: boolean
    receiptName?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expensecategoryId?: boolean
    companyId?: boolean
    expensecategory?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseDate?: boolean
    note?: boolean
    currency?: boolean
    paymentMode?: boolean
    status?: boolean
    receipt?: boolean
    receiptName?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expensecategoryId?: boolean
    companyId?: boolean
    expensecategory?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    expenseDate?: boolean
    note?: boolean
    currency?: boolean
    paymentMode?: boolean
    status?: boolean
    receipt?: boolean
    receiptName?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expensecategoryId?: boolean
    companyId?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expensecategory?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expensecategory?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      expensecategory: Prisma.$ExpenseCategoryPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseDate: Date
      note: string | null
      currency: string
      paymentMode: $Enums.PaymentMode
      status: string
      receipt: string | null
      receiptName: string | null
      taxAmount: number | null
      totalAmount: number
      createdAt: Date
      updatedAt: Date
      expensecategoryId: string
      companyId: string
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expensecategory<T extends ExpenseCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategoryDefaultArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly expenseDate: FieldRef<"Expense", 'DateTime'>
    readonly note: FieldRef<"Expense", 'String'>
    readonly currency: FieldRef<"Expense", 'String'>
    readonly paymentMode: FieldRef<"Expense", 'PaymentMode'>
    readonly status: FieldRef<"Expense", 'String'>
    readonly receipt: FieldRef<"Expense", 'String'>
    readonly receiptName: FieldRef<"Expense", 'String'>
    readonly taxAmount: FieldRef<"Expense", 'Float'>
    readonly totalAmount: FieldRef<"Expense", 'Float'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
    readonly expensecategoryId: FieldRef<"Expense", 'String'>
    readonly companyId: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentDate: Date | null
    paymentMode: string | null
    paymentReference: string | null
    amount: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentDate: Date | null
    paymentMode: string | null
    paymentReference: string | null
    amount: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentDate: number
    paymentMode: number
    paymentReference: number
    amount: number
    currency: number
    status: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentDate?: true
    paymentMode?: true
    paymentReference?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentDate?: true
    paymentMode?: true
    paymentReference?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentDate?: true
    paymentMode?: true
    paymentReference?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    paymentDate: Date
    paymentMode: string
    paymentReference: string | null
    amount: number
    currency: string
    status: string
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    paymentReference?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    paymentReference?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    paymentReference?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentDate: Date
      paymentMode: string
      paymentReference: string | null
      amount: number
      currency: string
      status: string
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMode: FieldRef<"Payment", 'String'>
    readonly paymentReference: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly companyId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    street: string | null
    locality: string | null
    city: string | null
    state: string | null
    pincode: string | null
    active: boolean | null
    userId: string | null
    clientId: string | null
    distributorId: string | null
    companyId: string | null
    accountId: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    street: string | null
    locality: string | null
    city: string | null
    state: string | null
    pincode: string | null
    active: boolean | null
    userId: string | null
    clientId: string | null
    distributorId: string | null
    companyId: string | null
    accountId: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    street: number
    locality: number
    city: number
    state: number
    pincode: number
    active: number
    userId: number
    clientId: number
    distributorId: number
    companyId: number
    accountId: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    street?: true
    locality?: true
    city?: true
    state?: true
    pincode?: true
    active?: true
    userId?: true
    clientId?: true
    distributorId?: true
    companyId?: true
    accountId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    street?: true
    locality?: true
    city?: true
    state?: true
    pincode?: true
    active?: true
    userId?: true
    clientId?: true
    distributorId?: true
    companyId?: true
    accountId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    street?: true
    locality?: true
    city?: true
    state?: true
    pincode?: true
    active?: true
    userId?: true
    clientId?: true
    distributorId?: true
    companyId?: true
    accountId?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active: boolean
    userId: string | null
    clientId: string | null
    distributorId: string | null
    companyId: string | null
    accountId: string | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    street?: boolean
    locality?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    active?: boolean
    userId?: boolean
    clientId?: boolean
    distributorId?: boolean
    companyId?: boolean
    accountId?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
    client?: boolean | Address$clientArgs<ExtArgs>
    distributor?: boolean | Address$distributorArgs<ExtArgs>
    company?: boolean | Address$companyArgs<ExtArgs>
    account?: boolean | Address$accountArgs<ExtArgs>
    bill?: boolean | Address$billArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    street?: boolean
    locality?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    active?: boolean
    userId?: boolean
    clientId?: boolean
    distributorId?: boolean
    companyId?: boolean
    accountId?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
    client?: boolean | Address$clientArgs<ExtArgs>
    distributor?: boolean | Address$distributorArgs<ExtArgs>
    company?: boolean | Address$companyArgs<ExtArgs>
    account?: boolean | Address$accountArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    street?: boolean
    locality?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    active?: boolean
    userId?: boolean
    clientId?: boolean
    distributorId?: boolean
    companyId?: boolean
    accountId?: boolean
  }

  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
    client?: boolean | Address$clientArgs<ExtArgs>
    distributor?: boolean | Address$distributorArgs<ExtArgs>
    company?: boolean | Address$companyArgs<ExtArgs>
    account?: boolean | Address$accountArgs<ExtArgs>
    bill?: boolean | Address$billArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
    client?: boolean | Address$clientArgs<ExtArgs>
    distributor?: boolean | Address$distributorArgs<ExtArgs>
    company?: boolean | Address$companyArgs<ExtArgs>
    account?: boolean | Address$accountArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      distributor: Prisma.$DistributorPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      account: Prisma.$AccountPayload<ExtArgs> | null
      bill: Prisma.$BillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string | null
      street: string
      locality: string
      city: string
      state: string
      pincode: string
      active: boolean
      userId: string | null
      clientId: string | null
      distributorId: string | null
      companyId: string | null
      accountId: string | null
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Address$userArgs<ExtArgs> = {}>(args?: Subset<T, Address$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends Address$clientArgs<ExtArgs> = {}>(args?: Subset<T, Address$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    distributor<T extends Address$distributorArgs<ExtArgs> = {}>(args?: Subset<T, Address$distributorArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends Address$companyArgs<ExtArgs> = {}>(args?: Subset<T, Address$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    account<T extends Address$accountArgs<ExtArgs> = {}>(args?: Subset<T, Address$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bill<T extends Address$billArgs<ExtArgs> = {}>(args?: Subset<T, Address$billArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
    readonly name: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly locality: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly pincode: FieldRef<"Address", 'String'>
    readonly active: FieldRef<"Address", 'Boolean'>
    readonly userId: FieldRef<"Address", 'String'>
    readonly clientId: FieldRef<"Address", 'String'>
    readonly distributorId: FieldRef<"Address", 'String'>
    readonly companyId: FieldRef<"Address", 'String'>
    readonly accountId: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }

  /**
   * Address.user
   */
  export type Address$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Address.client
   */
  export type Address$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Address.distributor
   */
  export type Address$distributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    where?: DistributorWhereInput
  }

  /**
   * Address.company
   */
  export type Address$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Address.account
   */
  export type Address$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Address.bill
   */
  export type Address$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    users?: boolean | Conversation$usersArgs<ExtArgs>
    clients?: boolean | Conversation$clientsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    users?: boolean | Conversation$usersArgs<ExtArgs>
    clients?: boolean | Conversation$clientsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      users: Prisma.$UserConversationPayload<ExtArgs>[]
      clients: Prisma.$ClientConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Conversation$usersArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findMany"> | Null>
    clients<T extends Conversation$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.users
   */
  export type Conversation$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    where?: UserConversationWhereInput
    orderBy?: UserConversationOrderByWithRelationInput | UserConversationOrderByWithRelationInput[]
    cursor?: UserConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConversationScalarFieldEnum | UserConversationScalarFieldEnum[]
  }

  /**
   * Conversation.clients
   */
  export type Conversation$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    where?: ClientConversationWhereInput
    orderBy?: ClientConversationOrderByWithRelationInput | ClientConversationOrderByWithRelationInput[]
    cursor?: ClientConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientConversationScalarFieldEnum | ClientConversationScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    conversationId: string | null
    senderId: string | null
    text: string | null
    replyto: string | null
    edited: boolean | null
    deleted: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    conversationId: string | null
    senderId: string | null
    text: string | null
    replyto: string | null
    edited: boolean | null
    deleted: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    conversationId: number
    senderId: number
    text: number
    seen: number
    replyto: number
    edited: number
    deleted: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    senderId?: true
    text?: true
    replyto?: true
    edited?: true
    deleted?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    senderId?: true
    text?: true
    replyto?: true
    edited?: true
    deleted?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    senderId?: true
    text?: true
    seen?: true
    replyto?: true
    edited?: true
    deleted?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    conversationId: string
    senderId: string
    text: string
    seen: string[]
    replyto: string | null
    edited: boolean
    deleted: boolean
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    senderId?: boolean
    text?: boolean
    seen?: boolean
    replyto?: boolean
    edited?: boolean
    deleted?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    senderId?: boolean
    text?: boolean
    seen?: boolean
    replyto?: boolean
    edited?: boolean
    deleted?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    senderId?: boolean
    text?: boolean
    seen?: boolean
    replyto?: boolean
    edited?: boolean
    deleted?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      conversationId: string
      senderId: string
      text: string
      seen: string[]
      replyto: string | null
      edited: boolean
      deleted: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly text: FieldRef<"Message", 'String'>
    readonly seen: FieldRef<"Message", 'String[]'>
    readonly replyto: FieldRef<"Message", 'String'>
    readonly edited: FieldRef<"Message", 'Boolean'>
    readonly deleted: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model CompanyUser
   */

  export type AggregateCompanyUser = {
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  export type CompanyUserMinAggregateOutputType = {
    companyId: string | null
    userId: string | null
  }

  export type CompanyUserMaxAggregateOutputType = {
    companyId: string | null
    userId: string | null
  }

  export type CompanyUserCountAggregateOutputType = {
    companyId: number
    userId: number
    _all: number
  }


  export type CompanyUserMinAggregateInputType = {
    companyId?: true
    userId?: true
  }

  export type CompanyUserMaxAggregateInputType = {
    companyId?: true
    userId?: true
  }

  export type CompanyUserCountAggregateInputType = {
    companyId?: true
    userId?: true
    _all?: true
  }

  export type CompanyUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUser to aggregate.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyUsers
    **/
    _count?: true | CompanyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyUserMaxAggregateInputType
  }

  export type GetCompanyUserAggregateType<T extends CompanyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyUser[P]>
      : GetScalarType<T[P], AggregateCompanyUser[P]>
  }




  export type CompanyUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithAggregationInput | CompanyUserOrderByWithAggregationInput[]
    by: CompanyUserScalarFieldEnum[] | CompanyUserScalarFieldEnum
    having?: CompanyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyUserCountAggregateInputType | true
    _min?: CompanyUserMinAggregateInputType
    _max?: CompanyUserMaxAggregateInputType
  }

  export type CompanyUserGroupByOutputType = {
    companyId: string
    userId: string
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  type GetCompanyUserGroupByPayload<T extends CompanyUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
        }
      >
    >


  export type CompanyUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    userId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    userId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectScalar = {
    companyId?: boolean
    userId?: boolean
  }

  export type CompanyUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CompanyUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyUser"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      companyId: string
      userId: string
    }, ExtArgs["result"]["companyUser"]>
    composites: {}
  }

  type CompanyUserGetPayload<S extends boolean | null | undefined | CompanyUserDefaultArgs> = $Result.GetResult<Prisma.$CompanyUserPayload, S>

  type CompanyUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyUserCountAggregateInputType | true
    }

  export interface CompanyUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyUser'], meta: { name: 'CompanyUser' } }
    /**
     * Find zero or one CompanyUser that matches the filter.
     * @param {CompanyUserFindUniqueArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyUserFindUniqueArgs>(args: SelectSubset<T, CompanyUserFindUniqueArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyUserFindUniqueOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyUserFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyUserFindFirstArgs>(args?: SelectSubset<T, CompanyUserFindFirstArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyUserFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany()
     * 
     * // Get first 10 CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany({ take: 10 })
     * 
     * // Only select the `companyId`
     * const companyUserWithCompanyIdOnly = await prisma.companyUser.findMany({ select: { companyId: true } })
     * 
     */
    findMany<T extends CompanyUserFindManyArgs>(args?: SelectSubset<T, CompanyUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyUser.
     * @param {CompanyUserCreateArgs} args - Arguments to create a CompanyUser.
     * @example
     * // Create one CompanyUser
     * const CompanyUser = await prisma.companyUser.create({
     *   data: {
     *     // ... data to create a CompanyUser
     *   }
     * })
     * 
     */
    create<T extends CompanyUserCreateArgs>(args: SelectSubset<T, CompanyUserCreateArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyUsers.
     * @param {CompanyUserCreateManyArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyUserCreateManyArgs>(args?: SelectSubset<T, CompanyUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyUsers and returns the data saved in the database.
     * @param {CompanyUserCreateManyAndReturnArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyUsers and only return the `companyId`
     * const companyUserWithCompanyIdOnly = await prisma.companyUser.createManyAndReturn({ 
     *   select: { companyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyUserCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyUser.
     * @param {CompanyUserDeleteArgs} args - Arguments to delete one CompanyUser.
     * @example
     * // Delete one CompanyUser
     * const CompanyUser = await prisma.companyUser.delete({
     *   where: {
     *     // ... filter to delete one CompanyUser
     *   }
     * })
     * 
     */
    delete<T extends CompanyUserDeleteArgs>(args: SelectSubset<T, CompanyUserDeleteArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyUser.
     * @param {CompanyUserUpdateArgs} args - Arguments to update one CompanyUser.
     * @example
     * // Update one CompanyUser
     * const companyUser = await prisma.companyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUserUpdateArgs>(args: SelectSubset<T, CompanyUserUpdateArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyUsers.
     * @param {CompanyUserDeleteManyArgs} args - Arguments to filter CompanyUsers to delete.
     * @example
     * // Delete a few CompanyUsers
     * const { count } = await prisma.companyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyUserDeleteManyArgs>(args?: SelectSubset<T, CompanyUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyUsers
     * const companyUser = await prisma.companyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUserUpdateManyArgs>(args: SelectSubset<T, CompanyUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyUser.
     * @param {CompanyUserUpsertArgs} args - Arguments to update or create a CompanyUser.
     * @example
     * // Update or create a CompanyUser
     * const companyUser = await prisma.companyUser.upsert({
     *   create: {
     *     // ... data to create a CompanyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyUser we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUserUpsertArgs>(args: SelectSubset<T, CompanyUserUpsertArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserCountArgs} args - Arguments to filter CompanyUsers to count.
     * @example
     * // Count the number of CompanyUsers
     * const count = await prisma.companyUser.count({
     *   where: {
     *     // ... the filter for the CompanyUsers we want to count
     *   }
     * })
    **/
    count<T extends CompanyUserCountArgs>(
      args?: Subset<T, CompanyUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyUserAggregateArgs>(args: Subset<T, CompanyUserAggregateArgs>): Prisma.PrismaPromise<GetCompanyUserAggregateType<T>>

    /**
     * Group by CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyUserGroupByArgs['orderBy'] }
        : { orderBy?: CompanyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyUser model
   */
  readonly fields: CompanyUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyUser model
   */ 
  interface CompanyUserFieldRefs {
    readonly companyId: FieldRef<"CompanyUser", 'String'>
    readonly userId: FieldRef<"CompanyUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyUser findUnique
   */
  export type CompanyUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findUniqueOrThrow
   */
  export type CompanyUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findFirst
   */
  export type CompanyUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findFirstOrThrow
   */
  export type CompanyUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findMany
   */
  export type CompanyUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUsers to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser create
   */
  export type CompanyUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyUser.
     */
    data: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
  }

  /**
   * CompanyUser createMany
   */
  export type CompanyUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUser createManyAndReturn
   */
  export type CompanyUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyUser update
   */
  export type CompanyUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyUser.
     */
    data: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
    /**
     * Choose, which CompanyUser to update.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser updateMany
   */
  export type CompanyUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyUsers.
     */
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUsers to update
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser upsert
   */
  export type CompanyUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyUser to update in case it exists.
     */
    where: CompanyUserWhereUniqueInput
    /**
     * In case the CompanyUser found by the `where` argument doesn't exist, create a new CompanyUser with this data.
     */
    create: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
    /**
     * In case the CompanyUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
  }

  /**
   * CompanyUser delete
   */
  export type CompanyUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter which CompanyUser to delete.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser deleteMany
   */
  export type CompanyUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUsers to delete
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser without action
   */
  export type CompanyUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
  }


  /**
   * Model CompanyClient
   */

  export type AggregateCompanyClient = {
    _count: CompanyClientCountAggregateOutputType | null
    _min: CompanyClientMinAggregateOutputType | null
    _max: CompanyClientMaxAggregateOutputType | null
  }

  export type CompanyClientMinAggregateOutputType = {
    companyId: string | null
    clientId: string | null
  }

  export type CompanyClientMaxAggregateOutputType = {
    companyId: string | null
    clientId: string | null
  }

  export type CompanyClientCountAggregateOutputType = {
    companyId: number
    clientId: number
    _all: number
  }


  export type CompanyClientMinAggregateInputType = {
    companyId?: true
    clientId?: true
  }

  export type CompanyClientMaxAggregateInputType = {
    companyId?: true
    clientId?: true
  }

  export type CompanyClientCountAggregateInputType = {
    companyId?: true
    clientId?: true
    _all?: true
  }

  export type CompanyClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyClient to aggregate.
     */
    where?: CompanyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyClients to fetch.
     */
    orderBy?: CompanyClientOrderByWithRelationInput | CompanyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyClients
    **/
    _count?: true | CompanyClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyClientMaxAggregateInputType
  }

  export type GetCompanyClientAggregateType<T extends CompanyClientAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyClient[P]>
      : GetScalarType<T[P], AggregateCompanyClient[P]>
  }




  export type CompanyClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyClientWhereInput
    orderBy?: CompanyClientOrderByWithAggregationInput | CompanyClientOrderByWithAggregationInput[]
    by: CompanyClientScalarFieldEnum[] | CompanyClientScalarFieldEnum
    having?: CompanyClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyClientCountAggregateInputType | true
    _min?: CompanyClientMinAggregateInputType
    _max?: CompanyClientMaxAggregateInputType
  }

  export type CompanyClientGroupByOutputType = {
    companyId: string
    clientId: string
    _count: CompanyClientCountAggregateOutputType | null
    _min: CompanyClientMinAggregateOutputType | null
    _max: CompanyClientMaxAggregateOutputType | null
  }

  type GetCompanyClientGroupByPayload<T extends CompanyClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyClientGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyClientGroupByOutputType[P]>
        }
      >
    >


  export type CompanyClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    clientId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyClient"]>

  export type CompanyClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    clientId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyClient"]>

  export type CompanyClientSelectScalar = {
    companyId?: boolean
    clientId?: boolean
  }

  export type CompanyClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type CompanyClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $CompanyClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyClient"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      companyId: string
      clientId: string
    }, ExtArgs["result"]["companyClient"]>
    composites: {}
  }

  type CompanyClientGetPayload<S extends boolean | null | undefined | CompanyClientDefaultArgs> = $Result.GetResult<Prisma.$CompanyClientPayload, S>

  type CompanyClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyClientCountAggregateInputType | true
    }

  export interface CompanyClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyClient'], meta: { name: 'CompanyClient' } }
    /**
     * Find zero or one CompanyClient that matches the filter.
     * @param {CompanyClientFindUniqueArgs} args - Arguments to find a CompanyClient
     * @example
     * // Get one CompanyClient
     * const companyClient = await prisma.companyClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyClientFindUniqueArgs>(args: SelectSubset<T, CompanyClientFindUniqueArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyClient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyClientFindUniqueOrThrowArgs} args - Arguments to find a CompanyClient
     * @example
     * // Get one CompanyClient
     * const companyClient = await prisma.companyClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyClientFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientFindFirstArgs} args - Arguments to find a CompanyClient
     * @example
     * // Get one CompanyClient
     * const companyClient = await prisma.companyClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyClientFindFirstArgs>(args?: SelectSubset<T, CompanyClientFindFirstArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientFindFirstOrThrowArgs} args - Arguments to find a CompanyClient
     * @example
     * // Get one CompanyClient
     * const companyClient = await prisma.companyClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyClientFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyClients
     * const companyClients = await prisma.companyClient.findMany()
     * 
     * // Get first 10 CompanyClients
     * const companyClients = await prisma.companyClient.findMany({ take: 10 })
     * 
     * // Only select the `companyId`
     * const companyClientWithCompanyIdOnly = await prisma.companyClient.findMany({ select: { companyId: true } })
     * 
     */
    findMany<T extends CompanyClientFindManyArgs>(args?: SelectSubset<T, CompanyClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyClient.
     * @param {CompanyClientCreateArgs} args - Arguments to create a CompanyClient.
     * @example
     * // Create one CompanyClient
     * const CompanyClient = await prisma.companyClient.create({
     *   data: {
     *     // ... data to create a CompanyClient
     *   }
     * })
     * 
     */
    create<T extends CompanyClientCreateArgs>(args: SelectSubset<T, CompanyClientCreateArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyClients.
     * @param {CompanyClientCreateManyArgs} args - Arguments to create many CompanyClients.
     * @example
     * // Create many CompanyClients
     * const companyClient = await prisma.companyClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyClientCreateManyArgs>(args?: SelectSubset<T, CompanyClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyClients and returns the data saved in the database.
     * @param {CompanyClientCreateManyAndReturnArgs} args - Arguments to create many CompanyClients.
     * @example
     * // Create many CompanyClients
     * const companyClient = await prisma.companyClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyClients and only return the `companyId`
     * const companyClientWithCompanyIdOnly = await prisma.companyClient.createManyAndReturn({ 
     *   select: { companyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyClientCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyClient.
     * @param {CompanyClientDeleteArgs} args - Arguments to delete one CompanyClient.
     * @example
     * // Delete one CompanyClient
     * const CompanyClient = await prisma.companyClient.delete({
     *   where: {
     *     // ... filter to delete one CompanyClient
     *   }
     * })
     * 
     */
    delete<T extends CompanyClientDeleteArgs>(args: SelectSubset<T, CompanyClientDeleteArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyClient.
     * @param {CompanyClientUpdateArgs} args - Arguments to update one CompanyClient.
     * @example
     * // Update one CompanyClient
     * const companyClient = await prisma.companyClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyClientUpdateArgs>(args: SelectSubset<T, CompanyClientUpdateArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyClients.
     * @param {CompanyClientDeleteManyArgs} args - Arguments to filter CompanyClients to delete.
     * @example
     * // Delete a few CompanyClients
     * const { count } = await prisma.companyClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyClientDeleteManyArgs>(args?: SelectSubset<T, CompanyClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyClients
     * const companyClient = await prisma.companyClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyClientUpdateManyArgs>(args: SelectSubset<T, CompanyClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyClient.
     * @param {CompanyClientUpsertArgs} args - Arguments to update or create a CompanyClient.
     * @example
     * // Update or create a CompanyClient
     * const companyClient = await prisma.companyClient.upsert({
     *   create: {
     *     // ... data to create a CompanyClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyClient we want to update
     *   }
     * })
     */
    upsert<T extends CompanyClientUpsertArgs>(args: SelectSubset<T, CompanyClientUpsertArgs<ExtArgs>>): Prisma__CompanyClientClient<$Result.GetResult<Prisma.$CompanyClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientCountArgs} args - Arguments to filter CompanyClients to count.
     * @example
     * // Count the number of CompanyClients
     * const count = await prisma.companyClient.count({
     *   where: {
     *     // ... the filter for the CompanyClients we want to count
     *   }
     * })
    **/
    count<T extends CompanyClientCountArgs>(
      args?: Subset<T, CompanyClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyClientAggregateArgs>(args: Subset<T, CompanyClientAggregateArgs>): Prisma.PrismaPromise<GetCompanyClientAggregateType<T>>

    /**
     * Group by CompanyClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyClientGroupByArgs['orderBy'] }
        : { orderBy?: CompanyClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyClient model
   */
  readonly fields: CompanyClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyClient model
   */ 
  interface CompanyClientFieldRefs {
    readonly companyId: FieldRef<"CompanyClient", 'String'>
    readonly clientId: FieldRef<"CompanyClient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyClient findUnique
   */
  export type CompanyClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyClient to fetch.
     */
    where: CompanyClientWhereUniqueInput
  }

  /**
   * CompanyClient findUniqueOrThrow
   */
  export type CompanyClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyClient to fetch.
     */
    where: CompanyClientWhereUniqueInput
  }

  /**
   * CompanyClient findFirst
   */
  export type CompanyClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyClient to fetch.
     */
    where?: CompanyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyClients to fetch.
     */
    orderBy?: CompanyClientOrderByWithRelationInput | CompanyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyClients.
     */
    cursor?: CompanyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyClients.
     */
    distinct?: CompanyClientScalarFieldEnum | CompanyClientScalarFieldEnum[]
  }

  /**
   * CompanyClient findFirstOrThrow
   */
  export type CompanyClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyClient to fetch.
     */
    where?: CompanyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyClients to fetch.
     */
    orderBy?: CompanyClientOrderByWithRelationInput | CompanyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyClients.
     */
    cursor?: CompanyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyClients.
     */
    distinct?: CompanyClientScalarFieldEnum | CompanyClientScalarFieldEnum[]
  }

  /**
   * CompanyClient findMany
   */
  export type CompanyClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyClients to fetch.
     */
    where?: CompanyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyClients to fetch.
     */
    orderBy?: CompanyClientOrderByWithRelationInput | CompanyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyClients.
     */
    cursor?: CompanyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyClients.
     */
    skip?: number
    distinct?: CompanyClientScalarFieldEnum | CompanyClientScalarFieldEnum[]
  }

  /**
   * CompanyClient create
   */
  export type CompanyClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyClient.
     */
    data: XOR<CompanyClientCreateInput, CompanyClientUncheckedCreateInput>
  }

  /**
   * CompanyClient createMany
   */
  export type CompanyClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyClients.
     */
    data: CompanyClientCreateManyInput | CompanyClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyClient createManyAndReturn
   */
  export type CompanyClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyClients.
     */
    data: CompanyClientCreateManyInput | CompanyClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyClient update
   */
  export type CompanyClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyClient.
     */
    data: XOR<CompanyClientUpdateInput, CompanyClientUncheckedUpdateInput>
    /**
     * Choose, which CompanyClient to update.
     */
    where: CompanyClientWhereUniqueInput
  }

  /**
   * CompanyClient updateMany
   */
  export type CompanyClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyClients.
     */
    data: XOR<CompanyClientUpdateManyMutationInput, CompanyClientUncheckedUpdateManyInput>
    /**
     * Filter which CompanyClients to update
     */
    where?: CompanyClientWhereInput
  }

  /**
   * CompanyClient upsert
   */
  export type CompanyClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyClient to update in case it exists.
     */
    where: CompanyClientWhereUniqueInput
    /**
     * In case the CompanyClient found by the `where` argument doesn't exist, create a new CompanyClient with this data.
     */
    create: XOR<CompanyClientCreateInput, CompanyClientUncheckedCreateInput>
    /**
     * In case the CompanyClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyClientUpdateInput, CompanyClientUncheckedUpdateInput>
  }

  /**
   * CompanyClient delete
   */
  export type CompanyClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
    /**
     * Filter which CompanyClient to delete.
     */
    where: CompanyClientWhereUniqueInput
  }

  /**
   * CompanyClient deleteMany
   */
  export type CompanyClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyClients to delete
     */
    where?: CompanyClientWhereInput
  }

  /**
   * CompanyClient without action
   */
  export type CompanyClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyClient
     */
    select?: CompanyClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyClientInclude<ExtArgs> | null
  }


  /**
   * Model UserConversation
   */

  export type AggregateUserConversation = {
    _count: UserConversationCountAggregateOutputType | null
    _min: UserConversationMinAggregateOutputType | null
    _max: UserConversationMaxAggregateOutputType | null
  }

  export type UserConversationMinAggregateOutputType = {
    userId: string | null
    conversationId: string | null
  }

  export type UserConversationMaxAggregateOutputType = {
    userId: string | null
    conversationId: string | null
  }

  export type UserConversationCountAggregateOutputType = {
    userId: number
    conversationId: number
    _all: number
  }


  export type UserConversationMinAggregateInputType = {
    userId?: true
    conversationId?: true
  }

  export type UserConversationMaxAggregateInputType = {
    userId?: true
    conversationId?: true
  }

  export type UserConversationCountAggregateInputType = {
    userId?: true
    conversationId?: true
    _all?: true
  }

  export type UserConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConversation to aggregate.
     */
    where?: UserConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversations to fetch.
     */
    orderBy?: UserConversationOrderByWithRelationInput | UserConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConversations
    **/
    _count?: true | UserConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConversationMaxAggregateInputType
  }

  export type GetUserConversationAggregateType<T extends UserConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConversation[P]>
      : GetScalarType<T[P], AggregateUserConversation[P]>
  }




  export type UserConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationWhereInput
    orderBy?: UserConversationOrderByWithAggregationInput | UserConversationOrderByWithAggregationInput[]
    by: UserConversationScalarFieldEnum[] | UserConversationScalarFieldEnum
    having?: UserConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConversationCountAggregateInputType | true
    _min?: UserConversationMinAggregateInputType
    _max?: UserConversationMaxAggregateInputType
  }

  export type UserConversationGroupByOutputType = {
    userId: string
    conversationId: string
    _count: UserConversationCountAggregateOutputType | null
    _min: UserConversationMinAggregateOutputType | null
    _max: UserConversationMaxAggregateOutputType | null
  }

  type GetUserConversationGroupByPayload<T extends UserConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConversationGroupByOutputType[P]>
            : GetScalarType<T[P], UserConversationGroupByOutputType[P]>
        }
      >
    >


  export type UserConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    conversationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConversation"]>

  export type UserConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    conversationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConversation"]>

  export type UserConversationSelectScalar = {
    userId?: boolean
    conversationId?: boolean
  }

  export type UserConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type UserConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $UserConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      conversationId: string
    }, ExtArgs["result"]["userConversation"]>
    composites: {}
  }

  type UserConversationGetPayload<S extends boolean | null | undefined | UserConversationDefaultArgs> = $Result.GetResult<Prisma.$UserConversationPayload, S>

  type UserConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserConversationCountAggregateInputType | true
    }

  export interface UserConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConversation'], meta: { name: 'UserConversation' } }
    /**
     * Find zero or one UserConversation that matches the filter.
     * @param {UserConversationFindUniqueArgs} args - Arguments to find a UserConversation
     * @example
     * // Get one UserConversation
     * const userConversation = await prisma.userConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConversationFindUniqueArgs>(args: SelectSubset<T, UserConversationFindUniqueArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserConversationFindUniqueOrThrowArgs} args - Arguments to find a UserConversation
     * @example
     * // Get one UserConversation
     * const userConversation = await prisma.userConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationFindFirstArgs} args - Arguments to find a UserConversation
     * @example
     * // Get one UserConversation
     * const userConversation = await prisma.userConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConversationFindFirstArgs>(args?: SelectSubset<T, UserConversationFindFirstArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationFindFirstOrThrowArgs} args - Arguments to find a UserConversation
     * @example
     * // Get one UserConversation
     * const userConversation = await prisma.userConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConversations
     * const userConversations = await prisma.userConversation.findMany()
     * 
     * // Get first 10 UserConversations
     * const userConversations = await prisma.userConversation.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userConversationWithUserIdOnly = await prisma.userConversation.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserConversationFindManyArgs>(args?: SelectSubset<T, UserConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserConversation.
     * @param {UserConversationCreateArgs} args - Arguments to create a UserConversation.
     * @example
     * // Create one UserConversation
     * const UserConversation = await prisma.userConversation.create({
     *   data: {
     *     // ... data to create a UserConversation
     *   }
     * })
     * 
     */
    create<T extends UserConversationCreateArgs>(args: SelectSubset<T, UserConversationCreateArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserConversations.
     * @param {UserConversationCreateManyArgs} args - Arguments to create many UserConversations.
     * @example
     * // Create many UserConversations
     * const userConversation = await prisma.userConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConversationCreateManyArgs>(args?: SelectSubset<T, UserConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConversations and returns the data saved in the database.
     * @param {UserConversationCreateManyAndReturnArgs} args - Arguments to create many UserConversations.
     * @example
     * // Create many UserConversations
     * const userConversation = await prisma.userConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConversations and only return the `userId`
     * const userConversationWithUserIdOnly = await prisma.userConversation.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserConversation.
     * @param {UserConversationDeleteArgs} args - Arguments to delete one UserConversation.
     * @example
     * // Delete one UserConversation
     * const UserConversation = await prisma.userConversation.delete({
     *   where: {
     *     // ... filter to delete one UserConversation
     *   }
     * })
     * 
     */
    delete<T extends UserConversationDeleteArgs>(args: SelectSubset<T, UserConversationDeleteArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserConversation.
     * @param {UserConversationUpdateArgs} args - Arguments to update one UserConversation.
     * @example
     * // Update one UserConversation
     * const userConversation = await prisma.userConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConversationUpdateArgs>(args: SelectSubset<T, UserConversationUpdateArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserConversations.
     * @param {UserConversationDeleteManyArgs} args - Arguments to filter UserConversations to delete.
     * @example
     * // Delete a few UserConversations
     * const { count } = await prisma.userConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConversationDeleteManyArgs>(args?: SelectSubset<T, UserConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConversations
     * const userConversation = await prisma.userConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConversationUpdateManyArgs>(args: SelectSubset<T, UserConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserConversation.
     * @param {UserConversationUpsertArgs} args - Arguments to update or create a UserConversation.
     * @example
     * // Update or create a UserConversation
     * const userConversation = await prisma.userConversation.upsert({
     *   create: {
     *     // ... data to create a UserConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConversation we want to update
     *   }
     * })
     */
    upsert<T extends UserConversationUpsertArgs>(args: SelectSubset<T, UserConversationUpsertArgs<ExtArgs>>): Prisma__UserConversationClient<$Result.GetResult<Prisma.$UserConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationCountArgs} args - Arguments to filter UserConversations to count.
     * @example
     * // Count the number of UserConversations
     * const count = await prisma.userConversation.count({
     *   where: {
     *     // ... the filter for the UserConversations we want to count
     *   }
     * })
    **/
    count<T extends UserConversationCountArgs>(
      args?: Subset<T, UserConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConversationAggregateArgs>(args: Subset<T, UserConversationAggregateArgs>): Prisma.PrismaPromise<GetUserConversationAggregateType<T>>

    /**
     * Group by UserConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConversationGroupByArgs['orderBy'] }
        : { orderBy?: UserConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConversation model
   */
  readonly fields: UserConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConversation model
   */ 
  interface UserConversationFieldRefs {
    readonly userId: FieldRef<"UserConversation", 'String'>
    readonly conversationId: FieldRef<"UserConversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserConversation findUnique
   */
  export type UserConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * Filter, which UserConversation to fetch.
     */
    where: UserConversationWhereUniqueInput
  }

  /**
   * UserConversation findUniqueOrThrow
   */
  export type UserConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * Filter, which UserConversation to fetch.
     */
    where: UserConversationWhereUniqueInput
  }

  /**
   * UserConversation findFirst
   */
  export type UserConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * Filter, which UserConversation to fetch.
     */
    where?: UserConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversations to fetch.
     */
    orderBy?: UserConversationOrderByWithRelationInput | UserConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConversations.
     */
    cursor?: UserConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConversations.
     */
    distinct?: UserConversationScalarFieldEnum | UserConversationScalarFieldEnum[]
  }

  /**
   * UserConversation findFirstOrThrow
   */
  export type UserConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * Filter, which UserConversation to fetch.
     */
    where?: UserConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversations to fetch.
     */
    orderBy?: UserConversationOrderByWithRelationInput | UserConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConversations.
     */
    cursor?: UserConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConversations.
     */
    distinct?: UserConversationScalarFieldEnum | UserConversationScalarFieldEnum[]
  }

  /**
   * UserConversation findMany
   */
  export type UserConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * Filter, which UserConversations to fetch.
     */
    where?: UserConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversations to fetch.
     */
    orderBy?: UserConversationOrderByWithRelationInput | UserConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConversations.
     */
    cursor?: UserConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversations.
     */
    skip?: number
    distinct?: UserConversationScalarFieldEnum | UserConversationScalarFieldEnum[]
  }

  /**
   * UserConversation create
   */
  export type UserConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConversation.
     */
    data: XOR<UserConversationCreateInput, UserConversationUncheckedCreateInput>
  }

  /**
   * UserConversation createMany
   */
  export type UserConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConversations.
     */
    data: UserConversationCreateManyInput | UserConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConversation createManyAndReturn
   */
  export type UserConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserConversations.
     */
    data: UserConversationCreateManyInput | UserConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConversation update
   */
  export type UserConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConversation.
     */
    data: XOR<UserConversationUpdateInput, UserConversationUncheckedUpdateInput>
    /**
     * Choose, which UserConversation to update.
     */
    where: UserConversationWhereUniqueInput
  }

  /**
   * UserConversation updateMany
   */
  export type UserConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConversations.
     */
    data: XOR<UserConversationUpdateManyMutationInput, UserConversationUncheckedUpdateManyInput>
    /**
     * Filter which UserConversations to update
     */
    where?: UserConversationWhereInput
  }

  /**
   * UserConversation upsert
   */
  export type UserConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConversation to update in case it exists.
     */
    where: UserConversationWhereUniqueInput
    /**
     * In case the UserConversation found by the `where` argument doesn't exist, create a new UserConversation with this data.
     */
    create: XOR<UserConversationCreateInput, UserConversationUncheckedCreateInput>
    /**
     * In case the UserConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConversationUpdateInput, UserConversationUncheckedUpdateInput>
  }

  /**
   * UserConversation delete
   */
  export type UserConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
    /**
     * Filter which UserConversation to delete.
     */
    where: UserConversationWhereUniqueInput
  }

  /**
   * UserConversation deleteMany
   */
  export type UserConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConversations to delete
     */
    where?: UserConversationWhereInput
  }

  /**
   * UserConversation without action
   */
  export type UserConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversation
     */
    select?: UserConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationInclude<ExtArgs> | null
  }


  /**
   * Model ClientConversation
   */

  export type AggregateClientConversation = {
    _count: ClientConversationCountAggregateOutputType | null
    _min: ClientConversationMinAggregateOutputType | null
    _max: ClientConversationMaxAggregateOutputType | null
  }

  export type ClientConversationMinAggregateOutputType = {
    clientId: string | null
    conversationId: string | null
  }

  export type ClientConversationMaxAggregateOutputType = {
    clientId: string | null
    conversationId: string | null
  }

  export type ClientConversationCountAggregateOutputType = {
    clientId: number
    conversationId: number
    _all: number
  }


  export type ClientConversationMinAggregateInputType = {
    clientId?: true
    conversationId?: true
  }

  export type ClientConversationMaxAggregateInputType = {
    clientId?: true
    conversationId?: true
  }

  export type ClientConversationCountAggregateInputType = {
    clientId?: true
    conversationId?: true
    _all?: true
  }

  export type ClientConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientConversation to aggregate.
     */
    where?: ClientConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientConversations to fetch.
     */
    orderBy?: ClientConversationOrderByWithRelationInput | ClientConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientConversations
    **/
    _count?: true | ClientConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientConversationMaxAggregateInputType
  }

  export type GetClientConversationAggregateType<T extends ClientConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateClientConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientConversation[P]>
      : GetScalarType<T[P], AggregateClientConversation[P]>
  }




  export type ClientConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientConversationWhereInput
    orderBy?: ClientConversationOrderByWithAggregationInput | ClientConversationOrderByWithAggregationInput[]
    by: ClientConversationScalarFieldEnum[] | ClientConversationScalarFieldEnum
    having?: ClientConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientConversationCountAggregateInputType | true
    _min?: ClientConversationMinAggregateInputType
    _max?: ClientConversationMaxAggregateInputType
  }

  export type ClientConversationGroupByOutputType = {
    clientId: string
    conversationId: string
    _count: ClientConversationCountAggregateOutputType | null
    _min: ClientConversationMinAggregateOutputType | null
    _max: ClientConversationMaxAggregateOutputType | null
  }

  type GetClientConversationGroupByPayload<T extends ClientConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ClientConversationGroupByOutputType[P]>
        }
      >
    >


  export type ClientConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    conversationId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientConversation"]>

  export type ClientConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    conversationId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientConversation"]>

  export type ClientConversationSelectScalar = {
    clientId?: boolean
    conversationId?: boolean
  }

  export type ClientConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ClientConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ClientConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientConversation"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientId: string
      conversationId: string
    }, ExtArgs["result"]["clientConversation"]>
    composites: {}
  }

  type ClientConversationGetPayload<S extends boolean | null | undefined | ClientConversationDefaultArgs> = $Result.GetResult<Prisma.$ClientConversationPayload, S>

  type ClientConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientConversationCountAggregateInputType | true
    }

  export interface ClientConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientConversation'], meta: { name: 'ClientConversation' } }
    /**
     * Find zero or one ClientConversation that matches the filter.
     * @param {ClientConversationFindUniqueArgs} args - Arguments to find a ClientConversation
     * @example
     * // Get one ClientConversation
     * const clientConversation = await prisma.clientConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientConversationFindUniqueArgs>(args: SelectSubset<T, ClientConversationFindUniqueArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientConversationFindUniqueOrThrowArgs} args - Arguments to find a ClientConversation
     * @example
     * // Get one ClientConversation
     * const clientConversation = await prisma.clientConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationFindFirstArgs} args - Arguments to find a ClientConversation
     * @example
     * // Get one ClientConversation
     * const clientConversation = await prisma.clientConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientConversationFindFirstArgs>(args?: SelectSubset<T, ClientConversationFindFirstArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationFindFirstOrThrowArgs} args - Arguments to find a ClientConversation
     * @example
     * // Get one ClientConversation
     * const clientConversation = await prisma.clientConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientConversations
     * const clientConversations = await prisma.clientConversation.findMany()
     * 
     * // Get first 10 ClientConversations
     * const clientConversations = await prisma.clientConversation.findMany({ take: 10 })
     * 
     * // Only select the `clientId`
     * const clientConversationWithClientIdOnly = await prisma.clientConversation.findMany({ select: { clientId: true } })
     * 
     */
    findMany<T extends ClientConversationFindManyArgs>(args?: SelectSubset<T, ClientConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientConversation.
     * @param {ClientConversationCreateArgs} args - Arguments to create a ClientConversation.
     * @example
     * // Create one ClientConversation
     * const ClientConversation = await prisma.clientConversation.create({
     *   data: {
     *     // ... data to create a ClientConversation
     *   }
     * })
     * 
     */
    create<T extends ClientConversationCreateArgs>(args: SelectSubset<T, ClientConversationCreateArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientConversations.
     * @param {ClientConversationCreateManyArgs} args - Arguments to create many ClientConversations.
     * @example
     * // Create many ClientConversations
     * const clientConversation = await prisma.clientConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientConversationCreateManyArgs>(args?: SelectSubset<T, ClientConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientConversations and returns the data saved in the database.
     * @param {ClientConversationCreateManyAndReturnArgs} args - Arguments to create many ClientConversations.
     * @example
     * // Create many ClientConversations
     * const clientConversation = await prisma.clientConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientConversations and only return the `clientId`
     * const clientConversationWithClientIdOnly = await prisma.clientConversation.createManyAndReturn({ 
     *   select: { clientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientConversation.
     * @param {ClientConversationDeleteArgs} args - Arguments to delete one ClientConversation.
     * @example
     * // Delete one ClientConversation
     * const ClientConversation = await prisma.clientConversation.delete({
     *   where: {
     *     // ... filter to delete one ClientConversation
     *   }
     * })
     * 
     */
    delete<T extends ClientConversationDeleteArgs>(args: SelectSubset<T, ClientConversationDeleteArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientConversation.
     * @param {ClientConversationUpdateArgs} args - Arguments to update one ClientConversation.
     * @example
     * // Update one ClientConversation
     * const clientConversation = await prisma.clientConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientConversationUpdateArgs>(args: SelectSubset<T, ClientConversationUpdateArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientConversations.
     * @param {ClientConversationDeleteManyArgs} args - Arguments to filter ClientConversations to delete.
     * @example
     * // Delete a few ClientConversations
     * const { count } = await prisma.clientConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientConversationDeleteManyArgs>(args?: SelectSubset<T, ClientConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientConversations
     * const clientConversation = await prisma.clientConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientConversationUpdateManyArgs>(args: SelectSubset<T, ClientConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientConversation.
     * @param {ClientConversationUpsertArgs} args - Arguments to update or create a ClientConversation.
     * @example
     * // Update or create a ClientConversation
     * const clientConversation = await prisma.clientConversation.upsert({
     *   create: {
     *     // ... data to create a ClientConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientConversation we want to update
     *   }
     * })
     */
    upsert<T extends ClientConversationUpsertArgs>(args: SelectSubset<T, ClientConversationUpsertArgs<ExtArgs>>): Prisma__ClientConversationClient<$Result.GetResult<Prisma.$ClientConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationCountArgs} args - Arguments to filter ClientConversations to count.
     * @example
     * // Count the number of ClientConversations
     * const count = await prisma.clientConversation.count({
     *   where: {
     *     // ... the filter for the ClientConversations we want to count
     *   }
     * })
    **/
    count<T extends ClientConversationCountArgs>(
      args?: Subset<T, ClientConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientConversationAggregateArgs>(args: Subset<T, ClientConversationAggregateArgs>): Prisma.PrismaPromise<GetClientConversationAggregateType<T>>

    /**
     * Group by ClientConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientConversationGroupByArgs['orderBy'] }
        : { orderBy?: ClientConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientConversation model
   */
  readonly fields: ClientConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientConversation model
   */ 
  interface ClientConversationFieldRefs {
    readonly clientId: FieldRef<"ClientConversation", 'String'>
    readonly conversationId: FieldRef<"ClientConversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientConversation findUnique
   */
  export type ClientConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * Filter, which ClientConversation to fetch.
     */
    where: ClientConversationWhereUniqueInput
  }

  /**
   * ClientConversation findUniqueOrThrow
   */
  export type ClientConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * Filter, which ClientConversation to fetch.
     */
    where: ClientConversationWhereUniqueInput
  }

  /**
   * ClientConversation findFirst
   */
  export type ClientConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * Filter, which ClientConversation to fetch.
     */
    where?: ClientConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientConversations to fetch.
     */
    orderBy?: ClientConversationOrderByWithRelationInput | ClientConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientConversations.
     */
    cursor?: ClientConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientConversations.
     */
    distinct?: ClientConversationScalarFieldEnum | ClientConversationScalarFieldEnum[]
  }

  /**
   * ClientConversation findFirstOrThrow
   */
  export type ClientConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * Filter, which ClientConversation to fetch.
     */
    where?: ClientConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientConversations to fetch.
     */
    orderBy?: ClientConversationOrderByWithRelationInput | ClientConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientConversations.
     */
    cursor?: ClientConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientConversations.
     */
    distinct?: ClientConversationScalarFieldEnum | ClientConversationScalarFieldEnum[]
  }

  /**
   * ClientConversation findMany
   */
  export type ClientConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * Filter, which ClientConversations to fetch.
     */
    where?: ClientConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientConversations to fetch.
     */
    orderBy?: ClientConversationOrderByWithRelationInput | ClientConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientConversations.
     */
    cursor?: ClientConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientConversations.
     */
    skip?: number
    distinct?: ClientConversationScalarFieldEnum | ClientConversationScalarFieldEnum[]
  }

  /**
   * ClientConversation create
   */
  export type ClientConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientConversation.
     */
    data: XOR<ClientConversationCreateInput, ClientConversationUncheckedCreateInput>
  }

  /**
   * ClientConversation createMany
   */
  export type ClientConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientConversations.
     */
    data: ClientConversationCreateManyInput | ClientConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientConversation createManyAndReturn
   */
  export type ClientConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientConversations.
     */
    data: ClientConversationCreateManyInput | ClientConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientConversation update
   */
  export type ClientConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientConversation.
     */
    data: XOR<ClientConversationUpdateInput, ClientConversationUncheckedUpdateInput>
    /**
     * Choose, which ClientConversation to update.
     */
    where: ClientConversationWhereUniqueInput
  }

  /**
   * ClientConversation updateMany
   */
  export type ClientConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientConversations.
     */
    data: XOR<ClientConversationUpdateManyMutationInput, ClientConversationUncheckedUpdateManyInput>
    /**
     * Filter which ClientConversations to update
     */
    where?: ClientConversationWhereInput
  }

  /**
   * ClientConversation upsert
   */
  export type ClientConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientConversation to update in case it exists.
     */
    where: ClientConversationWhereUniqueInput
    /**
     * In case the ClientConversation found by the `where` argument doesn't exist, create a new ClientConversation with this data.
     */
    create: XOR<ClientConversationCreateInput, ClientConversationUncheckedCreateInput>
    /**
     * In case the ClientConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientConversationUpdateInput, ClientConversationUncheckedUpdateInput>
  }

  /**
   * ClientConversation delete
   */
  export type ClientConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
    /**
     * Filter which ClientConversation to delete.
     */
    where: ClientConversationWhereUniqueInput
  }

  /**
   * ClientConversation deleteMany
   */
  export type ClientConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientConversations to delete
     */
    where?: ClientConversationWhereInput
  }

  /**
   * ClientConversation without action
   */
  export type ClientConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientConversation
     */
    select?: ClientConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientConversationInclude<ExtArgs> | null
  }


  /**
   * Model UserClient
   */

  export type AggregateUserClient = {
    _count: UserClientCountAggregateOutputType | null
    _min: UserClientMinAggregateOutputType | null
    _max: UserClientMaxAggregateOutputType | null
  }

  export type UserClientMinAggregateOutputType = {
    clientId: string | null
    userId: string | null
  }

  export type UserClientMaxAggregateOutputType = {
    clientId: string | null
    userId: string | null
  }

  export type UserClientCountAggregateOutputType = {
    clientId: number
    userId: number
    _all: number
  }


  export type UserClientMinAggregateInputType = {
    clientId?: true
    userId?: true
  }

  export type UserClientMaxAggregateInputType = {
    clientId?: true
    userId?: true
  }

  export type UserClientCountAggregateInputType = {
    clientId?: true
    userId?: true
    _all?: true
  }

  export type UserClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserClient to aggregate.
     */
    where?: UserClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClients to fetch.
     */
    orderBy?: UserClientOrderByWithRelationInput | UserClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserClients
    **/
    _count?: true | UserClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserClientMaxAggregateInputType
  }

  export type GetUserClientAggregateType<T extends UserClientAggregateArgs> = {
        [P in keyof T & keyof AggregateUserClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserClient[P]>
      : GetScalarType<T[P], AggregateUserClient[P]>
  }




  export type UserClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClientWhereInput
    orderBy?: UserClientOrderByWithAggregationInput | UserClientOrderByWithAggregationInput[]
    by: UserClientScalarFieldEnum[] | UserClientScalarFieldEnum
    having?: UserClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserClientCountAggregateInputType | true
    _min?: UserClientMinAggregateInputType
    _max?: UserClientMaxAggregateInputType
  }

  export type UserClientGroupByOutputType = {
    clientId: string
    userId: string
    _count: UserClientCountAggregateOutputType | null
    _min: UserClientMinAggregateOutputType | null
    _max: UserClientMaxAggregateOutputType | null
  }

  type GetUserClientGroupByPayload<T extends UserClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserClientGroupByOutputType[P]>
            : GetScalarType<T[P], UserClientGroupByOutputType[P]>
        }
      >
    >


  export type UserClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    userId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userClient"]>

  export type UserClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    userId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userClient"]>

  export type UserClientSelectScalar = {
    clientId?: boolean
    userId?: boolean
  }

  export type UserClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserClient"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientId: string
      userId: string
    }, ExtArgs["result"]["userClient"]>
    composites: {}
  }

  type UserClientGetPayload<S extends boolean | null | undefined | UserClientDefaultArgs> = $Result.GetResult<Prisma.$UserClientPayload, S>

  type UserClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserClientCountAggregateInputType | true
    }

  export interface UserClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserClient'], meta: { name: 'UserClient' } }
    /**
     * Find zero or one UserClient that matches the filter.
     * @param {UserClientFindUniqueArgs} args - Arguments to find a UserClient
     * @example
     * // Get one UserClient
     * const userClient = await prisma.userClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserClientFindUniqueArgs>(args: SelectSubset<T, UserClientFindUniqueArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserClient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserClientFindUniqueOrThrowArgs} args - Arguments to find a UserClient
     * @example
     * // Get one UserClient
     * const userClient = await prisma.userClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserClientFindUniqueOrThrowArgs>(args: SelectSubset<T, UserClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientFindFirstArgs} args - Arguments to find a UserClient
     * @example
     * // Get one UserClient
     * const userClient = await prisma.userClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserClientFindFirstArgs>(args?: SelectSubset<T, UserClientFindFirstArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientFindFirstOrThrowArgs} args - Arguments to find a UserClient
     * @example
     * // Get one UserClient
     * const userClient = await prisma.userClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserClientFindFirstOrThrowArgs>(args?: SelectSubset<T, UserClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserClients
     * const userClients = await prisma.userClient.findMany()
     * 
     * // Get first 10 UserClients
     * const userClients = await prisma.userClient.findMany({ take: 10 })
     * 
     * // Only select the `clientId`
     * const userClientWithClientIdOnly = await prisma.userClient.findMany({ select: { clientId: true } })
     * 
     */
    findMany<T extends UserClientFindManyArgs>(args?: SelectSubset<T, UserClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserClient.
     * @param {UserClientCreateArgs} args - Arguments to create a UserClient.
     * @example
     * // Create one UserClient
     * const UserClient = await prisma.userClient.create({
     *   data: {
     *     // ... data to create a UserClient
     *   }
     * })
     * 
     */
    create<T extends UserClientCreateArgs>(args: SelectSubset<T, UserClientCreateArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserClients.
     * @param {UserClientCreateManyArgs} args - Arguments to create many UserClients.
     * @example
     * // Create many UserClients
     * const userClient = await prisma.userClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserClientCreateManyArgs>(args?: SelectSubset<T, UserClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserClients and returns the data saved in the database.
     * @param {UserClientCreateManyAndReturnArgs} args - Arguments to create many UserClients.
     * @example
     * // Create many UserClients
     * const userClient = await prisma.userClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserClients and only return the `clientId`
     * const userClientWithClientIdOnly = await prisma.userClient.createManyAndReturn({ 
     *   select: { clientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserClientCreateManyAndReturnArgs>(args?: SelectSubset<T, UserClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserClient.
     * @param {UserClientDeleteArgs} args - Arguments to delete one UserClient.
     * @example
     * // Delete one UserClient
     * const UserClient = await prisma.userClient.delete({
     *   where: {
     *     // ... filter to delete one UserClient
     *   }
     * })
     * 
     */
    delete<T extends UserClientDeleteArgs>(args: SelectSubset<T, UserClientDeleteArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserClient.
     * @param {UserClientUpdateArgs} args - Arguments to update one UserClient.
     * @example
     * // Update one UserClient
     * const userClient = await prisma.userClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserClientUpdateArgs>(args: SelectSubset<T, UserClientUpdateArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserClients.
     * @param {UserClientDeleteManyArgs} args - Arguments to filter UserClients to delete.
     * @example
     * // Delete a few UserClients
     * const { count } = await prisma.userClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserClientDeleteManyArgs>(args?: SelectSubset<T, UserClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserClients
     * const userClient = await prisma.userClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserClientUpdateManyArgs>(args: SelectSubset<T, UserClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserClient.
     * @param {UserClientUpsertArgs} args - Arguments to update or create a UserClient.
     * @example
     * // Update or create a UserClient
     * const userClient = await prisma.userClient.upsert({
     *   create: {
     *     // ... data to create a UserClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserClient we want to update
     *   }
     * })
     */
    upsert<T extends UserClientUpsertArgs>(args: SelectSubset<T, UserClientUpsertArgs<ExtArgs>>): Prisma__UserClientClient<$Result.GetResult<Prisma.$UserClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientCountArgs} args - Arguments to filter UserClients to count.
     * @example
     * // Count the number of UserClients
     * const count = await prisma.userClient.count({
     *   where: {
     *     // ... the filter for the UserClients we want to count
     *   }
     * })
    **/
    count<T extends UserClientCountArgs>(
      args?: Subset<T, UserClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserClientAggregateArgs>(args: Subset<T, UserClientAggregateArgs>): Prisma.PrismaPromise<GetUserClientAggregateType<T>>

    /**
     * Group by UserClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserClientGroupByArgs['orderBy'] }
        : { orderBy?: UserClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserClient model
   */
  readonly fields: UserClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserClient model
   */ 
  interface UserClientFieldRefs {
    readonly clientId: FieldRef<"UserClient", 'String'>
    readonly userId: FieldRef<"UserClient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserClient findUnique
   */
  export type UserClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * Filter, which UserClient to fetch.
     */
    where: UserClientWhereUniqueInput
  }

  /**
   * UserClient findUniqueOrThrow
   */
  export type UserClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * Filter, which UserClient to fetch.
     */
    where: UserClientWhereUniqueInput
  }

  /**
   * UserClient findFirst
   */
  export type UserClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * Filter, which UserClient to fetch.
     */
    where?: UserClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClients to fetch.
     */
    orderBy?: UserClientOrderByWithRelationInput | UserClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClients.
     */
    cursor?: UserClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClients.
     */
    distinct?: UserClientScalarFieldEnum | UserClientScalarFieldEnum[]
  }

  /**
   * UserClient findFirstOrThrow
   */
  export type UserClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * Filter, which UserClient to fetch.
     */
    where?: UserClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClients to fetch.
     */
    orderBy?: UserClientOrderByWithRelationInput | UserClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClients.
     */
    cursor?: UserClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClients.
     */
    distinct?: UserClientScalarFieldEnum | UserClientScalarFieldEnum[]
  }

  /**
   * UserClient findMany
   */
  export type UserClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * Filter, which UserClients to fetch.
     */
    where?: UserClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClients to fetch.
     */
    orderBy?: UserClientOrderByWithRelationInput | UserClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserClients.
     */
    cursor?: UserClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClients.
     */
    skip?: number
    distinct?: UserClientScalarFieldEnum | UserClientScalarFieldEnum[]
  }

  /**
   * UserClient create
   */
  export type UserClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * The data needed to create a UserClient.
     */
    data: XOR<UserClientCreateInput, UserClientUncheckedCreateInput>
  }

  /**
   * UserClient createMany
   */
  export type UserClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserClients.
     */
    data: UserClientCreateManyInput | UserClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserClient createManyAndReturn
   */
  export type UserClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserClients.
     */
    data: UserClientCreateManyInput | UserClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserClient update
   */
  export type UserClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * The data needed to update a UserClient.
     */
    data: XOR<UserClientUpdateInput, UserClientUncheckedUpdateInput>
    /**
     * Choose, which UserClient to update.
     */
    where: UserClientWhereUniqueInput
  }

  /**
   * UserClient updateMany
   */
  export type UserClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserClients.
     */
    data: XOR<UserClientUpdateManyMutationInput, UserClientUncheckedUpdateManyInput>
    /**
     * Filter which UserClients to update
     */
    where?: UserClientWhereInput
  }

  /**
   * UserClient upsert
   */
  export type UserClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * The filter to search for the UserClient to update in case it exists.
     */
    where: UserClientWhereUniqueInput
    /**
     * In case the UserClient found by the `where` argument doesn't exist, create a new UserClient with this data.
     */
    create: XOR<UserClientCreateInput, UserClientUncheckedCreateInput>
    /**
     * In case the UserClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserClientUpdateInput, UserClientUncheckedUpdateInput>
  }

  /**
   * UserClient delete
   */
  export type UserClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
    /**
     * Filter which UserClient to delete.
     */
    where: UserClientWhereUniqueInput
  }

  /**
   * UserClient deleteMany
   */
  export type UserClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserClients to delete
     */
    where?: UserClientWhereInput
  }

  /**
   * UserClient without action
   */
  export type UserClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClient
     */
    select?: UserClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClientInclude<ExtArgs> | null
  }


  /**
   * Model DistributorCompany
   */

  export type AggregateDistributorCompany = {
    _count: DistributorCompanyCountAggregateOutputType | null
    _min: DistributorCompanyMinAggregateOutputType | null
    _max: DistributorCompanyMaxAggregateOutputType | null
  }

  export type DistributorCompanyMinAggregateOutputType = {
    distributorId: string | null
    companyId: string | null
  }

  export type DistributorCompanyMaxAggregateOutputType = {
    distributorId: string | null
    companyId: string | null
  }

  export type DistributorCompanyCountAggregateOutputType = {
    distributorId: number
    companyId: number
    _all: number
  }


  export type DistributorCompanyMinAggregateInputType = {
    distributorId?: true
    companyId?: true
  }

  export type DistributorCompanyMaxAggregateInputType = {
    distributorId?: true
    companyId?: true
  }

  export type DistributorCompanyCountAggregateInputType = {
    distributorId?: true
    companyId?: true
    _all?: true
  }

  export type DistributorCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributorCompany to aggregate.
     */
    where?: DistributorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributorCompanies to fetch.
     */
    orderBy?: DistributorCompanyOrderByWithRelationInput | DistributorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributorCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DistributorCompanies
    **/
    _count?: true | DistributorCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributorCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributorCompanyMaxAggregateInputType
  }

  export type GetDistributorCompanyAggregateType<T extends DistributorCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributorCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributorCompany[P]>
      : GetScalarType<T[P], AggregateDistributorCompany[P]>
  }




  export type DistributorCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributorCompanyWhereInput
    orderBy?: DistributorCompanyOrderByWithAggregationInput | DistributorCompanyOrderByWithAggregationInput[]
    by: DistributorCompanyScalarFieldEnum[] | DistributorCompanyScalarFieldEnum
    having?: DistributorCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributorCompanyCountAggregateInputType | true
    _min?: DistributorCompanyMinAggregateInputType
    _max?: DistributorCompanyMaxAggregateInputType
  }

  export type DistributorCompanyGroupByOutputType = {
    distributorId: string
    companyId: string
    _count: DistributorCompanyCountAggregateOutputType | null
    _min: DistributorCompanyMinAggregateOutputType | null
    _max: DistributorCompanyMaxAggregateOutputType | null
  }

  type GetDistributorCompanyGroupByPayload<T extends DistributorCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributorCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributorCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributorCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], DistributorCompanyGroupByOutputType[P]>
        }
      >
    >


  export type DistributorCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    distributorId?: boolean
    companyId?: boolean
    distributor?: boolean | DistributorDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributorCompany"]>

  export type DistributorCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    distributorId?: boolean
    companyId?: boolean
    distributor?: boolean | DistributorDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributorCompany"]>

  export type DistributorCompanySelectScalar = {
    distributorId?: boolean
    companyId?: boolean
  }

  export type DistributorCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    distributor?: boolean | DistributorDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DistributorCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    distributor?: boolean | DistributorDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DistributorCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DistributorCompany"
    objects: {
      distributor: Prisma.$DistributorPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      distributorId: string
      companyId: string
    }, ExtArgs["result"]["distributorCompany"]>
    composites: {}
  }

  type DistributorCompanyGetPayload<S extends boolean | null | undefined | DistributorCompanyDefaultArgs> = $Result.GetResult<Prisma.$DistributorCompanyPayload, S>

  type DistributorCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistributorCompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistributorCompanyCountAggregateInputType | true
    }

  export interface DistributorCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DistributorCompany'], meta: { name: 'DistributorCompany' } }
    /**
     * Find zero or one DistributorCompany that matches the filter.
     * @param {DistributorCompanyFindUniqueArgs} args - Arguments to find a DistributorCompany
     * @example
     * // Get one DistributorCompany
     * const distributorCompany = await prisma.distributorCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributorCompanyFindUniqueArgs>(args: SelectSubset<T, DistributorCompanyFindUniqueArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DistributorCompany that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistributorCompanyFindUniqueOrThrowArgs} args - Arguments to find a DistributorCompany
     * @example
     * // Get one DistributorCompany
     * const distributorCompany = await prisma.distributorCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributorCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributorCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DistributorCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyFindFirstArgs} args - Arguments to find a DistributorCompany
     * @example
     * // Get one DistributorCompany
     * const distributorCompany = await prisma.distributorCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributorCompanyFindFirstArgs>(args?: SelectSubset<T, DistributorCompanyFindFirstArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DistributorCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyFindFirstOrThrowArgs} args - Arguments to find a DistributorCompany
     * @example
     * // Get one DistributorCompany
     * const distributorCompany = await prisma.distributorCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributorCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributorCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DistributorCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DistributorCompanies
     * const distributorCompanies = await prisma.distributorCompany.findMany()
     * 
     * // Get first 10 DistributorCompanies
     * const distributorCompanies = await prisma.distributorCompany.findMany({ take: 10 })
     * 
     * // Only select the `distributorId`
     * const distributorCompanyWithDistributorIdOnly = await prisma.distributorCompany.findMany({ select: { distributorId: true } })
     * 
     */
    findMany<T extends DistributorCompanyFindManyArgs>(args?: SelectSubset<T, DistributorCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DistributorCompany.
     * @param {DistributorCompanyCreateArgs} args - Arguments to create a DistributorCompany.
     * @example
     * // Create one DistributorCompany
     * const DistributorCompany = await prisma.distributorCompany.create({
     *   data: {
     *     // ... data to create a DistributorCompany
     *   }
     * })
     * 
     */
    create<T extends DistributorCompanyCreateArgs>(args: SelectSubset<T, DistributorCompanyCreateArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DistributorCompanies.
     * @param {DistributorCompanyCreateManyArgs} args - Arguments to create many DistributorCompanies.
     * @example
     * // Create many DistributorCompanies
     * const distributorCompany = await prisma.distributorCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributorCompanyCreateManyArgs>(args?: SelectSubset<T, DistributorCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DistributorCompanies and returns the data saved in the database.
     * @param {DistributorCompanyCreateManyAndReturnArgs} args - Arguments to create many DistributorCompanies.
     * @example
     * // Create many DistributorCompanies
     * const distributorCompany = await prisma.distributorCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DistributorCompanies and only return the `distributorId`
     * const distributorCompanyWithDistributorIdOnly = await prisma.distributorCompany.createManyAndReturn({ 
     *   select: { distributorId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistributorCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, DistributorCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DistributorCompany.
     * @param {DistributorCompanyDeleteArgs} args - Arguments to delete one DistributorCompany.
     * @example
     * // Delete one DistributorCompany
     * const DistributorCompany = await prisma.distributorCompany.delete({
     *   where: {
     *     // ... filter to delete one DistributorCompany
     *   }
     * })
     * 
     */
    delete<T extends DistributorCompanyDeleteArgs>(args: SelectSubset<T, DistributorCompanyDeleteArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DistributorCompany.
     * @param {DistributorCompanyUpdateArgs} args - Arguments to update one DistributorCompany.
     * @example
     * // Update one DistributorCompany
     * const distributorCompany = await prisma.distributorCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributorCompanyUpdateArgs>(args: SelectSubset<T, DistributorCompanyUpdateArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DistributorCompanies.
     * @param {DistributorCompanyDeleteManyArgs} args - Arguments to filter DistributorCompanies to delete.
     * @example
     * // Delete a few DistributorCompanies
     * const { count } = await prisma.distributorCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributorCompanyDeleteManyArgs>(args?: SelectSubset<T, DistributorCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DistributorCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DistributorCompanies
     * const distributorCompany = await prisma.distributorCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributorCompanyUpdateManyArgs>(args: SelectSubset<T, DistributorCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DistributorCompany.
     * @param {DistributorCompanyUpsertArgs} args - Arguments to update or create a DistributorCompany.
     * @example
     * // Update or create a DistributorCompany
     * const distributorCompany = await prisma.distributorCompany.upsert({
     *   create: {
     *     // ... data to create a DistributorCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DistributorCompany we want to update
     *   }
     * })
     */
    upsert<T extends DistributorCompanyUpsertArgs>(args: SelectSubset<T, DistributorCompanyUpsertArgs<ExtArgs>>): Prisma__DistributorCompanyClient<$Result.GetResult<Prisma.$DistributorCompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DistributorCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyCountArgs} args - Arguments to filter DistributorCompanies to count.
     * @example
     * // Count the number of DistributorCompanies
     * const count = await prisma.distributorCompany.count({
     *   where: {
     *     // ... the filter for the DistributorCompanies we want to count
     *   }
     * })
    **/
    count<T extends DistributorCompanyCountArgs>(
      args?: Subset<T, DistributorCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributorCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DistributorCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributorCompanyAggregateArgs>(args: Subset<T, DistributorCompanyAggregateArgs>): Prisma.PrismaPromise<GetDistributorCompanyAggregateType<T>>

    /**
     * Group by DistributorCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributorCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributorCompanyGroupByArgs['orderBy'] }
        : { orderBy?: DistributorCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributorCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributorCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DistributorCompany model
   */
  readonly fields: DistributorCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DistributorCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributorCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    distributor<T extends DistributorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistributorDefaultArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DistributorCompany model
   */ 
  interface DistributorCompanyFieldRefs {
    readonly distributorId: FieldRef<"DistributorCompany", 'String'>
    readonly companyId: FieldRef<"DistributorCompany", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DistributorCompany findUnique
   */
  export type DistributorCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which DistributorCompany to fetch.
     */
    where: DistributorCompanyWhereUniqueInput
  }

  /**
   * DistributorCompany findUniqueOrThrow
   */
  export type DistributorCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which DistributorCompany to fetch.
     */
    where: DistributorCompanyWhereUniqueInput
  }

  /**
   * DistributorCompany findFirst
   */
  export type DistributorCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which DistributorCompany to fetch.
     */
    where?: DistributorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributorCompanies to fetch.
     */
    orderBy?: DistributorCompanyOrderByWithRelationInput | DistributorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributorCompanies.
     */
    cursor?: DistributorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributorCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributorCompanies.
     */
    distinct?: DistributorCompanyScalarFieldEnum | DistributorCompanyScalarFieldEnum[]
  }

  /**
   * DistributorCompany findFirstOrThrow
   */
  export type DistributorCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which DistributorCompany to fetch.
     */
    where?: DistributorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributorCompanies to fetch.
     */
    orderBy?: DistributorCompanyOrderByWithRelationInput | DistributorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributorCompanies.
     */
    cursor?: DistributorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributorCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributorCompanies.
     */
    distinct?: DistributorCompanyScalarFieldEnum | DistributorCompanyScalarFieldEnum[]
  }

  /**
   * DistributorCompany findMany
   */
  export type DistributorCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which DistributorCompanies to fetch.
     */
    where?: DistributorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributorCompanies to fetch.
     */
    orderBy?: DistributorCompanyOrderByWithRelationInput | DistributorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DistributorCompanies.
     */
    cursor?: DistributorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributorCompanies.
     */
    skip?: number
    distinct?: DistributorCompanyScalarFieldEnum | DistributorCompanyScalarFieldEnum[]
  }

  /**
   * DistributorCompany create
   */
  export type DistributorCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a DistributorCompany.
     */
    data: XOR<DistributorCompanyCreateInput, DistributorCompanyUncheckedCreateInput>
  }

  /**
   * DistributorCompany createMany
   */
  export type DistributorCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DistributorCompanies.
     */
    data: DistributorCompanyCreateManyInput | DistributorCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DistributorCompany createManyAndReturn
   */
  export type DistributorCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DistributorCompanies.
     */
    data: DistributorCompanyCreateManyInput | DistributorCompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DistributorCompany update
   */
  export type DistributorCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a DistributorCompany.
     */
    data: XOR<DistributorCompanyUpdateInput, DistributorCompanyUncheckedUpdateInput>
    /**
     * Choose, which DistributorCompany to update.
     */
    where: DistributorCompanyWhereUniqueInput
  }

  /**
   * DistributorCompany updateMany
   */
  export type DistributorCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DistributorCompanies.
     */
    data: XOR<DistributorCompanyUpdateManyMutationInput, DistributorCompanyUncheckedUpdateManyInput>
    /**
     * Filter which DistributorCompanies to update
     */
    where?: DistributorCompanyWhereInput
  }

  /**
   * DistributorCompany upsert
   */
  export type DistributorCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the DistributorCompany to update in case it exists.
     */
    where: DistributorCompanyWhereUniqueInput
    /**
     * In case the DistributorCompany found by the `where` argument doesn't exist, create a new DistributorCompany with this data.
     */
    create: XOR<DistributorCompanyCreateInput, DistributorCompanyUncheckedCreateInput>
    /**
     * In case the DistributorCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributorCompanyUpdateInput, DistributorCompanyUncheckedUpdateInput>
  }

  /**
   * DistributorCompany delete
   */
  export type DistributorCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
    /**
     * Filter which DistributorCompany to delete.
     */
    where: DistributorCompanyWhereUniqueInput
  }

  /**
   * DistributorCompany deleteMany
   */
  export type DistributorCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributorCompanies to delete
     */
    where?: DistributorCompanyWhereInput
  }

  /**
   * DistributorCompany without action
   */
  export type DistributorCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributorCompany
     */
    select?: DistributorCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorCompanyInclude<ExtArgs> | null
  }


  /**
   * Model VariantSizeBarcode
   */

  export type AggregateVariantSizeBarcode = {
    _count: VariantSizeBarcodeCountAggregateOutputType | null
    _avg: VariantSizeBarcodeAvgAggregateOutputType | null
    _sum: VariantSizeBarcodeSumAggregateOutputType | null
    _min: VariantSizeBarcodeMinAggregateOutputType | null
    _max: VariantSizeBarcodeMaxAggregateOutputType | null
  }

  export type VariantSizeBarcodeAvgAggregateOutputType = {
    id: number | null
  }

  export type VariantSizeBarcodeSumAggregateOutputType = {
    id: number | null
  }

  export type VariantSizeBarcodeMinAggregateOutputType = {
    id: number | null
    variantId: string | null
    size: string | null
    barcode: string | null
  }

  export type VariantSizeBarcodeMaxAggregateOutputType = {
    id: number | null
    variantId: string | null
    size: string | null
    barcode: string | null
  }

  export type VariantSizeBarcodeCountAggregateOutputType = {
    id: number
    variantId: number
    size: number
    barcode: number
    _all: number
  }


  export type VariantSizeBarcodeAvgAggregateInputType = {
    id?: true
  }

  export type VariantSizeBarcodeSumAggregateInputType = {
    id?: true
  }

  export type VariantSizeBarcodeMinAggregateInputType = {
    id?: true
    variantId?: true
    size?: true
    barcode?: true
  }

  export type VariantSizeBarcodeMaxAggregateInputType = {
    id?: true
    variantId?: true
    size?: true
    barcode?: true
  }

  export type VariantSizeBarcodeCountAggregateInputType = {
    id?: true
    variantId?: true
    size?: true
    barcode?: true
    _all?: true
  }

  export type VariantSizeBarcodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariantSizeBarcode to aggregate.
     */
    where?: VariantSizeBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantSizeBarcodes to fetch.
     */
    orderBy?: VariantSizeBarcodeOrderByWithRelationInput | VariantSizeBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantSizeBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantSizeBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantSizeBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariantSizeBarcodes
    **/
    _count?: true | VariantSizeBarcodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariantSizeBarcodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariantSizeBarcodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantSizeBarcodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantSizeBarcodeMaxAggregateInputType
  }

  export type GetVariantSizeBarcodeAggregateType<T extends VariantSizeBarcodeAggregateArgs> = {
        [P in keyof T & keyof AggregateVariantSizeBarcode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariantSizeBarcode[P]>
      : GetScalarType<T[P], AggregateVariantSizeBarcode[P]>
  }




  export type VariantSizeBarcodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantSizeBarcodeWhereInput
    orderBy?: VariantSizeBarcodeOrderByWithAggregationInput | VariantSizeBarcodeOrderByWithAggregationInput[]
    by: VariantSizeBarcodeScalarFieldEnum[] | VariantSizeBarcodeScalarFieldEnum
    having?: VariantSizeBarcodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantSizeBarcodeCountAggregateInputType | true
    _avg?: VariantSizeBarcodeAvgAggregateInputType
    _sum?: VariantSizeBarcodeSumAggregateInputType
    _min?: VariantSizeBarcodeMinAggregateInputType
    _max?: VariantSizeBarcodeMaxAggregateInputType
  }

  export type VariantSizeBarcodeGroupByOutputType = {
    id: number
    variantId: string
    size: string | null
    barcode: string
    _count: VariantSizeBarcodeCountAggregateOutputType | null
    _avg: VariantSizeBarcodeAvgAggregateOutputType | null
    _sum: VariantSizeBarcodeSumAggregateOutputType | null
    _min: VariantSizeBarcodeMinAggregateOutputType | null
    _max: VariantSizeBarcodeMaxAggregateOutputType | null
  }

  type GetVariantSizeBarcodeGroupByPayload<T extends VariantSizeBarcodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantSizeBarcodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantSizeBarcodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantSizeBarcodeGroupByOutputType[P]>
            : GetScalarType<T[P], VariantSizeBarcodeGroupByOutputType[P]>
        }
      >
    >


  export type VariantSizeBarcodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    size?: boolean
    barcode?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantSizeBarcode"]>

  export type VariantSizeBarcodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    size?: boolean
    barcode?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantSizeBarcode"]>

  export type VariantSizeBarcodeSelectScalar = {
    id?: boolean
    variantId?: boolean
    size?: boolean
    barcode?: boolean
  }

  export type VariantSizeBarcodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }
  export type VariantSizeBarcodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }

  export type $VariantSizeBarcodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariantSizeBarcode"
    objects: {
      variant: Prisma.$VariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      variantId: string
      size: string | null
      barcode: string
    }, ExtArgs["result"]["variantSizeBarcode"]>
    composites: {}
  }

  type VariantSizeBarcodeGetPayload<S extends boolean | null | undefined | VariantSizeBarcodeDefaultArgs> = $Result.GetResult<Prisma.$VariantSizeBarcodePayload, S>

  type VariantSizeBarcodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VariantSizeBarcodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VariantSizeBarcodeCountAggregateInputType | true
    }

  export interface VariantSizeBarcodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariantSizeBarcode'], meta: { name: 'VariantSizeBarcode' } }
    /**
     * Find zero or one VariantSizeBarcode that matches the filter.
     * @param {VariantSizeBarcodeFindUniqueArgs} args - Arguments to find a VariantSizeBarcode
     * @example
     * // Get one VariantSizeBarcode
     * const variantSizeBarcode = await prisma.variantSizeBarcode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantSizeBarcodeFindUniqueArgs>(args: SelectSubset<T, VariantSizeBarcodeFindUniqueArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VariantSizeBarcode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VariantSizeBarcodeFindUniqueOrThrowArgs} args - Arguments to find a VariantSizeBarcode
     * @example
     * // Get one VariantSizeBarcode
     * const variantSizeBarcode = await prisma.variantSizeBarcode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantSizeBarcodeFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantSizeBarcodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VariantSizeBarcode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeFindFirstArgs} args - Arguments to find a VariantSizeBarcode
     * @example
     * // Get one VariantSizeBarcode
     * const variantSizeBarcode = await prisma.variantSizeBarcode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantSizeBarcodeFindFirstArgs>(args?: SelectSubset<T, VariantSizeBarcodeFindFirstArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VariantSizeBarcode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeFindFirstOrThrowArgs} args - Arguments to find a VariantSizeBarcode
     * @example
     * // Get one VariantSizeBarcode
     * const variantSizeBarcode = await prisma.variantSizeBarcode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantSizeBarcodeFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantSizeBarcodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VariantSizeBarcodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariantSizeBarcodes
     * const variantSizeBarcodes = await prisma.variantSizeBarcode.findMany()
     * 
     * // Get first 10 VariantSizeBarcodes
     * const variantSizeBarcodes = await prisma.variantSizeBarcode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantSizeBarcodeWithIdOnly = await prisma.variantSizeBarcode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantSizeBarcodeFindManyArgs>(args?: SelectSubset<T, VariantSizeBarcodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VariantSizeBarcode.
     * @param {VariantSizeBarcodeCreateArgs} args - Arguments to create a VariantSizeBarcode.
     * @example
     * // Create one VariantSizeBarcode
     * const VariantSizeBarcode = await prisma.variantSizeBarcode.create({
     *   data: {
     *     // ... data to create a VariantSizeBarcode
     *   }
     * })
     * 
     */
    create<T extends VariantSizeBarcodeCreateArgs>(args: SelectSubset<T, VariantSizeBarcodeCreateArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VariantSizeBarcodes.
     * @param {VariantSizeBarcodeCreateManyArgs} args - Arguments to create many VariantSizeBarcodes.
     * @example
     * // Create many VariantSizeBarcodes
     * const variantSizeBarcode = await prisma.variantSizeBarcode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantSizeBarcodeCreateManyArgs>(args?: SelectSubset<T, VariantSizeBarcodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariantSizeBarcodes and returns the data saved in the database.
     * @param {VariantSizeBarcodeCreateManyAndReturnArgs} args - Arguments to create many VariantSizeBarcodes.
     * @example
     * // Create many VariantSizeBarcodes
     * const variantSizeBarcode = await prisma.variantSizeBarcode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariantSizeBarcodes and only return the `id`
     * const variantSizeBarcodeWithIdOnly = await prisma.variantSizeBarcode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantSizeBarcodeCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantSizeBarcodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VariantSizeBarcode.
     * @param {VariantSizeBarcodeDeleteArgs} args - Arguments to delete one VariantSizeBarcode.
     * @example
     * // Delete one VariantSizeBarcode
     * const VariantSizeBarcode = await prisma.variantSizeBarcode.delete({
     *   where: {
     *     // ... filter to delete one VariantSizeBarcode
     *   }
     * })
     * 
     */
    delete<T extends VariantSizeBarcodeDeleteArgs>(args: SelectSubset<T, VariantSizeBarcodeDeleteArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VariantSizeBarcode.
     * @param {VariantSizeBarcodeUpdateArgs} args - Arguments to update one VariantSizeBarcode.
     * @example
     * // Update one VariantSizeBarcode
     * const variantSizeBarcode = await prisma.variantSizeBarcode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantSizeBarcodeUpdateArgs>(args: SelectSubset<T, VariantSizeBarcodeUpdateArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VariantSizeBarcodes.
     * @param {VariantSizeBarcodeDeleteManyArgs} args - Arguments to filter VariantSizeBarcodes to delete.
     * @example
     * // Delete a few VariantSizeBarcodes
     * const { count } = await prisma.variantSizeBarcode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantSizeBarcodeDeleteManyArgs>(args?: SelectSubset<T, VariantSizeBarcodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariantSizeBarcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariantSizeBarcodes
     * const variantSizeBarcode = await prisma.variantSizeBarcode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantSizeBarcodeUpdateManyArgs>(args: SelectSubset<T, VariantSizeBarcodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VariantSizeBarcode.
     * @param {VariantSizeBarcodeUpsertArgs} args - Arguments to update or create a VariantSizeBarcode.
     * @example
     * // Update or create a VariantSizeBarcode
     * const variantSizeBarcode = await prisma.variantSizeBarcode.upsert({
     *   create: {
     *     // ... data to create a VariantSizeBarcode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariantSizeBarcode we want to update
     *   }
     * })
     */
    upsert<T extends VariantSizeBarcodeUpsertArgs>(args: SelectSubset<T, VariantSizeBarcodeUpsertArgs<ExtArgs>>): Prisma__VariantSizeBarcodeClient<$Result.GetResult<Prisma.$VariantSizeBarcodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VariantSizeBarcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeCountArgs} args - Arguments to filter VariantSizeBarcodes to count.
     * @example
     * // Count the number of VariantSizeBarcodes
     * const count = await prisma.variantSizeBarcode.count({
     *   where: {
     *     // ... the filter for the VariantSizeBarcodes we want to count
     *   }
     * })
    **/
    count<T extends VariantSizeBarcodeCountArgs>(
      args?: Subset<T, VariantSizeBarcodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantSizeBarcodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariantSizeBarcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantSizeBarcodeAggregateArgs>(args: Subset<T, VariantSizeBarcodeAggregateArgs>): Prisma.PrismaPromise<GetVariantSizeBarcodeAggregateType<T>>

    /**
     * Group by VariantSizeBarcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantSizeBarcodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantSizeBarcodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantSizeBarcodeGroupByArgs['orderBy'] }
        : { orderBy?: VariantSizeBarcodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantSizeBarcodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantSizeBarcodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariantSizeBarcode model
   */
  readonly fields: VariantSizeBarcodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariantSizeBarcode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantSizeBarcodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends VariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariantDefaultArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariantSizeBarcode model
   */ 
  interface VariantSizeBarcodeFieldRefs {
    readonly id: FieldRef<"VariantSizeBarcode", 'Int'>
    readonly variantId: FieldRef<"VariantSizeBarcode", 'String'>
    readonly size: FieldRef<"VariantSizeBarcode", 'String'>
    readonly barcode: FieldRef<"VariantSizeBarcode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VariantSizeBarcode findUnique
   */
  export type VariantSizeBarcodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * Filter, which VariantSizeBarcode to fetch.
     */
    where: VariantSizeBarcodeWhereUniqueInput
  }

  /**
   * VariantSizeBarcode findUniqueOrThrow
   */
  export type VariantSizeBarcodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * Filter, which VariantSizeBarcode to fetch.
     */
    where: VariantSizeBarcodeWhereUniqueInput
  }

  /**
   * VariantSizeBarcode findFirst
   */
  export type VariantSizeBarcodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * Filter, which VariantSizeBarcode to fetch.
     */
    where?: VariantSizeBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantSizeBarcodes to fetch.
     */
    orderBy?: VariantSizeBarcodeOrderByWithRelationInput | VariantSizeBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariantSizeBarcodes.
     */
    cursor?: VariantSizeBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantSizeBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantSizeBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariantSizeBarcodes.
     */
    distinct?: VariantSizeBarcodeScalarFieldEnum | VariantSizeBarcodeScalarFieldEnum[]
  }

  /**
   * VariantSizeBarcode findFirstOrThrow
   */
  export type VariantSizeBarcodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * Filter, which VariantSizeBarcode to fetch.
     */
    where?: VariantSizeBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantSizeBarcodes to fetch.
     */
    orderBy?: VariantSizeBarcodeOrderByWithRelationInput | VariantSizeBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariantSizeBarcodes.
     */
    cursor?: VariantSizeBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantSizeBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantSizeBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariantSizeBarcodes.
     */
    distinct?: VariantSizeBarcodeScalarFieldEnum | VariantSizeBarcodeScalarFieldEnum[]
  }

  /**
   * VariantSizeBarcode findMany
   */
  export type VariantSizeBarcodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * Filter, which VariantSizeBarcodes to fetch.
     */
    where?: VariantSizeBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantSizeBarcodes to fetch.
     */
    orderBy?: VariantSizeBarcodeOrderByWithRelationInput | VariantSizeBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariantSizeBarcodes.
     */
    cursor?: VariantSizeBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantSizeBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantSizeBarcodes.
     */
    skip?: number
    distinct?: VariantSizeBarcodeScalarFieldEnum | VariantSizeBarcodeScalarFieldEnum[]
  }

  /**
   * VariantSizeBarcode create
   */
  export type VariantSizeBarcodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * The data needed to create a VariantSizeBarcode.
     */
    data: XOR<VariantSizeBarcodeCreateInput, VariantSizeBarcodeUncheckedCreateInput>
  }

  /**
   * VariantSizeBarcode createMany
   */
  export type VariantSizeBarcodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariantSizeBarcodes.
     */
    data: VariantSizeBarcodeCreateManyInput | VariantSizeBarcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariantSizeBarcode createManyAndReturn
   */
  export type VariantSizeBarcodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VariantSizeBarcodes.
     */
    data: VariantSizeBarcodeCreateManyInput | VariantSizeBarcodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariantSizeBarcode update
   */
  export type VariantSizeBarcodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * The data needed to update a VariantSizeBarcode.
     */
    data: XOR<VariantSizeBarcodeUpdateInput, VariantSizeBarcodeUncheckedUpdateInput>
    /**
     * Choose, which VariantSizeBarcode to update.
     */
    where: VariantSizeBarcodeWhereUniqueInput
  }

  /**
   * VariantSizeBarcode updateMany
   */
  export type VariantSizeBarcodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariantSizeBarcodes.
     */
    data: XOR<VariantSizeBarcodeUpdateManyMutationInput, VariantSizeBarcodeUncheckedUpdateManyInput>
    /**
     * Filter which VariantSizeBarcodes to update
     */
    where?: VariantSizeBarcodeWhereInput
  }

  /**
   * VariantSizeBarcode upsert
   */
  export type VariantSizeBarcodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * The filter to search for the VariantSizeBarcode to update in case it exists.
     */
    where: VariantSizeBarcodeWhereUniqueInput
    /**
     * In case the VariantSizeBarcode found by the `where` argument doesn't exist, create a new VariantSizeBarcode with this data.
     */
    create: XOR<VariantSizeBarcodeCreateInput, VariantSizeBarcodeUncheckedCreateInput>
    /**
     * In case the VariantSizeBarcode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantSizeBarcodeUpdateInput, VariantSizeBarcodeUncheckedUpdateInput>
  }

  /**
   * VariantSizeBarcode delete
   */
  export type VariantSizeBarcodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
    /**
     * Filter which VariantSizeBarcode to delete.
     */
    where: VariantSizeBarcodeWhereUniqueInput
  }

  /**
   * VariantSizeBarcode deleteMany
   */
  export type VariantSizeBarcodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariantSizeBarcodes to delete
     */
    where?: VariantSizeBarcodeWhereInput
  }

  /**
   * VariantSizeBarcode without action
   */
  export type VariantSizeBarcodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantSizeBarcode
     */
    select?: VariantSizeBarcodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantSizeBarcodeInclude<ExtArgs> | null
  }


  /**
   * Model EmailOtp
   */

  export type AggregateEmailOtp = {
    _count: EmailOtpCountAggregateOutputType | null
    _min: EmailOtpMinAggregateOutputType | null
    _max: EmailOtpMaxAggregateOutputType | null
  }

  export type EmailOtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    expiresAt: Date | null
  }

  export type EmailOtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    expiresAt: Date | null
  }

  export type EmailOtpCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    expiresAt: number
    _all: number
  }


  export type EmailOtpMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
  }

  export type EmailOtpMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
  }

  export type EmailOtpCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
    _all?: true
  }

  export type EmailOtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailOtp to aggregate.
     */
    where?: EmailOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOtps to fetch.
     */
    orderBy?: EmailOtpOrderByWithRelationInput | EmailOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailOtps
    **/
    _count?: true | EmailOtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailOtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailOtpMaxAggregateInputType
  }

  export type GetEmailOtpAggregateType<T extends EmailOtpAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailOtp[P]>
      : GetScalarType<T[P], AggregateEmailOtp[P]>
  }




  export type EmailOtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailOtpWhereInput
    orderBy?: EmailOtpOrderByWithAggregationInput | EmailOtpOrderByWithAggregationInput[]
    by: EmailOtpScalarFieldEnum[] | EmailOtpScalarFieldEnum
    having?: EmailOtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailOtpCountAggregateInputType | true
    _min?: EmailOtpMinAggregateInputType
    _max?: EmailOtpMaxAggregateInputType
  }

  export type EmailOtpGroupByOutputType = {
    id: string
    email: string
    otp: string
    expiresAt: Date
    _count: EmailOtpCountAggregateOutputType | null
    _min: EmailOtpMinAggregateOutputType | null
    _max: EmailOtpMaxAggregateOutputType | null
  }

  type GetEmailOtpGroupByPayload<T extends EmailOtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailOtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailOtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailOtpGroupByOutputType[P]>
            : GetScalarType<T[P], EmailOtpGroupByOutputType[P]>
        }
      >
    >


  export type EmailOtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["emailOtp"]>

  export type EmailOtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["emailOtp"]>

  export type EmailOtpSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }


  export type $EmailOtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailOtp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp: string
      expiresAt: Date
    }, ExtArgs["result"]["emailOtp"]>
    composites: {}
  }

  type EmailOtpGetPayload<S extends boolean | null | undefined | EmailOtpDefaultArgs> = $Result.GetResult<Prisma.$EmailOtpPayload, S>

  type EmailOtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailOtpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailOtpCountAggregateInputType | true
    }

  export interface EmailOtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailOtp'], meta: { name: 'EmailOtp' } }
    /**
     * Find zero or one EmailOtp that matches the filter.
     * @param {EmailOtpFindUniqueArgs} args - Arguments to find a EmailOtp
     * @example
     * // Get one EmailOtp
     * const emailOtp = await prisma.emailOtp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailOtpFindUniqueArgs>(args: SelectSubset<T, EmailOtpFindUniqueArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailOtp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailOtpFindUniqueOrThrowArgs} args - Arguments to find a EmailOtp
     * @example
     * // Get one EmailOtp
     * const emailOtp = await prisma.emailOtp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailOtpFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailOtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailOtp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpFindFirstArgs} args - Arguments to find a EmailOtp
     * @example
     * // Get one EmailOtp
     * const emailOtp = await prisma.emailOtp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailOtpFindFirstArgs>(args?: SelectSubset<T, EmailOtpFindFirstArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailOtp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpFindFirstOrThrowArgs} args - Arguments to find a EmailOtp
     * @example
     * // Get one EmailOtp
     * const emailOtp = await prisma.emailOtp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailOtpFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailOtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailOtps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailOtps
     * const emailOtps = await prisma.emailOtp.findMany()
     * 
     * // Get first 10 EmailOtps
     * const emailOtps = await prisma.emailOtp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailOtpWithIdOnly = await prisma.emailOtp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailOtpFindManyArgs>(args?: SelectSubset<T, EmailOtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailOtp.
     * @param {EmailOtpCreateArgs} args - Arguments to create a EmailOtp.
     * @example
     * // Create one EmailOtp
     * const EmailOtp = await prisma.emailOtp.create({
     *   data: {
     *     // ... data to create a EmailOtp
     *   }
     * })
     * 
     */
    create<T extends EmailOtpCreateArgs>(args: SelectSubset<T, EmailOtpCreateArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailOtps.
     * @param {EmailOtpCreateManyArgs} args - Arguments to create many EmailOtps.
     * @example
     * // Create many EmailOtps
     * const emailOtp = await prisma.emailOtp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailOtpCreateManyArgs>(args?: SelectSubset<T, EmailOtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailOtps and returns the data saved in the database.
     * @param {EmailOtpCreateManyAndReturnArgs} args - Arguments to create many EmailOtps.
     * @example
     * // Create many EmailOtps
     * const emailOtp = await prisma.emailOtp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailOtps and only return the `id`
     * const emailOtpWithIdOnly = await prisma.emailOtp.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailOtpCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailOtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailOtp.
     * @param {EmailOtpDeleteArgs} args - Arguments to delete one EmailOtp.
     * @example
     * // Delete one EmailOtp
     * const EmailOtp = await prisma.emailOtp.delete({
     *   where: {
     *     // ... filter to delete one EmailOtp
     *   }
     * })
     * 
     */
    delete<T extends EmailOtpDeleteArgs>(args: SelectSubset<T, EmailOtpDeleteArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailOtp.
     * @param {EmailOtpUpdateArgs} args - Arguments to update one EmailOtp.
     * @example
     * // Update one EmailOtp
     * const emailOtp = await prisma.emailOtp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailOtpUpdateArgs>(args: SelectSubset<T, EmailOtpUpdateArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailOtps.
     * @param {EmailOtpDeleteManyArgs} args - Arguments to filter EmailOtps to delete.
     * @example
     * // Delete a few EmailOtps
     * const { count } = await prisma.emailOtp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailOtpDeleteManyArgs>(args?: SelectSubset<T, EmailOtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailOtps
     * const emailOtp = await prisma.emailOtp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailOtpUpdateManyArgs>(args: SelectSubset<T, EmailOtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailOtp.
     * @param {EmailOtpUpsertArgs} args - Arguments to update or create a EmailOtp.
     * @example
     * // Update or create a EmailOtp
     * const emailOtp = await prisma.emailOtp.upsert({
     *   create: {
     *     // ... data to create a EmailOtp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailOtp we want to update
     *   }
     * })
     */
    upsert<T extends EmailOtpUpsertArgs>(args: SelectSubset<T, EmailOtpUpsertArgs<ExtArgs>>): Prisma__EmailOtpClient<$Result.GetResult<Prisma.$EmailOtpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpCountArgs} args - Arguments to filter EmailOtps to count.
     * @example
     * // Count the number of EmailOtps
     * const count = await prisma.emailOtp.count({
     *   where: {
     *     // ... the filter for the EmailOtps we want to count
     *   }
     * })
    **/
    count<T extends EmailOtpCountArgs>(
      args?: Subset<T, EmailOtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailOtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailOtpAggregateArgs>(args: Subset<T, EmailOtpAggregateArgs>): Prisma.PrismaPromise<GetEmailOtpAggregateType<T>>

    /**
     * Group by EmailOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailOtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailOtpGroupByArgs['orderBy'] }
        : { orderBy?: EmailOtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailOtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailOtp model
   */
  readonly fields: EmailOtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailOtp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailOtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailOtp model
   */ 
  interface EmailOtpFieldRefs {
    readonly id: FieldRef<"EmailOtp", 'String'>
    readonly email: FieldRef<"EmailOtp", 'String'>
    readonly otp: FieldRef<"EmailOtp", 'String'>
    readonly expiresAt: FieldRef<"EmailOtp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailOtp findUnique
   */
  export type EmailOtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * Filter, which EmailOtp to fetch.
     */
    where: EmailOtpWhereUniqueInput
  }

  /**
   * EmailOtp findUniqueOrThrow
   */
  export type EmailOtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * Filter, which EmailOtp to fetch.
     */
    where: EmailOtpWhereUniqueInput
  }

  /**
   * EmailOtp findFirst
   */
  export type EmailOtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * Filter, which EmailOtp to fetch.
     */
    where?: EmailOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOtps to fetch.
     */
    orderBy?: EmailOtpOrderByWithRelationInput | EmailOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailOtps.
     */
    cursor?: EmailOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailOtps.
     */
    distinct?: EmailOtpScalarFieldEnum | EmailOtpScalarFieldEnum[]
  }

  /**
   * EmailOtp findFirstOrThrow
   */
  export type EmailOtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * Filter, which EmailOtp to fetch.
     */
    where?: EmailOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOtps to fetch.
     */
    orderBy?: EmailOtpOrderByWithRelationInput | EmailOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailOtps.
     */
    cursor?: EmailOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailOtps.
     */
    distinct?: EmailOtpScalarFieldEnum | EmailOtpScalarFieldEnum[]
  }

  /**
   * EmailOtp findMany
   */
  export type EmailOtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * Filter, which EmailOtps to fetch.
     */
    where?: EmailOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOtps to fetch.
     */
    orderBy?: EmailOtpOrderByWithRelationInput | EmailOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailOtps.
     */
    cursor?: EmailOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOtps.
     */
    skip?: number
    distinct?: EmailOtpScalarFieldEnum | EmailOtpScalarFieldEnum[]
  }

  /**
   * EmailOtp create
   */
  export type EmailOtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailOtp.
     */
    data: XOR<EmailOtpCreateInput, EmailOtpUncheckedCreateInput>
  }

  /**
   * EmailOtp createMany
   */
  export type EmailOtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailOtps.
     */
    data: EmailOtpCreateManyInput | EmailOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailOtp createManyAndReturn
   */
  export type EmailOtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailOtps.
     */
    data: EmailOtpCreateManyInput | EmailOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailOtp update
   */
  export type EmailOtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailOtp.
     */
    data: XOR<EmailOtpUpdateInput, EmailOtpUncheckedUpdateInput>
    /**
     * Choose, which EmailOtp to update.
     */
    where: EmailOtpWhereUniqueInput
  }

  /**
   * EmailOtp updateMany
   */
  export type EmailOtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailOtps.
     */
    data: XOR<EmailOtpUpdateManyMutationInput, EmailOtpUncheckedUpdateManyInput>
    /**
     * Filter which EmailOtps to update
     */
    where?: EmailOtpWhereInput
  }

  /**
   * EmailOtp upsert
   */
  export type EmailOtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailOtp to update in case it exists.
     */
    where: EmailOtpWhereUniqueInput
    /**
     * In case the EmailOtp found by the `where` argument doesn't exist, create a new EmailOtp with this data.
     */
    create: XOR<EmailOtpCreateInput, EmailOtpUncheckedCreateInput>
    /**
     * In case the EmailOtp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailOtpUpdateInput, EmailOtpUncheckedUpdateInput>
  }

  /**
   * EmailOtp delete
   */
  export type EmailOtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
    /**
     * Filter which EmailOtp to delete.
     */
    where: EmailOtpWhereUniqueInput
  }

  /**
   * EmailOtp deleteMany
   */
  export type EmailOtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailOtps to delete
     */
    where?: EmailOtpWhereInput
  }

  /**
   * EmailOtp without action
   */
  export type EmailOtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOtp
     */
    select?: EmailOtpSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    clientId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    clientId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    clientId: number
    type: number
    title: number
    message: number
    read: number
    actionPath: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    clientId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    clientId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    clientId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionPath?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    companyId: string
    userId: string | null
    clientId: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read: boolean
    actionPath: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    clientId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionPath?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
    client?: boolean | Notification$clientArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    clientId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionPath?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
    client?: boolean | Notification$clientArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    clientId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionPath?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
    client?: boolean | Notification$clientArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
    client?: boolean | Notification$clientArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      userId: string | null
      clientId: string | null
      type: $Enums.NotificationType
      title: string
      message: string
      read: boolean
      actionPath: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends Notification$clientArgs<ExtArgs> = {}>(args?: Subset<T, Notification$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly companyId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly clientId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionPath: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification.client
   */
  export type Notification$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    storecode: 'storecode',
    storeUniqueName: 'storeUniqueName',
    logo: 'logo',
    description: 'description',
    shopifyStoreName: 'shopifyStoreName',
    shopifyAccessToken: 'shopifyAccessToken',
    tiktokCipher: 'tiktokCipher',
    tiktokStoreName: 'tiktokStoreName',
    tiktokAccessToken: 'tiktokAccessToken',
    tiktokAccessTokenExpireIn: 'tiktokAccessTokenExpireIn',
    tiktokRefreshToken: 'tiktokRefreshToken',
    tiktokRefreshTokenExpireIn: 'tiktokRefreshTokenExpireIn',
    images: 'images',
    isTaxIncluded: 'isTaxIncluded',
    status: 'status',
    type: 'type',
    accHolderName: 'accHolderName',
    ifsc: 'ifsc',
    accountNo: 'accountNo',
    bankName: 'bankName',
    gstin: 'gstin',
    upiId: 'upiId',
    billCounter: 'billCounter',
    barcodeCounter: 'barcodeCounter'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const DistributorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    images: 'images',
    status: 'status',
    accHolderName: 'accHolderName',
    ifsc: 'ifsc',
    accountNo: 'accountNo',
    bankName: 'bankName',
    gstin: 'gstin'
  };

  export type DistributorScalarFieldEnum = (typeof DistributorScalarFieldEnum)[keyof typeof DistributorScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    status: 'status',
    role: 'role',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    phone: 'phone',
    status: 'status',
    pipelineStatus: 'pipelineStatus',
    newPipelineId: 'newPipelineId',
    prospectPipelineId: 'prospectPipelineId',
    viewingPipelineId: 'viewingPipelineId',
    rejectPipelineId: 'rejectPipelineId',
    closePipelineId: 'closePipelineId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const PipelineScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId'
  };

  export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    status: 'status',
    image: 'image',
    companyId: 'companyId',
    hsn: 'hsn',
    taxType: 'taxType',
    fixedTax: 'fixedTax',
    thresholdAmount: 'thresholdAmount',
    taxBelowThreshold: 'taxBelowThreshold',
    taxAboveThreshold: 'taxAboveThreshold'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubcategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    status: 'status',
    image: 'image',
    companyId: 'companyId',
    categoryId: 'categoryId'
  };

  export type SubcategoryScalarFieldEnum = (typeof SubcategoryScalarFieldEnum)[keyof typeof SubcategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    brand: 'brand',
    status: 'status',
    rating: 'rating',
    description: 'description',
    companyId: 'companyId',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    purchaseorderId: 'purchaseorderId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const VariantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    code: 'code',
    status: 'status',
    sprice: 'sprice',
    pprice: 'pprice',
    qty: 'qty',
    discount: 'discount',
    dprice: 'dprice',
    sizes: 'sizes',
    images: 'images',
    tax: 'tax',
    productId: 'productId',
    companyId: 'companyId'
  };

  export type VariantScalarFieldEnum = (typeof VariantScalarFieldEnum)[keyof typeof VariantScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    barcode: 'barcode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    variantId: 'variantId',
    status: 'status',
    size: 'size',
    companyId: 'companyId'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    distributorId: 'distributorId',
    paymentType: 'paymentType',
    companyId: 'companyId'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    invoiceNumber: 'invoiceNumber',
    subtotal: 'subtotal',
    discount: 'discount',
    tax: 'tax',
    grandTotal: 'grandTotal',
    deliveryFees: 'deliveryFees',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    transactionId: 'transactionId',
    notes: 'notes',
    type: 'type',
    status: 'status',
    deleted: 'deleted',
    bookingDate: 'bookingDate',
    returnDeadline: 'returnDeadline',
    companyId: 'companyId',
    accountId: 'accountId',
    clientId: 'clientId',
    addressId: 'addressId'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const TokenEntryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    tokenNo: 'tokenNo',
    companyId: 'companyId',
    itemId: 'itemId',
    variantId: 'variantId',
    barcode: 'barcode',
    categoryId: 'categoryId',
    size: 'size',
    name: 'name',
    qty: 'qty',
    rate: 'rate',
    discount: 'discount',
    tax: 'tax',
    value: 'value',
    sizes: 'sizes',
    totalQty: 'totalQty'
  };

  export type TokenEntryScalarFieldEnum = (typeof TokenEntryScalarFieldEnum)[keyof typeof TokenEntryScalarFieldEnum]


  export const EntryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode',
    qty: 'qty',
    rate: 'rate',
    discount: 'discount',
    tax: 'tax',
    value: 'value',
    size: 'size',
    variantId: 'variantId',
    outOfStock: 'outOfStock',
    categoryId: 'categoryId',
    billId: 'billId',
    itemId: 'itemId'
  };

  export type EntryScalarFieldEnum = (typeof EntryScalarFieldEnum)[keyof typeof EntryScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    companyId: 'companyId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    expenseDate: 'expenseDate',
    note: 'note',
    currency: 'currency',
    paymentMode: 'paymentMode',
    status: 'status',
    receipt: 'receipt',
    receiptName: 'receiptName',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expensecategoryId: 'expensecategoryId',
    companyId: 'companyId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentDate: 'paymentDate',
    paymentMode: 'paymentMode',
    paymentReference: 'paymentReference',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    street: 'street',
    locality: 'locality',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    active: 'active',
    userId: 'userId',
    clientId: 'clientId',
    distributorId: 'distributorId',
    companyId: 'companyId',
    accountId: 'accountId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    conversationId: 'conversationId',
    senderId: 'senderId',
    text: 'text',
    seen: 'seen',
    replyto: 'replyto',
    edited: 'edited',
    deleted: 'deleted'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const CompanyUserScalarFieldEnum: {
    companyId: 'companyId',
    userId: 'userId'
  };

  export type CompanyUserScalarFieldEnum = (typeof CompanyUserScalarFieldEnum)[keyof typeof CompanyUserScalarFieldEnum]


  export const CompanyClientScalarFieldEnum: {
    companyId: 'companyId',
    clientId: 'clientId'
  };

  export type CompanyClientScalarFieldEnum = (typeof CompanyClientScalarFieldEnum)[keyof typeof CompanyClientScalarFieldEnum]


  export const UserConversationScalarFieldEnum: {
    userId: 'userId',
    conversationId: 'conversationId'
  };

  export type UserConversationScalarFieldEnum = (typeof UserConversationScalarFieldEnum)[keyof typeof UserConversationScalarFieldEnum]


  export const ClientConversationScalarFieldEnum: {
    clientId: 'clientId',
    conversationId: 'conversationId'
  };

  export type ClientConversationScalarFieldEnum = (typeof ClientConversationScalarFieldEnum)[keyof typeof ClientConversationScalarFieldEnum]


  export const UserClientScalarFieldEnum: {
    clientId: 'clientId',
    userId: 'userId'
  };

  export type UserClientScalarFieldEnum = (typeof UserClientScalarFieldEnum)[keyof typeof UserClientScalarFieldEnum]


  export const DistributorCompanyScalarFieldEnum: {
    distributorId: 'distributorId',
    companyId: 'companyId'
  };

  export type DistributorCompanyScalarFieldEnum = (typeof DistributorCompanyScalarFieldEnum)[keyof typeof DistributorCompanyScalarFieldEnum]


  export const VariantSizeBarcodeScalarFieldEnum: {
    id: 'id',
    variantId: 'variantId',
    size: 'size',
    barcode: 'barcode'
  };

  export type VariantSizeBarcodeScalarFieldEnum = (typeof VariantSizeBarcodeScalarFieldEnum)[keyof typeof VariantSizeBarcodeScalarFieldEnum]


  export const EmailOtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    expiresAt: 'expiresAt'
  };

  export type EmailOtpScalarFieldEnum = (typeof EmailOtpScalarFieldEnum)[keyof typeof EmailOtpScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    clientId: 'clientId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    actionPath: 'actionPath',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CompanyType'
   */
  export type EnumCompanyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyType'>
    


  /**
   * Reference to a field of type 'CompanyType[]'
   */
  export type ListEnumCompanyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyType[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TaxType'
   */
  export type EnumTaxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxType'>
    


  /**
   * Reference to a field of type 'TaxType[]'
   */
  export type ListEnumTaxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'paymentType'
   */
  export type EnumpaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'paymentType'>
    


  /**
   * Reference to a field of type 'paymentType[]'
   */
  export type ListEnumpaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'paymentType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'OrderType'
   */
  export type EnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType'>
    


  /**
   * Reference to a field of type 'OrderType[]'
   */
  export type ListEnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMode'
   */
  export type EnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode'>
    


  /**
   * Reference to a field of type 'PaymentMode[]'
   */
  export type ListEnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    storecode?: IntFilter<"Company"> | number
    storeUniqueName?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    description?: StringNullableFilter<"Company"> | string | null
    shopifyStoreName?: StringNullableFilter<"Company"> | string | null
    shopifyAccessToken?: StringNullableFilter<"Company"> | string | null
    tiktokCipher?: StringNullableFilter<"Company"> | string | null
    tiktokStoreName?: StringNullableFilter<"Company"> | string | null
    tiktokAccessToken?: StringNullableFilter<"Company"> | string | null
    tiktokAccessTokenExpireIn?: IntNullableFilter<"Company"> | number | null
    tiktokRefreshToken?: StringNullableFilter<"Company"> | string | null
    tiktokRefreshTokenExpireIn?: IntNullableFilter<"Company"> | number | null
    images?: StringNullableFilter<"Company"> | string | null
    isTaxIncluded?: BoolFilter<"Company"> | boolean
    status?: BoolFilter<"Company"> | boolean
    type?: EnumCompanyTypeFilter<"Company"> | $Enums.CompanyType
    accHolderName?: StringNullableFilter<"Company"> | string | null
    ifsc?: StringNullableFilter<"Company"> | string | null
    accountNo?: StringNullableFilter<"Company"> | string | null
    bankName?: StringNullableFilter<"Company"> | string | null
    gstin?: StringNullableFilter<"Company"> | string | null
    upiId?: StringNullableFilter<"Company"> | string | null
    billCounter?: IntFilter<"Company"> | number
    barcodeCounter?: IntFilter<"Company"> | number
    users?: CompanyUserListRelationFilter
    clients?: CompanyClientListRelationFilter
    products?: ProductListRelationFilter
    categories?: CategoryListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    bills?: BillListRelationFilter
    tokenbills?: TokenEntryListRelationFilter
    accounts?: AccountListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    expenses?: ExpenseListRelationFilter
    payment?: PaymentListRelationFilter
    variants?: VariantListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    items?: ItemListRelationFilter
    pipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    notifications?: NotificationListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    distributor?: DistributorCompanyListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    storecode?: SortOrder
    storeUniqueName?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    shopifyStoreName?: SortOrderInput | SortOrder
    shopifyAccessToken?: SortOrderInput | SortOrder
    tiktokCipher?: SortOrderInput | SortOrder
    tiktokStoreName?: SortOrderInput | SortOrder
    tiktokAccessToken?: SortOrderInput | SortOrder
    tiktokAccessTokenExpireIn?: SortOrderInput | SortOrder
    tiktokRefreshToken?: SortOrderInput | SortOrder
    tiktokRefreshTokenExpireIn?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    isTaxIncluded?: SortOrder
    status?: SortOrder
    type?: SortOrder
    accHolderName?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    accountNo?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
    users?: CompanyUserOrderByRelationAggregateInput
    clients?: CompanyClientOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    subcategories?: SubcategoryOrderByRelationAggregateInput
    bills?: BillOrderByRelationAggregateInput
    tokenbills?: TokenEntryOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    expenseCategories?: ExpenseCategoryOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    payment?: PaymentOrderByRelationAggregateInput
    variants?: VariantOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    pipeline?: PipelineOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    address?: AddressOrderByWithRelationInput
    distributor?: DistributorCompanyOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storecode?: number
    storeUniqueName?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    logo?: StringNullableFilter<"Company"> | string | null
    description?: StringNullableFilter<"Company"> | string | null
    shopifyStoreName?: StringNullableFilter<"Company"> | string | null
    shopifyAccessToken?: StringNullableFilter<"Company"> | string | null
    tiktokCipher?: StringNullableFilter<"Company"> | string | null
    tiktokStoreName?: StringNullableFilter<"Company"> | string | null
    tiktokAccessToken?: StringNullableFilter<"Company"> | string | null
    tiktokAccessTokenExpireIn?: IntNullableFilter<"Company"> | number | null
    tiktokRefreshToken?: StringNullableFilter<"Company"> | string | null
    tiktokRefreshTokenExpireIn?: IntNullableFilter<"Company"> | number | null
    images?: StringNullableFilter<"Company"> | string | null
    isTaxIncluded?: BoolFilter<"Company"> | boolean
    status?: BoolFilter<"Company"> | boolean
    type?: EnumCompanyTypeFilter<"Company"> | $Enums.CompanyType
    accHolderName?: StringNullableFilter<"Company"> | string | null
    ifsc?: StringNullableFilter<"Company"> | string | null
    accountNo?: StringNullableFilter<"Company"> | string | null
    bankName?: StringNullableFilter<"Company"> | string | null
    gstin?: StringNullableFilter<"Company"> | string | null
    upiId?: StringNullableFilter<"Company"> | string | null
    billCounter?: IntFilter<"Company"> | number
    barcodeCounter?: IntFilter<"Company"> | number
    users?: CompanyUserListRelationFilter
    clients?: CompanyClientListRelationFilter
    products?: ProductListRelationFilter
    categories?: CategoryListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    bills?: BillListRelationFilter
    tokenbills?: TokenEntryListRelationFilter
    accounts?: AccountListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    expenses?: ExpenseListRelationFilter
    payment?: PaymentListRelationFilter
    variants?: VariantListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    items?: ItemListRelationFilter
    pipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    notifications?: NotificationListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    distributor?: DistributorCompanyListRelationFilter
  }, "id" | "id" | "storecode" | "storeUniqueName">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    storecode?: SortOrder
    storeUniqueName?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    shopifyStoreName?: SortOrderInput | SortOrder
    shopifyAccessToken?: SortOrderInput | SortOrder
    tiktokCipher?: SortOrderInput | SortOrder
    tiktokStoreName?: SortOrderInput | SortOrder
    tiktokAccessToken?: SortOrderInput | SortOrder
    tiktokAccessTokenExpireIn?: SortOrderInput | SortOrder
    tiktokRefreshToken?: SortOrderInput | SortOrder
    tiktokRefreshTokenExpireIn?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    isTaxIncluded?: SortOrder
    status?: SortOrder
    type?: SortOrder
    accHolderName?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    accountNo?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    storecode?: IntWithAggregatesFilter<"Company"> | number
    storeUniqueName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    description?: StringNullableWithAggregatesFilter<"Company"> | string | null
    shopifyStoreName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    shopifyAccessToken?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tiktokCipher?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tiktokStoreName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tiktokAccessToken?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tiktokAccessTokenExpireIn?: IntNullableWithAggregatesFilter<"Company"> | number | null
    tiktokRefreshToken?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tiktokRefreshTokenExpireIn?: IntNullableWithAggregatesFilter<"Company"> | number | null
    images?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isTaxIncluded?: BoolWithAggregatesFilter<"Company"> | boolean
    status?: BoolWithAggregatesFilter<"Company"> | boolean
    type?: EnumCompanyTypeWithAggregatesFilter<"Company"> | $Enums.CompanyType
    accHolderName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    ifsc?: StringNullableWithAggregatesFilter<"Company"> | string | null
    accountNo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"Company"> | string | null
    upiId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    billCounter?: IntWithAggregatesFilter<"Company"> | number
    barcodeCounter?: IntWithAggregatesFilter<"Company"> | number
  }

  export type DistributorWhereInput = {
    AND?: DistributorWhereInput | DistributorWhereInput[]
    OR?: DistributorWhereInput[]
    NOT?: DistributorWhereInput | DistributorWhereInput[]
    id?: StringFilter<"Distributor"> | string
    name?: StringFilter<"Distributor"> | string
    images?: StringNullableFilter<"Distributor"> | string | null
    status?: BoolFilter<"Distributor"> | boolean
    accHolderName?: StringNullableFilter<"Distributor"> | string | null
    ifsc?: StringNullableFilter<"Distributor"> | string | null
    accountNo?: StringNullableFilter<"Distributor"> | string | null
    bankName?: StringNullableFilter<"Distributor"> | string | null
    gstin?: StringNullableFilter<"Distributor"> | string | null
    companies?: DistributorCompanyListRelationFilter
    purchaseorders?: PurchaseOrderListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
  }

  export type DistributorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrderInput | SortOrder
    status?: SortOrder
    accHolderName?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    accountNo?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    companies?: DistributorCompanyOrderByRelationAggregateInput
    purchaseorders?: PurchaseOrderOrderByRelationAggregateInput
    address?: AddressOrderByWithRelationInput
  }

  export type DistributorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DistributorWhereInput | DistributorWhereInput[]
    OR?: DistributorWhereInput[]
    NOT?: DistributorWhereInput | DistributorWhereInput[]
    name?: StringFilter<"Distributor"> | string
    images?: StringNullableFilter<"Distributor"> | string | null
    status?: BoolFilter<"Distributor"> | boolean
    accHolderName?: StringNullableFilter<"Distributor"> | string | null
    ifsc?: StringNullableFilter<"Distributor"> | string | null
    accountNo?: StringNullableFilter<"Distributor"> | string | null
    bankName?: StringNullableFilter<"Distributor"> | string | null
    gstin?: StringNullableFilter<"Distributor"> | string | null
    companies?: DistributorCompanyListRelationFilter
    purchaseorders?: PurchaseOrderListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
  }, "id" | "id">

  export type DistributorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrderInput | SortOrder
    status?: SortOrder
    accHolderName?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    accountNo?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    _count?: DistributorCountOrderByAggregateInput
    _max?: DistributorMaxOrderByAggregateInput
    _min?: DistributorMinOrderByAggregateInput
  }

  export type DistributorScalarWhereWithAggregatesInput = {
    AND?: DistributorScalarWhereWithAggregatesInput | DistributorScalarWhereWithAggregatesInput[]
    OR?: DistributorScalarWhereWithAggregatesInput[]
    NOT?: DistributorScalarWhereWithAggregatesInput | DistributorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Distributor"> | string
    name?: StringWithAggregatesFilter<"Distributor"> | string
    images?: StringNullableWithAggregatesFilter<"Distributor"> | string | null
    status?: BoolWithAggregatesFilter<"Distributor"> | boolean
    accHolderName?: StringNullableWithAggregatesFilter<"Distributor"> | string | null
    ifsc?: StringNullableWithAggregatesFilter<"Distributor"> | string | null
    accountNo?: StringNullableWithAggregatesFilter<"Distributor"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Distributor"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"Distributor"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    companies?: CompanyUserListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    notifications?: NotificationListRelationFilter
    conversations?: UserConversationListRelationFilter
    clients?: UserClientListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    companies?: CompanyUserOrderByRelationAggregateInput
    address?: AddressOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    conversations?: UserConversationOrderByRelationAggregateInput
    clients?: UserClientOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    companies?: CompanyUserListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    notifications?: NotificationListRelationFilter
    conversations?: UserConversationListRelationFilter
    clients?: UserClientListRelationFilter
  }, "id" | "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    status?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    name?: StringFilter<"Client"> | string
    password?: StringNullableFilter<"Client"> | string | null
    phone?: StringFilter<"Client"> | string
    status?: BoolFilter<"Client"> | boolean
    pipelineStatus?: StringFilter<"Client"> | string
    newPipelineId?: StringNullableFilter<"Client"> | string | null
    prospectPipelineId?: StringNullableFilter<"Client"> | string | null
    viewingPipelineId?: StringNullableFilter<"Client"> | string | null
    rejectPipelineId?: StringNullableFilter<"Client"> | string | null
    closePipelineId?: StringNullableFilter<"Client"> | string | null
    companies?: CompanyClientListRelationFilter
    address?: AddressListRelationFilter
    bill?: XOR<BillNullableRelationFilter, BillWhereInput> | null
    conversations?: ClientConversationListRelationFilter
    users?: UserClientListRelationFilter
    newPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    prospectPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    viewingPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    rejectPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    closePipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrder
    status?: SortOrder
    pipelineStatus?: SortOrder
    newPipelineId?: SortOrderInput | SortOrder
    prospectPipelineId?: SortOrderInput | SortOrder
    viewingPipelineId?: SortOrderInput | SortOrder
    rejectPipelineId?: SortOrderInput | SortOrder
    closePipelineId?: SortOrderInput | SortOrder
    companies?: CompanyClientOrderByRelationAggregateInput
    address?: AddressOrderByRelationAggregateInput
    bill?: BillOrderByWithRelationInput
    conversations?: ClientConversationOrderByRelationAggregateInput
    users?: UserClientOrderByRelationAggregateInput
    newPipeline?: PipelineOrderByWithRelationInput
    prospectPipeline?: PipelineOrderByWithRelationInput
    viewingPipeline?: PipelineOrderByWithRelationInput
    rejectPipeline?: PipelineOrderByWithRelationInput
    closePipeline?: PipelineOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    password?: StringNullableFilter<"Client"> | string | null
    status?: BoolFilter<"Client"> | boolean
    pipelineStatus?: StringFilter<"Client"> | string
    newPipelineId?: StringNullableFilter<"Client"> | string | null
    prospectPipelineId?: StringNullableFilter<"Client"> | string | null
    viewingPipelineId?: StringNullableFilter<"Client"> | string | null
    rejectPipelineId?: StringNullableFilter<"Client"> | string | null
    closePipelineId?: StringNullableFilter<"Client"> | string | null
    companies?: CompanyClientListRelationFilter
    address?: AddressListRelationFilter
    bill?: XOR<BillNullableRelationFilter, BillWhereInput> | null
    conversations?: ClientConversationListRelationFilter
    users?: UserClientListRelationFilter
    newPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    prospectPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    viewingPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    rejectPipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    closePipeline?: XOR<PipelineNullableRelationFilter, PipelineWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id" | "id" | "email" | "phone">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrder
    status?: SortOrder
    pipelineStatus?: SortOrder
    newPipelineId?: SortOrderInput | SortOrder
    prospectPipelineId?: SortOrderInput | SortOrder
    viewingPipelineId?: SortOrderInput | SortOrder
    rejectPipelineId?: SortOrderInput | SortOrder
    closePipelineId?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    name?: StringWithAggregatesFilter<"Client"> | string
    password?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringWithAggregatesFilter<"Client"> | string
    status?: BoolWithAggregatesFilter<"Client"> | boolean
    pipelineStatus?: StringWithAggregatesFilter<"Client"> | string
    newPipelineId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    prospectPipelineId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    viewingPipelineId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    rejectPipelineId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    closePipelineId?: StringNullableWithAggregatesFilter<"Client"> | string | null
  }

  export type PipelineWhereInput = {
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    companyId?: StringFilter<"Pipeline"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    newClients?: ClientListRelationFilter
    prospectClients?: ClientListRelationFilter
    viewingClients?: ClientListRelationFilter
    rejectClients?: ClientListRelationFilter
    closeClients?: ClientListRelationFilter
  }

  export type PipelineOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    newClients?: ClientOrderByRelationAggregateInput
    prospectClients?: ClientOrderByRelationAggregateInput
    viewingClients?: ClientOrderByRelationAggregateInput
    rejectClients?: ClientOrderByRelationAggregateInput
    closeClients?: ClientOrderByRelationAggregateInput
  }

  export type PipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId?: string
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    newClients?: ClientListRelationFilter
    prospectClients?: ClientListRelationFilter
    viewingClients?: ClientListRelationFilter
    rejectClients?: ClientListRelationFilter
    closeClients?: ClientListRelationFilter
  }, "id" | "id" | "companyId">

  export type PipelineOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    _count?: PipelineCountOrderByAggregateInput
    _max?: PipelineMaxOrderByAggregateInput
    _min?: PipelineMinOrderByAggregateInput
  }

  export type PipelineScalarWhereWithAggregatesInput = {
    AND?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    OR?: PipelineScalarWhereWithAggregatesInput[]
    NOT?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipeline"> | string
    companyId?: StringWithAggregatesFilter<"Pipeline"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    status?: BoolFilter<"Category"> | boolean
    image?: StringNullableFilter<"Category"> | string | null
    companyId?: StringFilter<"Category"> | string
    hsn?: StringNullableFilter<"Category"> | string | null
    taxType?: EnumTaxTypeFilter<"Category"> | $Enums.TaxType
    fixedTax?: FloatNullableFilter<"Category"> | number | null
    thresholdAmount?: FloatNullableFilter<"Category"> | number | null
    taxBelowThreshold?: FloatNullableFilter<"Category"> | number | null
    taxAboveThreshold?: FloatNullableFilter<"Category"> | number | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    products?: ProductListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    entries?: EntryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    image?: SortOrderInput | SortOrder
    companyId?: SortOrder
    hsn?: SortOrderInput | SortOrder
    taxType?: SortOrder
    fixedTax?: SortOrderInput | SortOrder
    thresholdAmount?: SortOrderInput | SortOrder
    taxBelowThreshold?: SortOrderInput | SortOrder
    taxAboveThreshold?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    subcategories?: SubcategoryOrderByRelationAggregateInput
    entries?: EntryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    status?: BoolFilter<"Category"> | boolean
    image?: StringNullableFilter<"Category"> | string | null
    companyId?: StringFilter<"Category"> | string
    hsn?: StringNullableFilter<"Category"> | string | null
    taxType?: EnumTaxTypeFilter<"Category"> | $Enums.TaxType
    fixedTax?: FloatNullableFilter<"Category"> | number | null
    thresholdAmount?: FloatNullableFilter<"Category"> | number | null
    taxBelowThreshold?: FloatNullableFilter<"Category"> | number | null
    taxAboveThreshold?: FloatNullableFilter<"Category"> | number | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    products?: ProductListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    entries?: EntryListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    image?: SortOrderInput | SortOrder
    companyId?: SortOrder
    hsn?: SortOrderInput | SortOrder
    taxType?: SortOrder
    fixedTax?: SortOrderInput | SortOrder
    thresholdAmount?: SortOrderInput | SortOrder
    taxBelowThreshold?: SortOrderInput | SortOrder
    taxAboveThreshold?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    status?: BoolWithAggregatesFilter<"Category"> | boolean
    image?: StringNullableWithAggregatesFilter<"Category"> | string | null
    companyId?: StringWithAggregatesFilter<"Category"> | string
    hsn?: StringNullableWithAggregatesFilter<"Category"> | string | null
    taxType?: EnumTaxTypeWithAggregatesFilter<"Category"> | $Enums.TaxType
    fixedTax?: FloatNullableWithAggregatesFilter<"Category"> | number | null
    thresholdAmount?: FloatNullableWithAggregatesFilter<"Category"> | number | null
    taxBelowThreshold?: FloatNullableWithAggregatesFilter<"Category"> | number | null
    taxAboveThreshold?: FloatNullableWithAggregatesFilter<"Category"> | number | null
  }

  export type SubcategoryWhereInput = {
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    createdAt?: DateTimeFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeFilter<"Subcategory"> | Date | string
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    status?: BoolFilter<"Subcategory"> | boolean
    image?: StringNullableFilter<"Subcategory"> | string | null
    companyId?: StringFilter<"Subcategory"> | string
    categoryId?: StringNullableFilter<"Subcategory"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    products?: ProductListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
  }

  export type SubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    image?: SortOrderInput | SortOrder
    companyId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
  }

  export type SubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    createdAt?: DateTimeFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeFilter<"Subcategory"> | Date | string
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    status?: BoolFilter<"Subcategory"> | boolean
    image?: StringNullableFilter<"Subcategory"> | string | null
    companyId?: StringFilter<"Subcategory"> | string
    categoryId?: StringNullableFilter<"Subcategory"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    products?: ProductListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
  }, "id">

  export type SubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    image?: SortOrderInput | SortOrder
    companyId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: SubcategoryCountOrderByAggregateInput
    _max?: SubcategoryMaxOrderByAggregateInput
    _min?: SubcategoryMinOrderByAggregateInput
  }

  export type SubcategoryScalarWhereWithAggregatesInput = {
    AND?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    OR?: SubcategoryScalarWhereWithAggregatesInput[]
    NOT?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subcategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subcategory"> | Date | string
    name?: StringWithAggregatesFilter<"Subcategory"> | string
    description?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    status?: BoolWithAggregatesFilter<"Subcategory"> | boolean
    image?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    companyId?: StringWithAggregatesFilter<"Subcategory"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    brand?: StringNullableFilter<"Product"> | string | null
    status?: BoolFilter<"Product"> | boolean
    rating?: FloatNullableFilter<"Product"> | number | null
    description?: StringNullableFilter<"Product"> | string | null
    companyId?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    subcategoryId?: StringNullableFilter<"Product"> | string | null
    purchaseorderId?: StringFilter<"Product"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    subcategory?: XOR<SubcategoryNullableRelationFilter, SubcategoryWhereInput> | null
    variants?: VariantListRelationFilter
    purchaseorder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    companyId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    purchaseorderId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    subcategory?: SubcategoryOrderByWithRelationInput
    variants?: VariantOrderByRelationAggregateInput
    purchaseorder?: PurchaseOrderOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    brand?: StringNullableFilter<"Product"> | string | null
    status?: BoolFilter<"Product"> | boolean
    rating?: FloatNullableFilter<"Product"> | number | null
    description?: StringNullableFilter<"Product"> | string | null
    companyId?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    subcategoryId?: StringNullableFilter<"Product"> | string | null
    purchaseorderId?: StringFilter<"Product"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    subcategory?: XOR<SubcategoryNullableRelationFilter, SubcategoryWhereInput> | null
    variants?: VariantListRelationFilter
    purchaseorder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    companyId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    purchaseorderId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    name?: StringWithAggregatesFilter<"Product"> | string
    brand?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status?: BoolWithAggregatesFilter<"Product"> | boolean
    rating?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    companyId?: StringWithAggregatesFilter<"Product"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    subcategoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    purchaseorderId?: StringWithAggregatesFilter<"Product"> | string
  }

  export type VariantWhereInput = {
    AND?: VariantWhereInput | VariantWhereInput[]
    OR?: VariantWhereInput[]
    NOT?: VariantWhereInput | VariantWhereInput[]
    id?: StringFilter<"Variant"> | string
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    name?: StringFilter<"Variant"> | string
    code?: StringNullableFilter<"Variant"> | string | null
    status?: BoolFilter<"Variant"> | boolean
    sprice?: FloatFilter<"Variant"> | number
    pprice?: FloatNullableFilter<"Variant"> | number | null
    qty?: IntNullableFilter<"Variant"> | number | null
    discount?: FloatNullableFilter<"Variant"> | number | null
    dprice?: FloatNullableFilter<"Variant"> | number | null
    sizes?: JsonNullableFilter<"Variant">
    images?: StringNullableListFilter<"Variant">
    tax?: FloatFilter<"Variant"> | number
    productId?: StringFilter<"Variant"> | string
    companyId?: StringFilter<"Variant"> | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    items?: ItemListRelationFilter
    entries?: EntryListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    VariantSizeBarcode?: VariantSizeBarcodeListRelationFilter
  }

  export type VariantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    status?: SortOrder
    sprice?: SortOrder
    pprice?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    dprice?: SortOrderInput | SortOrder
    sizes?: SortOrderInput | SortOrder
    images?: SortOrder
    tax?: SortOrder
    productId?: SortOrder
    companyId?: SortOrder
    product?: ProductOrderByWithRelationInput
    items?: ItemOrderByRelationAggregateInput
    entries?: EntryOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    VariantSizeBarcode?: VariantSizeBarcodeOrderByRelationAggregateInput
  }

  export type VariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VariantWhereInput | VariantWhereInput[]
    OR?: VariantWhereInput[]
    NOT?: VariantWhereInput | VariantWhereInput[]
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    name?: StringFilter<"Variant"> | string
    code?: StringNullableFilter<"Variant"> | string | null
    status?: BoolFilter<"Variant"> | boolean
    sprice?: FloatFilter<"Variant"> | number
    pprice?: FloatNullableFilter<"Variant"> | number | null
    qty?: IntNullableFilter<"Variant"> | number | null
    discount?: FloatNullableFilter<"Variant"> | number | null
    dprice?: FloatNullableFilter<"Variant"> | number | null
    sizes?: JsonNullableFilter<"Variant">
    images?: StringNullableListFilter<"Variant">
    tax?: FloatFilter<"Variant"> | number
    productId?: StringFilter<"Variant"> | string
    companyId?: StringFilter<"Variant"> | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    items?: ItemListRelationFilter
    entries?: EntryListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    VariantSizeBarcode?: VariantSizeBarcodeListRelationFilter
  }, "id">

  export type VariantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    status?: SortOrder
    sprice?: SortOrder
    pprice?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    dprice?: SortOrderInput | SortOrder
    sizes?: SortOrderInput | SortOrder
    images?: SortOrder
    tax?: SortOrder
    productId?: SortOrder
    companyId?: SortOrder
    _count?: VariantCountOrderByAggregateInput
    _avg?: VariantAvgOrderByAggregateInput
    _max?: VariantMaxOrderByAggregateInput
    _min?: VariantMinOrderByAggregateInput
    _sum?: VariantSumOrderByAggregateInput
  }

  export type VariantScalarWhereWithAggregatesInput = {
    AND?: VariantScalarWhereWithAggregatesInput | VariantScalarWhereWithAggregatesInput[]
    OR?: VariantScalarWhereWithAggregatesInput[]
    NOT?: VariantScalarWhereWithAggregatesInput | VariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Variant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Variant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Variant"> | Date | string
    name?: StringWithAggregatesFilter<"Variant"> | string
    code?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    status?: BoolWithAggregatesFilter<"Variant"> | boolean
    sprice?: FloatWithAggregatesFilter<"Variant"> | number
    pprice?: FloatNullableWithAggregatesFilter<"Variant"> | number | null
    qty?: IntNullableWithAggregatesFilter<"Variant"> | number | null
    discount?: FloatNullableWithAggregatesFilter<"Variant"> | number | null
    dprice?: FloatNullableWithAggregatesFilter<"Variant"> | number | null
    sizes?: JsonNullableWithAggregatesFilter<"Variant">
    images?: StringNullableListFilter<"Variant">
    tax?: FloatWithAggregatesFilter<"Variant"> | number
    productId?: StringWithAggregatesFilter<"Variant"> | string
    companyId?: StringWithAggregatesFilter<"Variant"> | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    barcode?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    variantId?: StringFilter<"Item"> | string
    status?: StringFilter<"Item"> | string
    size?: StringNullableFilter<"Item"> | string | null
    companyId?: StringFilter<"Item"> | string
    variant?: XOR<VariantRelationFilter, VariantWhereInput>
    entry?: XOR<EntryNullableRelationFilter, EntryWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    barcode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variantId?: SortOrder
    status?: SortOrder
    size?: SortOrderInput | SortOrder
    companyId?: SortOrder
    variant?: VariantOrderByWithRelationInput
    entry?: EntryOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    barcode?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    variantId?: StringFilter<"Item"> | string
    status?: StringFilter<"Item"> | string
    size?: StringNullableFilter<"Item"> | string | null
    companyId?: StringFilter<"Item"> | string
    variant?: XOR<VariantRelationFilter, VariantWhereInput>
    entry?: XOR<EntryNullableRelationFilter, EntryWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    barcode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variantId?: SortOrder
    status?: SortOrder
    size?: SortOrderInput | SortOrder
    companyId?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    barcode?: StringNullableWithAggregatesFilter<"Item"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    variantId?: StringWithAggregatesFilter<"Item"> | string
    status?: StringWithAggregatesFilter<"Item"> | string
    size?: StringNullableWithAggregatesFilter<"Item"> | string | null
    companyId?: StringWithAggregatesFilter<"Item"> | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    distributorId?: StringNullableFilter<"PurchaseOrder"> | string | null
    paymentType?: EnumpaymentTypeNullableFilter<"PurchaseOrder"> | $Enums.paymentType | null
    companyId?: StringFilter<"PurchaseOrder"> | string
    products?: ProductListRelationFilter
    distributor?: XOR<DistributorNullableRelationFilter, DistributorWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributorId?: SortOrderInput | SortOrder
    paymentType?: SortOrderInput | SortOrder
    companyId?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    distributor?: DistributorOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    distributorId?: StringNullableFilter<"PurchaseOrder"> | string | null
    paymentType?: EnumpaymentTypeNullableFilter<"PurchaseOrder"> | $Enums.paymentType | null
    companyId?: StringFilter<"PurchaseOrder"> | string
    products?: ProductListRelationFilter
    distributor?: XOR<DistributorNullableRelationFilter, DistributorWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributorId?: SortOrderInput | SortOrder
    paymentType?: SortOrderInput | SortOrder
    companyId?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    distributorId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    paymentType?: EnumpaymentTypeNullableWithAggregatesFilter<"PurchaseOrder"> | $Enums.paymentType | null
    companyId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: StringFilter<"Bill"> | string
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    invoiceNumber?: IntNullableFilter<"Bill"> | number | null
    subtotal?: FloatNullableFilter<"Bill"> | number | null
    discount?: FloatNullableFilter<"Bill"> | number | null
    tax?: FloatNullableFilter<"Bill"> | number | null
    grandTotal?: FloatNullableFilter<"Bill"> | number | null
    deliveryFees?: FloatNullableFilter<"Bill"> | number | null
    paymentMethod?: StringNullableFilter<"Bill"> | string | null
    paymentStatus?: EnumPaymentStatusFilter<"Bill"> | $Enums.PaymentStatus
    transactionId?: StringNullableFilter<"Bill"> | string | null
    notes?: StringNullableFilter<"Bill"> | string | null
    type?: EnumOrderTypeNullableFilter<"Bill"> | $Enums.OrderType | null
    status?: EnumOrderStatusNullableFilter<"Bill"> | $Enums.OrderStatus | null
    deleted?: BoolNullableFilter<"Bill"> | boolean | null
    bookingDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    returnDeadline?: StringNullableFilter<"Bill"> | string | null
    companyId?: StringFilter<"Bill"> | string
    accountId?: StringNullableFilter<"Bill"> | string | null
    clientId?: StringNullableFilter<"Bill"> | string | null
    addressId?: StringNullableFilter<"Bill"> | string | null
    entries?: EntryListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    subtotal?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    grandTotal?: SortOrderInput | SortOrder
    deliveryFees?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    bookingDate?: SortOrderInput | SortOrder
    returnDeadline?: SortOrderInput | SortOrder
    companyId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    addressId?: SortOrderInput | SortOrder
    entries?: EntryOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    clientId?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    invoiceNumber?: IntNullableFilter<"Bill"> | number | null
    subtotal?: FloatNullableFilter<"Bill"> | number | null
    discount?: FloatNullableFilter<"Bill"> | number | null
    tax?: FloatNullableFilter<"Bill"> | number | null
    grandTotal?: FloatNullableFilter<"Bill"> | number | null
    deliveryFees?: FloatNullableFilter<"Bill"> | number | null
    paymentMethod?: StringNullableFilter<"Bill"> | string | null
    paymentStatus?: EnumPaymentStatusFilter<"Bill"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Bill"> | string | null
    type?: EnumOrderTypeNullableFilter<"Bill"> | $Enums.OrderType | null
    status?: EnumOrderStatusNullableFilter<"Bill"> | $Enums.OrderStatus | null
    deleted?: BoolNullableFilter<"Bill"> | boolean | null
    bookingDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    returnDeadline?: StringNullableFilter<"Bill"> | string | null
    companyId?: StringFilter<"Bill"> | string
    accountId?: StringNullableFilter<"Bill"> | string | null
    addressId?: StringNullableFilter<"Bill"> | string | null
    entries?: EntryListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
  }, "id" | "id" | "transactionId" | "clientId">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    subtotal?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    grandTotal?: SortOrderInput | SortOrder
    deliveryFees?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    bookingDate?: SortOrderInput | SortOrder
    returnDeadline?: SortOrderInput | SortOrder
    companyId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    addressId?: SortOrderInput | SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    invoiceNumber?: IntNullableWithAggregatesFilter<"Bill"> | number | null
    subtotal?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    discount?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    tax?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    grandTotal?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    deliveryFees?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Bill"> | $Enums.PaymentStatus
    transactionId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    type?: EnumOrderTypeNullableWithAggregatesFilter<"Bill"> | $Enums.OrderType | null
    status?: EnumOrderStatusNullableWithAggregatesFilter<"Bill"> | $Enums.OrderStatus | null
    deleted?: BoolNullableWithAggregatesFilter<"Bill"> | boolean | null
    bookingDate?: DateTimeNullableWithAggregatesFilter<"Bill"> | Date | string | null
    returnDeadline?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    companyId?: StringWithAggregatesFilter<"Bill"> | string
    accountId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    addressId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
  }

  export type TokenEntryWhereInput = {
    AND?: TokenEntryWhereInput | TokenEntryWhereInput[]
    OR?: TokenEntryWhereInput[]
    NOT?: TokenEntryWhereInput | TokenEntryWhereInput[]
    id?: StringFilter<"TokenEntry"> | string
    createdAt?: DateTimeFilter<"TokenEntry"> | Date | string
    tokenNo?: StringFilter<"TokenEntry"> | string
    companyId?: StringFilter<"TokenEntry"> | string
    itemId?: StringFilter<"TokenEntry"> | string
    variantId?: StringFilter<"TokenEntry"> | string
    barcode?: StringFilter<"TokenEntry"> | string
    categoryId?: StringFilter<"TokenEntry"> | string
    size?: StringFilter<"TokenEntry"> | string
    name?: StringFilter<"TokenEntry"> | string
    qty?: IntFilter<"TokenEntry"> | number
    rate?: IntFilter<"TokenEntry"> | number
    discount?: IntFilter<"TokenEntry"> | number
    tax?: IntFilter<"TokenEntry"> | number
    value?: IntFilter<"TokenEntry"> | number
    sizes?: JsonFilter<"TokenEntry">
    totalQty?: IntFilter<"TokenEntry"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type TokenEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tokenNo?: SortOrder
    companyId?: SortOrder
    itemId?: SortOrder
    variantId?: SortOrder
    barcode?: SortOrder
    categoryId?: SortOrder
    size?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    sizes?: SortOrder
    totalQty?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type TokenEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TokenEntryWhereInput | TokenEntryWhereInput[]
    OR?: TokenEntryWhereInput[]
    NOT?: TokenEntryWhereInput | TokenEntryWhereInput[]
    createdAt?: DateTimeFilter<"TokenEntry"> | Date | string
    tokenNo?: StringFilter<"TokenEntry"> | string
    companyId?: StringFilter<"TokenEntry"> | string
    itemId?: StringFilter<"TokenEntry"> | string
    variantId?: StringFilter<"TokenEntry"> | string
    barcode?: StringFilter<"TokenEntry"> | string
    categoryId?: StringFilter<"TokenEntry"> | string
    size?: StringFilter<"TokenEntry"> | string
    name?: StringFilter<"TokenEntry"> | string
    qty?: IntFilter<"TokenEntry"> | number
    rate?: IntFilter<"TokenEntry"> | number
    discount?: IntFilter<"TokenEntry"> | number
    tax?: IntFilter<"TokenEntry"> | number
    value?: IntFilter<"TokenEntry"> | number
    sizes?: JsonFilter<"TokenEntry">
    totalQty?: IntFilter<"TokenEntry"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "id">

  export type TokenEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tokenNo?: SortOrder
    companyId?: SortOrder
    itemId?: SortOrder
    variantId?: SortOrder
    barcode?: SortOrder
    categoryId?: SortOrder
    size?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    sizes?: SortOrder
    totalQty?: SortOrder
    _count?: TokenEntryCountOrderByAggregateInput
    _avg?: TokenEntryAvgOrderByAggregateInput
    _max?: TokenEntryMaxOrderByAggregateInput
    _min?: TokenEntryMinOrderByAggregateInput
    _sum?: TokenEntrySumOrderByAggregateInput
  }

  export type TokenEntryScalarWhereWithAggregatesInput = {
    AND?: TokenEntryScalarWhereWithAggregatesInput | TokenEntryScalarWhereWithAggregatesInput[]
    OR?: TokenEntryScalarWhereWithAggregatesInput[]
    NOT?: TokenEntryScalarWhereWithAggregatesInput | TokenEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TokenEntry"> | Date | string
    tokenNo?: StringWithAggregatesFilter<"TokenEntry"> | string
    companyId?: StringWithAggregatesFilter<"TokenEntry"> | string
    itemId?: StringWithAggregatesFilter<"TokenEntry"> | string
    variantId?: StringWithAggregatesFilter<"TokenEntry"> | string
    barcode?: StringWithAggregatesFilter<"TokenEntry"> | string
    categoryId?: StringWithAggregatesFilter<"TokenEntry"> | string
    size?: StringWithAggregatesFilter<"TokenEntry"> | string
    name?: StringWithAggregatesFilter<"TokenEntry"> | string
    qty?: IntWithAggregatesFilter<"TokenEntry"> | number
    rate?: IntWithAggregatesFilter<"TokenEntry"> | number
    discount?: IntWithAggregatesFilter<"TokenEntry"> | number
    tax?: IntWithAggregatesFilter<"TokenEntry"> | number
    value?: IntWithAggregatesFilter<"TokenEntry"> | number
    sizes?: JsonWithAggregatesFilter<"TokenEntry">
    totalQty?: IntWithAggregatesFilter<"TokenEntry"> | number
  }

  export type EntryWhereInput = {
    AND?: EntryWhereInput | EntryWhereInput[]
    OR?: EntryWhereInput[]
    NOT?: EntryWhereInput | EntryWhereInput[]
    id?: StringFilter<"Entry"> | string
    name?: StringNullableFilter<"Entry"> | string | null
    barcode?: StringNullableFilter<"Entry"> | string | null
    qty?: FloatNullableFilter<"Entry"> | number | null
    rate?: FloatNullableFilter<"Entry"> | number | null
    discount?: FloatNullableFilter<"Entry"> | number | null
    tax?: FloatNullableFilter<"Entry"> | number | null
    value?: FloatNullableFilter<"Entry"> | number | null
    size?: StringNullableFilter<"Entry"> | string | null
    variantId?: StringNullableFilter<"Entry"> | string | null
    outOfStock?: BoolNullableFilter<"Entry"> | boolean | null
    categoryId?: StringNullableFilter<"Entry"> | string | null
    billId?: StringNullableFilter<"Entry"> | string | null
    itemId?: StringNullableFilter<"Entry"> | string | null
    variant?: XOR<VariantNullableRelationFilter, VariantWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    bill?: XOR<BillNullableRelationFilter, BillWhereInput> | null
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
  }

  export type EntryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    variantId?: SortOrderInput | SortOrder
    outOfStock?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    itemId?: SortOrderInput | SortOrder
    variant?: VariantOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    bill?: BillOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type EntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId?: string
    AND?: EntryWhereInput | EntryWhereInput[]
    OR?: EntryWhereInput[]
    NOT?: EntryWhereInput | EntryWhereInput[]
    name?: StringNullableFilter<"Entry"> | string | null
    barcode?: StringNullableFilter<"Entry"> | string | null
    qty?: FloatNullableFilter<"Entry"> | number | null
    rate?: FloatNullableFilter<"Entry"> | number | null
    discount?: FloatNullableFilter<"Entry"> | number | null
    tax?: FloatNullableFilter<"Entry"> | number | null
    value?: FloatNullableFilter<"Entry"> | number | null
    size?: StringNullableFilter<"Entry"> | string | null
    variantId?: StringNullableFilter<"Entry"> | string | null
    outOfStock?: BoolNullableFilter<"Entry"> | boolean | null
    categoryId?: StringNullableFilter<"Entry"> | string | null
    billId?: StringNullableFilter<"Entry"> | string | null
    variant?: XOR<VariantNullableRelationFilter, VariantWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    bill?: XOR<BillNullableRelationFilter, BillWhereInput> | null
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
  }, "id" | "id" | "itemId">

  export type EntryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    variantId?: SortOrderInput | SortOrder
    outOfStock?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    itemId?: SortOrderInput | SortOrder
    _count?: EntryCountOrderByAggregateInput
    _avg?: EntryAvgOrderByAggregateInput
    _max?: EntryMaxOrderByAggregateInput
    _min?: EntryMinOrderByAggregateInput
    _sum?: EntrySumOrderByAggregateInput
  }

  export type EntryScalarWhereWithAggregatesInput = {
    AND?: EntryScalarWhereWithAggregatesInput | EntryScalarWhereWithAggregatesInput[]
    OR?: EntryScalarWhereWithAggregatesInput[]
    NOT?: EntryScalarWhereWithAggregatesInput | EntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Entry"> | string
    name?: StringNullableWithAggregatesFilter<"Entry"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"Entry"> | string | null
    qty?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    rate?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    discount?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    tax?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    value?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    size?: StringNullableWithAggregatesFilter<"Entry"> | string | null
    variantId?: StringNullableWithAggregatesFilter<"Entry"> | string | null
    outOfStock?: BoolNullableWithAggregatesFilter<"Entry"> | boolean | null
    categoryId?: StringNullableWithAggregatesFilter<"Entry"> | string | null
    billId?: StringNullableWithAggregatesFilter<"Entry"> | string | null
    itemId?: StringNullableWithAggregatesFilter<"Entry"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    phone?: StringFilter<"Account"> | string
    companyId?: StringFilter<"Account"> | string
    bill?: BillListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    bill?: BillOrderByRelationAggregateInput
    address?: AddressOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    name?: StringFilter<"Account"> | string
    phone?: StringFilter<"Account"> | string
    companyId?: StringFilter<"Account"> | string
    bill?: BillListRelationFilter
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    phone?: StringWithAggregatesFilter<"Account"> | string
    companyId?: StringWithAggregatesFilter<"Account"> | string
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    status?: BoolFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    companyId?: StringFilter<"ExpenseCategory"> | string
    expenses?: ExpenseListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    name?: StringFilter<"ExpenseCategory"> | string
    status?: BoolFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    companyId?: StringFilter<"ExpenseCategory"> | string
    expenses?: ExpenseListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "id">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    status?: BoolWithAggregatesFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    companyId?: StringWithAggregatesFilter<"ExpenseCategory"> | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    note?: StringNullableFilter<"Expense"> | string | null
    currency?: StringFilter<"Expense"> | string
    paymentMode?: EnumPaymentModeFilter<"Expense"> | $Enums.PaymentMode
    status?: StringFilter<"Expense"> | string
    receipt?: StringNullableFilter<"Expense"> | string | null
    receiptName?: StringNullableFilter<"Expense"> | string | null
    taxAmount?: FloatNullableFilter<"Expense"> | number | null
    totalAmount?: FloatFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    expensecategoryId?: StringFilter<"Expense"> | string
    companyId?: StringFilter<"Expense"> | string
    expensecategory?: XOR<ExpenseCategoryRelationFilter, ExpenseCategoryWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    note?: SortOrderInput | SortOrder
    currency?: SortOrder
    paymentMode?: SortOrder
    status?: SortOrder
    receipt?: SortOrderInput | SortOrder
    receiptName?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expensecategoryId?: SortOrder
    companyId?: SortOrder
    expensecategory?: ExpenseCategoryOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    note?: StringNullableFilter<"Expense"> | string | null
    currency?: StringFilter<"Expense"> | string
    paymentMode?: EnumPaymentModeFilter<"Expense"> | $Enums.PaymentMode
    status?: StringFilter<"Expense"> | string
    receipt?: StringNullableFilter<"Expense"> | string | null
    receiptName?: StringNullableFilter<"Expense"> | string | null
    taxAmount?: FloatNullableFilter<"Expense"> | number | null
    totalAmount?: FloatFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    expensecategoryId?: StringFilter<"Expense"> | string
    companyId?: StringFilter<"Expense"> | string
    expensecategory?: XOR<ExpenseCategoryRelationFilter, ExpenseCategoryWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    note?: SortOrderInput | SortOrder
    currency?: SortOrder
    paymentMode?: SortOrder
    status?: SortOrder
    receipt?: SortOrderInput | SortOrder
    receiptName?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expensecategoryId?: SortOrder
    companyId?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    expenseDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    note?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    currency?: StringWithAggregatesFilter<"Expense"> | string
    paymentMode?: EnumPaymentModeWithAggregatesFilter<"Expense"> | $Enums.PaymentMode
    status?: StringWithAggregatesFilter<"Expense"> | string
    receipt?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    receiptName?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    taxAmount?: FloatNullableWithAggregatesFilter<"Expense"> | number | null
    totalAmount?: FloatWithAggregatesFilter<"Expense"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    expensecategoryId?: StringWithAggregatesFilter<"Expense"> | string
    companyId?: StringWithAggregatesFilter<"Expense"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMode?: StringFilter<"Payment"> | string
    paymentReference?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    companyId?: StringFilter<"Payment"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    paymentReference?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMode?: StringFilter<"Payment"> | string
    paymentReference?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    companyId?: StringFilter<"Payment"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    paymentReference?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMode?: StringWithAggregatesFilter<"Payment"> | string
    paymentReference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    companyId?: StringWithAggregatesFilter<"Payment"> | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    name?: StringNullableFilter<"Address"> | string | null
    street?: StringFilter<"Address"> | string
    locality?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    pincode?: StringFilter<"Address"> | string
    active?: BoolFilter<"Address"> | boolean
    userId?: StringNullableFilter<"Address"> | string | null
    clientId?: StringNullableFilter<"Address"> | string | null
    distributorId?: StringNullableFilter<"Address"> | string | null
    companyId?: StringNullableFilter<"Address"> | string | null
    accountId?: StringNullableFilter<"Address"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    distributor?: XOR<DistributorNullableRelationFilter, DistributorWhereInput> | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    bill?: BillListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    street?: SortOrder
    locality?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    active?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    distributorId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    distributor?: DistributorOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    bill?: BillOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    distributorId?: string
    companyId?: string
    accountId?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    name?: StringNullableFilter<"Address"> | string | null
    street?: StringFilter<"Address"> | string
    locality?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    pincode?: StringFilter<"Address"> | string
    active?: BoolFilter<"Address"> | boolean
    clientId?: StringNullableFilter<"Address"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    distributor?: XOR<DistributorNullableRelationFilter, DistributorWhereInput> | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    bill?: BillListRelationFilter
  }, "id" | "id" | "userId" | "distributorId" | "companyId" | "accountId">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    street?: SortOrder
    locality?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    active?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    distributorId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    name?: StringNullableWithAggregatesFilter<"Address"> | string | null
    street?: StringWithAggregatesFilter<"Address"> | string
    locality?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    pincode?: StringWithAggregatesFilter<"Address"> | string
    active?: BoolWithAggregatesFilter<"Address"> | boolean
    userId?: StringNullableWithAggregatesFilter<"Address"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Address"> | string | null
    distributorId?: StringNullableWithAggregatesFilter<"Address"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"Address"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"Address"> | string | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    users?: UserConversationListRelationFilter
    clients?: ClientConversationListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    users?: UserConversationOrderByRelationAggregateInput
    clients?: ClientConversationOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    users?: UserConversationListRelationFilter
    clients?: ClientConversationListRelationFilter
  }, "id" | "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    text?: StringFilter<"Message"> | string
    seen?: StringNullableListFilter<"Message">
    replyto?: StringNullableFilter<"Message"> | string | null
    edited?: BoolFilter<"Message"> | boolean
    deleted?: BoolFilter<"Message"> | boolean
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    text?: SortOrder
    seen?: SortOrder
    replyto?: SortOrderInput | SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    text?: StringFilter<"Message"> | string
    seen?: StringNullableListFilter<"Message">
    replyto?: StringNullableFilter<"Message"> | string | null
    edited?: BoolFilter<"Message"> | boolean
    deleted?: BoolFilter<"Message"> | boolean
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }, "id" | "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    text?: SortOrder
    seen?: SortOrder
    replyto?: SortOrderInput | SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    text?: StringWithAggregatesFilter<"Message"> | string
    seen?: StringNullableListFilter<"Message">
    replyto?: StringNullableWithAggregatesFilter<"Message"> | string | null
    edited?: BoolWithAggregatesFilter<"Message"> | boolean
    deleted?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type CompanyUserWhereInput = {
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    companyId?: StringFilter<"CompanyUser"> | string
    userId?: StringFilter<"CompanyUser"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CompanyUserOrderByWithRelationInput = {
    companyId?: SortOrder
    userId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CompanyUserWhereUniqueInput = Prisma.AtLeast<{
    companyId_userId?: CompanyUserCompanyIdUserIdCompoundUniqueInput
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    companyId?: StringFilter<"CompanyUser"> | string
    userId?: StringFilter<"CompanyUser"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "companyId_userId">

  export type CompanyUserOrderByWithAggregationInput = {
    companyId?: SortOrder
    userId?: SortOrder
    _count?: CompanyUserCountOrderByAggregateInput
    _max?: CompanyUserMaxOrderByAggregateInput
    _min?: CompanyUserMinOrderByAggregateInput
  }

  export type CompanyUserScalarWhereWithAggregatesInput = {
    AND?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    OR?: CompanyUserScalarWhereWithAggregatesInput[]
    NOT?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    companyId?: StringWithAggregatesFilter<"CompanyUser"> | string
    userId?: StringWithAggregatesFilter<"CompanyUser"> | string
  }

  export type CompanyClientWhereInput = {
    AND?: CompanyClientWhereInput | CompanyClientWhereInput[]
    OR?: CompanyClientWhereInput[]
    NOT?: CompanyClientWhereInput | CompanyClientWhereInput[]
    companyId?: StringFilter<"CompanyClient"> | string
    clientId?: StringFilter<"CompanyClient"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }

  export type CompanyClientOrderByWithRelationInput = {
    companyId?: SortOrder
    clientId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type CompanyClientWhereUniqueInput = Prisma.AtLeast<{
    companyId_clientId?: CompanyClientCompanyIdClientIdCompoundUniqueInput
    AND?: CompanyClientWhereInput | CompanyClientWhereInput[]
    OR?: CompanyClientWhereInput[]
    NOT?: CompanyClientWhereInput | CompanyClientWhereInput[]
    companyId?: StringFilter<"CompanyClient"> | string
    clientId?: StringFilter<"CompanyClient"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }, "companyId_clientId">

  export type CompanyClientOrderByWithAggregationInput = {
    companyId?: SortOrder
    clientId?: SortOrder
    _count?: CompanyClientCountOrderByAggregateInput
    _max?: CompanyClientMaxOrderByAggregateInput
    _min?: CompanyClientMinOrderByAggregateInput
  }

  export type CompanyClientScalarWhereWithAggregatesInput = {
    AND?: CompanyClientScalarWhereWithAggregatesInput | CompanyClientScalarWhereWithAggregatesInput[]
    OR?: CompanyClientScalarWhereWithAggregatesInput[]
    NOT?: CompanyClientScalarWhereWithAggregatesInput | CompanyClientScalarWhereWithAggregatesInput[]
    companyId?: StringWithAggregatesFilter<"CompanyClient"> | string
    clientId?: StringWithAggregatesFilter<"CompanyClient"> | string
  }

  export type UserConversationWhereInput = {
    AND?: UserConversationWhereInput | UserConversationWhereInput[]
    OR?: UserConversationWhereInput[]
    NOT?: UserConversationWhereInput | UserConversationWhereInput[]
    userId?: StringFilter<"UserConversation"> | string
    conversationId?: StringFilter<"UserConversation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }

  export type UserConversationOrderByWithRelationInput = {
    userId?: SortOrder
    conversationId?: SortOrder
    user?: UserOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
  }

  export type UserConversationWhereUniqueInput = Prisma.AtLeast<{
    userId_conversationId?: UserConversationUserIdConversationIdCompoundUniqueInput
    AND?: UserConversationWhereInput | UserConversationWhereInput[]
    OR?: UserConversationWhereInput[]
    NOT?: UserConversationWhereInput | UserConversationWhereInput[]
    userId?: StringFilter<"UserConversation"> | string
    conversationId?: StringFilter<"UserConversation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }, "userId_conversationId">

  export type UserConversationOrderByWithAggregationInput = {
    userId?: SortOrder
    conversationId?: SortOrder
    _count?: UserConversationCountOrderByAggregateInput
    _max?: UserConversationMaxOrderByAggregateInput
    _min?: UserConversationMinOrderByAggregateInput
  }

  export type UserConversationScalarWhereWithAggregatesInput = {
    AND?: UserConversationScalarWhereWithAggregatesInput | UserConversationScalarWhereWithAggregatesInput[]
    OR?: UserConversationScalarWhereWithAggregatesInput[]
    NOT?: UserConversationScalarWhereWithAggregatesInput | UserConversationScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserConversation"> | string
    conversationId?: StringWithAggregatesFilter<"UserConversation"> | string
  }

  export type ClientConversationWhereInput = {
    AND?: ClientConversationWhereInput | ClientConversationWhereInput[]
    OR?: ClientConversationWhereInput[]
    NOT?: ClientConversationWhereInput | ClientConversationWhereInput[]
    clientId?: StringFilter<"ClientConversation"> | string
    conversationId?: StringFilter<"ClientConversation"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }

  export type ClientConversationOrderByWithRelationInput = {
    clientId?: SortOrder
    conversationId?: SortOrder
    client?: ClientOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ClientConversationWhereUniqueInput = Prisma.AtLeast<{
    clientId_conversationId?: ClientConversationClientIdConversationIdCompoundUniqueInput
    AND?: ClientConversationWhereInput | ClientConversationWhereInput[]
    OR?: ClientConversationWhereInput[]
    NOT?: ClientConversationWhereInput | ClientConversationWhereInput[]
    clientId?: StringFilter<"ClientConversation"> | string
    conversationId?: StringFilter<"ClientConversation"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }, "clientId_conversationId">

  export type ClientConversationOrderByWithAggregationInput = {
    clientId?: SortOrder
    conversationId?: SortOrder
    _count?: ClientConversationCountOrderByAggregateInput
    _max?: ClientConversationMaxOrderByAggregateInput
    _min?: ClientConversationMinOrderByAggregateInput
  }

  export type ClientConversationScalarWhereWithAggregatesInput = {
    AND?: ClientConversationScalarWhereWithAggregatesInput | ClientConversationScalarWhereWithAggregatesInput[]
    OR?: ClientConversationScalarWhereWithAggregatesInput[]
    NOT?: ClientConversationScalarWhereWithAggregatesInput | ClientConversationScalarWhereWithAggregatesInput[]
    clientId?: StringWithAggregatesFilter<"ClientConversation"> | string
    conversationId?: StringWithAggregatesFilter<"ClientConversation"> | string
  }

  export type UserClientWhereInput = {
    AND?: UserClientWhereInput | UserClientWhereInput[]
    OR?: UserClientWhereInput[]
    NOT?: UserClientWhereInput | UserClientWhereInput[]
    clientId?: StringFilter<"UserClient"> | string
    userId?: StringFilter<"UserClient"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserClientOrderByWithRelationInput = {
    clientId?: SortOrder
    userId?: SortOrder
    client?: ClientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserClientWhereUniqueInput = Prisma.AtLeast<{
    clientId_userId?: UserClientClientIdUserIdCompoundUniqueInput
    AND?: UserClientWhereInput | UserClientWhereInput[]
    OR?: UserClientWhereInput[]
    NOT?: UserClientWhereInput | UserClientWhereInput[]
    clientId?: StringFilter<"UserClient"> | string
    userId?: StringFilter<"UserClient"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "clientId_userId">

  export type UserClientOrderByWithAggregationInput = {
    clientId?: SortOrder
    userId?: SortOrder
    _count?: UserClientCountOrderByAggregateInput
    _max?: UserClientMaxOrderByAggregateInput
    _min?: UserClientMinOrderByAggregateInput
  }

  export type UserClientScalarWhereWithAggregatesInput = {
    AND?: UserClientScalarWhereWithAggregatesInput | UserClientScalarWhereWithAggregatesInput[]
    OR?: UserClientScalarWhereWithAggregatesInput[]
    NOT?: UserClientScalarWhereWithAggregatesInput | UserClientScalarWhereWithAggregatesInput[]
    clientId?: StringWithAggregatesFilter<"UserClient"> | string
    userId?: StringWithAggregatesFilter<"UserClient"> | string
  }

  export type DistributorCompanyWhereInput = {
    AND?: DistributorCompanyWhereInput | DistributorCompanyWhereInput[]
    OR?: DistributorCompanyWhereInput[]
    NOT?: DistributorCompanyWhereInput | DistributorCompanyWhereInput[]
    distributorId?: StringFilter<"DistributorCompany"> | string
    companyId?: StringFilter<"DistributorCompany"> | string
    distributor?: XOR<DistributorRelationFilter, DistributorWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type DistributorCompanyOrderByWithRelationInput = {
    distributorId?: SortOrder
    companyId?: SortOrder
    distributor?: DistributorOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DistributorCompanyWhereUniqueInput = Prisma.AtLeast<{
    distributorId_companyId?: DistributorCompanyDistributorIdCompanyIdCompoundUniqueInput
    AND?: DistributorCompanyWhereInput | DistributorCompanyWhereInput[]
    OR?: DistributorCompanyWhereInput[]
    NOT?: DistributorCompanyWhereInput | DistributorCompanyWhereInput[]
    distributorId?: StringFilter<"DistributorCompany"> | string
    companyId?: StringFilter<"DistributorCompany"> | string
    distributor?: XOR<DistributorRelationFilter, DistributorWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "distributorId_companyId">

  export type DistributorCompanyOrderByWithAggregationInput = {
    distributorId?: SortOrder
    companyId?: SortOrder
    _count?: DistributorCompanyCountOrderByAggregateInput
    _max?: DistributorCompanyMaxOrderByAggregateInput
    _min?: DistributorCompanyMinOrderByAggregateInput
  }

  export type DistributorCompanyScalarWhereWithAggregatesInput = {
    AND?: DistributorCompanyScalarWhereWithAggregatesInput | DistributorCompanyScalarWhereWithAggregatesInput[]
    OR?: DistributorCompanyScalarWhereWithAggregatesInput[]
    NOT?: DistributorCompanyScalarWhereWithAggregatesInput | DistributorCompanyScalarWhereWithAggregatesInput[]
    distributorId?: StringWithAggregatesFilter<"DistributorCompany"> | string
    companyId?: StringWithAggregatesFilter<"DistributorCompany"> | string
  }

  export type VariantSizeBarcodeWhereInput = {
    AND?: VariantSizeBarcodeWhereInput | VariantSizeBarcodeWhereInput[]
    OR?: VariantSizeBarcodeWhereInput[]
    NOT?: VariantSizeBarcodeWhereInput | VariantSizeBarcodeWhereInput[]
    id?: IntFilter<"VariantSizeBarcode"> | number
    variantId?: StringFilter<"VariantSizeBarcode"> | string
    size?: StringNullableFilter<"VariantSizeBarcode"> | string | null
    barcode?: StringFilter<"VariantSizeBarcode"> | string
    variant?: XOR<VariantRelationFilter, VariantWhereInput>
  }

  export type VariantSizeBarcodeOrderByWithRelationInput = {
    id?: SortOrder
    variantId?: SortOrder
    size?: SortOrderInput | SortOrder
    barcode?: SortOrder
    variant?: VariantOrderByWithRelationInput
  }

  export type VariantSizeBarcodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    barcode?: string
    variantId_size?: VariantSizeBarcodeVariantIdSizeCompoundUniqueInput
    AND?: VariantSizeBarcodeWhereInput | VariantSizeBarcodeWhereInput[]
    OR?: VariantSizeBarcodeWhereInput[]
    NOT?: VariantSizeBarcodeWhereInput | VariantSizeBarcodeWhereInput[]
    variantId?: StringFilter<"VariantSizeBarcode"> | string
    size?: StringNullableFilter<"VariantSizeBarcode"> | string | null
    variant?: XOR<VariantRelationFilter, VariantWhereInput>
  }, "id" | "barcode" | "variantId_size">

  export type VariantSizeBarcodeOrderByWithAggregationInput = {
    id?: SortOrder
    variantId?: SortOrder
    size?: SortOrderInput | SortOrder
    barcode?: SortOrder
    _count?: VariantSizeBarcodeCountOrderByAggregateInput
    _avg?: VariantSizeBarcodeAvgOrderByAggregateInput
    _max?: VariantSizeBarcodeMaxOrderByAggregateInput
    _min?: VariantSizeBarcodeMinOrderByAggregateInput
    _sum?: VariantSizeBarcodeSumOrderByAggregateInput
  }

  export type VariantSizeBarcodeScalarWhereWithAggregatesInput = {
    AND?: VariantSizeBarcodeScalarWhereWithAggregatesInput | VariantSizeBarcodeScalarWhereWithAggregatesInput[]
    OR?: VariantSizeBarcodeScalarWhereWithAggregatesInput[]
    NOT?: VariantSizeBarcodeScalarWhereWithAggregatesInput | VariantSizeBarcodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VariantSizeBarcode"> | number
    variantId?: StringWithAggregatesFilter<"VariantSizeBarcode"> | string
    size?: StringNullableWithAggregatesFilter<"VariantSizeBarcode"> | string | null
    barcode?: StringWithAggregatesFilter<"VariantSizeBarcode"> | string
  }

  export type EmailOtpWhereInput = {
    AND?: EmailOtpWhereInput | EmailOtpWhereInput[]
    OR?: EmailOtpWhereInput[]
    NOT?: EmailOtpWhereInput | EmailOtpWhereInput[]
    id?: StringFilter<"EmailOtp"> | string
    email?: StringFilter<"EmailOtp"> | string
    otp?: StringFilter<"EmailOtp"> | string
    expiresAt?: DateTimeFilter<"EmailOtp"> | Date | string
  }

  export type EmailOtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailOtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: EmailOtpWhereInput | EmailOtpWhereInput[]
    OR?: EmailOtpWhereInput[]
    NOT?: EmailOtpWhereInput | EmailOtpWhereInput[]
    otp?: StringFilter<"EmailOtp"> | string
    expiresAt?: DateTimeFilter<"EmailOtp"> | Date | string
  }, "id" | "id" | "email">

  export type EmailOtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    _count?: EmailOtpCountOrderByAggregateInput
    _max?: EmailOtpMaxOrderByAggregateInput
    _min?: EmailOtpMinOrderByAggregateInput
  }

  export type EmailOtpScalarWhereWithAggregatesInput = {
    AND?: EmailOtpScalarWhereWithAggregatesInput | EmailOtpScalarWhereWithAggregatesInput[]
    OR?: EmailOtpScalarWhereWithAggregatesInput[]
    NOT?: EmailOtpScalarWhereWithAggregatesInput | EmailOtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailOtp"> | string
    email?: StringWithAggregatesFilter<"EmailOtp"> | string
    otp?: StringWithAggregatesFilter<"EmailOtp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailOtp"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    companyId?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    clientId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionPath?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionPath?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    companyId?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    clientId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionPath?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionPath?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    companyId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionPath?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
  }

  export type DistributorCreateInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    companies?: DistributorCompanyCreateNestedManyWithoutDistributorInput
    purchaseorders?: PurchaseOrderCreateNestedManyWithoutDistributorInput
    address?: AddressCreateNestedOneWithoutDistributorInput
  }

  export type DistributorUncheckedCreateInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    companies?: DistributorCompanyUncheckedCreateNestedManyWithoutDistributorInput
    purchaseorders?: PurchaseOrderUncheckedCreateNestedManyWithoutDistributorInput
    address?: AddressUncheckedCreateNestedOneWithoutDistributorInput
  }

  export type DistributorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: DistributorCompanyUpdateManyWithoutDistributorNestedInput
    purchaseorders?: PurchaseOrderUpdateManyWithoutDistributorNestedInput
    address?: AddressUpdateOneWithoutDistributorNestedInput
  }

  export type DistributorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: DistributorCompanyUncheckedUpdateManyWithoutDistributorNestedInput
    purchaseorders?: PurchaseOrderUncheckedUpdateManyWithoutDistributorNestedInput
    address?: AddressUncheckedUpdateOneWithoutDistributorNestedInput
  }

  export type DistributorCreateManyInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
  }

  export type DistributorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DistributorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversations?: UserConversationCreateNestedManyWithoutUserInput
    clients?: UserClientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversations?: UserConversationUncheckedCreateNestedManyWithoutUserInput
    clients?: UserClientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUpdateManyWithoutUserNestedInput
    clients?: UserClientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUncheckedUpdateManyWithoutUserNestedInput
    clients?: UserClientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PipelineCreateInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutPipelineInput
    newClients?: ClientCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUncheckedCreateInput = {
    id?: string
    companyId: string
    newClients?: ClientUncheckedCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientUncheckedCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientUncheckedCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientUncheckedCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientUncheckedCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPipelineNestedInput
    newClients?: ClientUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUncheckedUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUncheckedUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineCreateManyInput = {
    id?: string
    companyId: string
  }

  export type PipelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    company: CompanyCreateNestedOneWithoutCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    entries?: EntryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    entries?: EntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    entries?: EntryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: EntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SubcategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    company: CompanyCreateNestedOneWithoutSubcategoriesInput
    products?: ProductCreateNestedManyWithoutSubcategoryInput
    category?: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    categoryId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutSubcategoriesNestedInput
    products?: ProductUpdateManyWithoutSubcategoryNestedInput
    category?: CategoryUpdateOneWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    categoryId?: string | null
  }

  export type SubcategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubcategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    subcategory?: SubcategoryCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
    purchaseorder: PurchaseOrderCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    subcategoryId?: string | null
    purchaseorderId: string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    purchaseorder?: PurchaseOrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    subcategoryId?: string | null
    purchaseorderId: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    product: ProductCreateNestedOneWithoutVariantsInput
    items?: ItemCreateNestedManyWithoutVariantInput
    entries?: EntryCreateNestedManyWithoutVariantInput
    company: CompanyCreateNestedOneWithoutVariantsInput
    VariantSizeBarcode?: VariantSizeBarcodeCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
    companyId: string
    items?: ItemUncheckedCreateNestedManyWithoutVariantInput
    entries?: EntryUncheckedCreateNestedManyWithoutVariantInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    items?: ItemUpdateManyWithoutVariantNestedInput
    entries?: EntryUpdateManyWithoutVariantNestedInput
    company?: CompanyUpdateOneRequiredWithoutVariantsNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutVariantNestedInput
    entries?: EntryUncheckedUpdateManyWithoutVariantNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VariantCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
    companyId: string
  }

  export type VariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
  }

  export type VariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    size?: string | null
    variant: VariantCreateNestedOneWithoutItemsInput
    entry?: EntryCreateNestedOneWithoutItemInput
    company: CompanyCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variantId: string
    status?: string
    size?: string | null
    companyId: string
    entry?: EntryUncheckedCreateNestedOneWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: VariantUpdateOneRequiredWithoutItemsNestedInput
    entry?: EntryUpdateOneWithoutItemNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    entry?: EntryUncheckedUpdateOneWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variantId: string
    status?: string
    size?: string | null
    companyId: string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentType?: $Enums.paymentType | null
    products?: ProductCreateNestedManyWithoutPurchaseorderInput
    distributor?: DistributorCreateNestedOneWithoutPurchaseordersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    distributorId?: string | null
    paymentType?: $Enums.paymentType | null
    companyId: string
    products?: ProductUncheckedCreateNestedManyWithoutPurchaseorderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    products?: ProductUpdateManyWithoutPurchaseorderNestedInput
    distributor?: DistributorUpdateOneWithoutPurchaseordersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    companyId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutPurchaseorderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    distributorId?: string | null
    paymentType?: $Enums.paymentType | null
    companyId: string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type BillCreateInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    entries?: EntryCreateNestedManyWithoutBillInput
    company: CompanyCreateNestedOneWithoutBillsInput
    account?: AccountCreateNestedOneWithoutBillInput
    client?: ClientCreateNestedOneWithoutBillInput
    address?: AddressCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    accountId?: string | null
    clientId?: string | null
    addressId?: string | null
    entries?: EntryUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUpdateManyWithoutBillNestedInput
    company?: CompanyUpdateOneRequiredWithoutBillsNestedInput
    account?: AccountUpdateOneWithoutBillNestedInput
    client?: ClientUpdateOneWithoutBillNestedInput
    address?: AddressUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillCreateManyInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    accountId?: string | null
    clientId?: string | null
    addressId?: string | null
  }

  export type BillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenEntryCreateInput = {
    id?: string
    createdAt: Date | string
    tokenNo: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonNullValueInput | InputJsonValue
    totalQty: number
    company: CompanyCreateNestedOneWithoutTokenbillsInput
  }

  export type TokenEntryUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    tokenNo: string
    companyId: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonNullValueInput | InputJsonValue
    totalQty: number
  }

  export type TokenEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
    company?: CompanyUpdateOneRequiredWithoutTokenbillsNestedInput
  }

  export type TokenEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
  }

  export type TokenEntryCreateManyInput = {
    id?: string
    createdAt: Date | string
    tokenNo: string
    companyId: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonNullValueInput | InputJsonValue
    totalQty: number
  }

  export type TokenEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
  }

  export type TokenEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
  }

  export type EntryCreateInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    variant?: VariantCreateNestedOneWithoutEntriesInput
    category?: CategoryCreateNestedOneWithoutEntriesInput
    bill?: BillCreateNestedOneWithoutEntriesInput
    item?: ItemCreateNestedOneWithoutEntryInput
  }

  export type EntryUncheckedCreateInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    billId?: string | null
    itemId?: string | null
  }

  export type EntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    variant?: VariantUpdateOneWithoutEntriesNestedInput
    category?: CategoryUpdateOneWithoutEntriesNestedInput
    bill?: BillUpdateOneWithoutEntriesNestedInput
    item?: ItemUpdateOneWithoutEntryNestedInput
  }

  export type EntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntryCreateManyInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    billId?: string | null
    itemId?: string | null
  }

  export type EntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    phone: string
    bill?: BillCreateNestedManyWithoutAccountInput
    address?: AddressCreateNestedOneWithoutAccountInput
    company: CompanyCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    name: string
    phone: string
    companyId: string
    bill?: BillUncheckedCreateNestedManyWithoutAccountInput
    address?: AddressUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bill?: BillUpdateManyWithoutAccountNestedInput
    address?: AddressUpdateOneWithoutAccountNestedInput
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    bill?: BillUncheckedUpdateManyWithoutAccountNestedInput
    address?: AddressUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    name: string
    phone: string
    companyId: string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCategoryCreateInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutExpensecategoryInput
    company: CompanyCreateNestedOneWithoutExpenseCategoriesInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutExpensecategoryInput
  }

  export type ExpenseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutExpensecategoryNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    expenses?: ExpenseUncheckedUpdateManyWithoutExpensecategoryNestedInput
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCreateInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expensecategory: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    company: CompanyCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expensecategoryId: string
    companyId: string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expensecategory?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expensecategoryId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expensecategoryId: string
    companyId: string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expensecategoryId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentDate?: Date | string
    paymentMode: string
    paymentReference?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentDate?: Date | string
    paymentMode: string
    paymentReference?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentDate?: Date | string
    paymentMode: string
    paymentReference?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    user?: UserCreateNestedOneWithoutAddressInput
    client?: ClientCreateNestedOneWithoutAddressInput
    distributor?: DistributorCreateNestedOneWithoutAddressInput
    company?: CompanyCreateNestedOneWithoutAddressInput
    account?: AccountCreateNestedOneWithoutAddressInput
    bill?: BillCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    clientId?: string | null
    distributorId?: string | null
    companyId?: string | null
    accountId?: string | null
    bill?: BillUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAddressNestedInput
    client?: ClientUpdateOneWithoutAddressNestedInput
    distributor?: DistributorUpdateOneWithoutAddressNestedInput
    company?: CompanyUpdateOneWithoutAddressNestedInput
    account?: AccountUpdateOneWithoutAddressNestedInput
    bill?: BillUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    clientId?: string | null
    distributorId?: string | null
    companyId?: string | null
    accountId?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    users?: UserConversationCreateNestedManyWithoutConversationInput
    clients?: ClientConversationCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    users?: UserConversationUncheckedCreateNestedManyWithoutConversationInput
    clients?: ClientConversationUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    users?: UserConversationUpdateManyWithoutConversationNestedInput
    clients?: ClientConversationUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    users?: UserConversationUncheckedUpdateManyWithoutConversationNestedInput
    clients?: ClientConversationUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    text: string
    seen?: MessageCreateseenInput | string[]
    replyto?: string | null
    edited?: boolean
    deleted?: boolean
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    senderId: string
    text: string
    seen?: MessageCreateseenInput | string[]
    replyto?: string | null
    edited?: boolean
    deleted?: boolean
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    senderId: string
    text: string
    seen?: MessageCreateseenInput | string[]
    replyto?: string | null
    edited?: boolean
    deleted?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyUserCreateInput = {
    company: CompanyCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyUserUncheckedCreateInput = {
    companyId: string
    userId: string
  }

  export type CompanyUserUpdateInput = {
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyUserUncheckedUpdateInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUserCreateManyInput = {
    companyId: string
    userId: string
  }

  export type CompanyUserUpdateManyMutationInput = {

  }

  export type CompanyUserUncheckedUpdateManyInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyClientCreateInput = {
    company: CompanyCreateNestedOneWithoutClientsInput
    client: ClientCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyClientUncheckedCreateInput = {
    companyId: string
    clientId: string
  }

  export type CompanyClientUpdateInput = {
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
    client?: ClientUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyClientUncheckedUpdateInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyClientCreateManyInput = {
    companyId: string
    clientId: string
  }

  export type CompanyClientUpdateManyMutationInput = {

  }

  export type CompanyClientUncheckedUpdateManyInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type UserConversationCreateInput = {
    user: UserCreateNestedOneWithoutConversationsInput
    conversation: ConversationCreateNestedOneWithoutUsersInput
  }

  export type UserConversationUncheckedCreateInput = {
    userId: string
    conversationId: string
  }

  export type UserConversationUpdateInput = {
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserConversationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type UserConversationCreateManyInput = {
    userId: string
    conversationId: string
  }

  export type UserConversationUpdateManyMutationInput = {

  }

  export type UserConversationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientConversationCreateInput = {
    client: ClientCreateNestedOneWithoutConversationsInput
    conversation: ConversationCreateNestedOneWithoutClientsInput
  }

  export type ClientConversationUncheckedCreateInput = {
    clientId: string
    conversationId: string
  }

  export type ClientConversationUpdateInput = {
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientConversationUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientConversationCreateManyInput = {
    clientId: string
    conversationId: string
  }

  export type ClientConversationUpdateManyMutationInput = {

  }

  export type ClientConversationUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientCreateInput = {
    client: ClientCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutClientsInput
  }

  export type UserClientUncheckedCreateInput = {
    clientId: string
    userId: string
  }

  export type UserClientUpdateInput = {
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
  }

  export type UserClientUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientCreateManyInput = {
    clientId: string
    userId: string
  }

  export type UserClientUpdateManyMutationInput = {

  }

  export type UserClientUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCompanyCreateInput = {
    distributor: DistributorCreateNestedOneWithoutCompaniesInput
    company: CompanyCreateNestedOneWithoutDistributorInput
  }

  export type DistributorCompanyUncheckedCreateInput = {
    distributorId: string
    companyId: string
  }

  export type DistributorCompanyUpdateInput = {
    distributor?: DistributorUpdateOneRequiredWithoutCompaniesNestedInput
    company?: CompanyUpdateOneRequiredWithoutDistributorNestedInput
  }

  export type DistributorCompanyUncheckedUpdateInput = {
    distributorId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCompanyCreateManyInput = {
    distributorId: string
    companyId: string
  }

  export type DistributorCompanyUpdateManyMutationInput = {

  }

  export type DistributorCompanyUncheckedUpdateManyInput = {
    distributorId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantSizeBarcodeCreateInput = {
    size?: string | null
    barcode: string
    variant: VariantCreateNestedOneWithoutVariantSizeBarcodeInput
  }

  export type VariantSizeBarcodeUncheckedCreateInput = {
    id?: number
    variantId: string
    size?: string | null
    barcode: string
  }

  export type VariantSizeBarcodeUpdateInput = {
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    variant?: VariantUpdateOneRequiredWithoutVariantSizeBarcodeNestedInput
  }

  export type VariantSizeBarcodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    variantId?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
  }

  export type VariantSizeBarcodeCreateManyInput = {
    id?: number
    variantId: string
    size?: string | null
    barcode: string
  }

  export type VariantSizeBarcodeUpdateManyMutationInput = {
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
  }

  export type VariantSizeBarcodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    variantId?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
  }

  export type EmailOtpCreateInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
  }

  export type EmailOtpUncheckedCreateInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
  }

  export type EmailOtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOtpCreateManyInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
  }

  export type EmailOtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutNotificationsInput
    user?: UserCreateNestedOneWithoutNotificationsInput
    client?: ClientCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    companyId: string
    userId?: string | null
    clientId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneWithoutNotificationsNestedInput
    client?: ClientUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    companyId: string
    userId?: string | null
    clientId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumCompanyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeFilter<$PrismaModel> | $Enums.CompanyType
  }

  export type CompanyUserListRelationFilter = {
    every?: CompanyUserWhereInput
    some?: CompanyUserWhereInput
    none?: CompanyUserWhereInput
  }

  export type CompanyClientListRelationFilter = {
    every?: CompanyClientWhereInput
    some?: CompanyClientWhereInput
    none?: CompanyClientWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type SubcategoryListRelationFilter = {
    every?: SubcategoryWhereInput
    some?: SubcategoryWhereInput
    none?: SubcategoryWhereInput
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type TokenEntryListRelationFilter = {
    every?: TokenEntryWhereInput
    some?: TokenEntryWhereInput
    none?: TokenEntryWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ExpenseCategoryListRelationFilter = {
    every?: ExpenseCategoryWhereInput
    some?: ExpenseCategoryWhereInput
    none?: ExpenseCategoryWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type VariantListRelationFilter = {
    every?: VariantWhereInput
    some?: VariantWhereInput
    none?: VariantWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type PipelineNullableRelationFilter = {
    is?: PipelineWhereInput | null
    isNot?: PipelineWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AddressNullableRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type DistributorCompanyListRelationFilter = {
    every?: DistributorCompanyWhereInput
    some?: DistributorCompanyWhereInput
    none?: DistributorCompanyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompanyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistributorCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storecode?: SortOrder
    storeUniqueName?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    shopifyStoreName?: SortOrder
    shopifyAccessToken?: SortOrder
    tiktokCipher?: SortOrder
    tiktokStoreName?: SortOrder
    tiktokAccessToken?: SortOrder
    tiktokAccessTokenExpireIn?: SortOrder
    tiktokRefreshToken?: SortOrder
    tiktokRefreshTokenExpireIn?: SortOrder
    images?: SortOrder
    isTaxIncluded?: SortOrder
    status?: SortOrder
    type?: SortOrder
    accHolderName?: SortOrder
    ifsc?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    gstin?: SortOrder
    upiId?: SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    storecode?: SortOrder
    tiktokAccessTokenExpireIn?: SortOrder
    tiktokRefreshTokenExpireIn?: SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storecode?: SortOrder
    storeUniqueName?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    shopifyStoreName?: SortOrder
    shopifyAccessToken?: SortOrder
    tiktokCipher?: SortOrder
    tiktokStoreName?: SortOrder
    tiktokAccessToken?: SortOrder
    tiktokAccessTokenExpireIn?: SortOrder
    tiktokRefreshToken?: SortOrder
    tiktokRefreshTokenExpireIn?: SortOrder
    images?: SortOrder
    isTaxIncluded?: SortOrder
    status?: SortOrder
    type?: SortOrder
    accHolderName?: SortOrder
    ifsc?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    gstin?: SortOrder
    upiId?: SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storecode?: SortOrder
    storeUniqueName?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    shopifyStoreName?: SortOrder
    shopifyAccessToken?: SortOrder
    tiktokCipher?: SortOrder
    tiktokStoreName?: SortOrder
    tiktokAccessToken?: SortOrder
    tiktokAccessTokenExpireIn?: SortOrder
    tiktokRefreshToken?: SortOrder
    tiktokRefreshTokenExpireIn?: SortOrder
    images?: SortOrder
    isTaxIncluded?: SortOrder
    status?: SortOrder
    type?: SortOrder
    accHolderName?: SortOrder
    ifsc?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    gstin?: SortOrder
    upiId?: SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    storecode?: SortOrder
    tiktokAccessTokenExpireIn?: SortOrder
    tiktokRefreshTokenExpireIn?: SortOrder
    billCounter?: SortOrder
    barcodeCounter?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCompanyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CompanyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyTypeFilter<$PrismaModel>
    _max?: NestedEnumCompanyTypeFilter<$PrismaModel>
  }

  export type DistributorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrder
    status?: SortOrder
    accHolderName?: SortOrder
    ifsc?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    gstin?: SortOrder
  }

  export type DistributorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrder
    status?: SortOrder
    accHolderName?: SortOrder
    ifsc?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    gstin?: SortOrder
  }

  export type DistributorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrder
    status?: SortOrder
    accHolderName?: SortOrder
    ifsc?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    gstin?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserConversationListRelationFilter = {
    every?: UserConversationWhereInput
    some?: UserConversationWhereInput
    none?: UserConversationWhereInput
  }

  export type UserClientListRelationFilter = {
    every?: UserClientWhereInput
    some?: UserClientWhereInput
    none?: UserClientWhereInput
  }

  export type UserConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    image?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type BillNullableRelationFilter = {
    is?: BillWhereInput | null
    isNot?: BillWhereInput | null
  }

  export type ClientConversationListRelationFilter = {
    every?: ClientConversationWhereInput
    some?: ClientConversationWhereInput
    none?: ClientConversationWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    pipelineStatus?: SortOrder
    newPipelineId?: SortOrder
    prospectPipelineId?: SortOrder
    viewingPipelineId?: SortOrder
    rejectPipelineId?: SortOrder
    closePipelineId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    pipelineStatus?: SortOrder
    newPipelineId?: SortOrder
    prospectPipelineId?: SortOrder
    viewingPipelineId?: SortOrder
    rejectPipelineId?: SortOrder
    closePipelineId?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    pipelineStatus?: SortOrder
    newPipelineId?: SortOrder
    prospectPipelineId?: SortOrder
    viewingPipelineId?: SortOrder
    rejectPipelineId?: SortOrder
    closePipelineId?: SortOrder
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type PipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type PipelineMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumTaxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeFilter<$PrismaModel> | $Enums.TaxType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EntryListRelationFilter = {
    every?: EntryWhereInput
    some?: EntryWhereInput
    none?: EntryWhereInput
  }

  export type EntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
    hsn?: SortOrder
    taxType?: SortOrder
    fixedTax?: SortOrder
    thresholdAmount?: SortOrder
    taxBelowThreshold?: SortOrder
    taxAboveThreshold?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    fixedTax?: SortOrder
    thresholdAmount?: SortOrder
    taxBelowThreshold?: SortOrder
    taxAboveThreshold?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
    hsn?: SortOrder
    taxType?: SortOrder
    fixedTax?: SortOrder
    thresholdAmount?: SortOrder
    taxBelowThreshold?: SortOrder
    taxAboveThreshold?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
    hsn?: SortOrder
    taxType?: SortOrder
    fixedTax?: SortOrder
    thresholdAmount?: SortOrder
    taxBelowThreshold?: SortOrder
    taxAboveThreshold?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    fixedTax?: SortOrder
    thresholdAmount?: SortOrder
    taxBelowThreshold?: SortOrder
    taxAboveThreshold?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTaxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type SubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryNullableRelationFilter = {
    is?: SubcategoryWhereInput | null
    isNot?: SubcategoryWhereInput | null
  }

  export type PurchaseOrderRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    purchaseorderId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    purchaseorderId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    purchaseorderId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type VariantSizeBarcodeListRelationFilter = {
    every?: VariantSizeBarcodeWhereInput
    some?: VariantSizeBarcodeWhereInput
    none?: VariantSizeBarcodeWhereInput
  }

  export type VariantSizeBarcodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    sprice?: SortOrder
    pprice?: SortOrder
    qty?: SortOrder
    discount?: SortOrder
    dprice?: SortOrder
    sizes?: SortOrder
    images?: SortOrder
    tax?: SortOrder
    productId?: SortOrder
    companyId?: SortOrder
  }

  export type VariantAvgOrderByAggregateInput = {
    sprice?: SortOrder
    pprice?: SortOrder
    qty?: SortOrder
    discount?: SortOrder
    dprice?: SortOrder
    tax?: SortOrder
  }

  export type VariantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    sprice?: SortOrder
    pprice?: SortOrder
    qty?: SortOrder
    discount?: SortOrder
    dprice?: SortOrder
    tax?: SortOrder
    productId?: SortOrder
    companyId?: SortOrder
  }

  export type VariantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    sprice?: SortOrder
    pprice?: SortOrder
    qty?: SortOrder
    discount?: SortOrder
    dprice?: SortOrder
    tax?: SortOrder
    productId?: SortOrder
    companyId?: SortOrder
  }

  export type VariantSumOrderByAggregateInput = {
    sprice?: SortOrder
    pprice?: SortOrder
    qty?: SortOrder
    discount?: SortOrder
    dprice?: SortOrder
    tax?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type VariantRelationFilter = {
    is?: VariantWhereInput
    isNot?: VariantWhereInput
  }

  export type EntryNullableRelationFilter = {
    is?: EntryWhereInput | null
    isNot?: EntryWhereInput | null
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variantId?: SortOrder
    status?: SortOrder
    size?: SortOrder
    companyId?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variantId?: SortOrder
    status?: SortOrder
    size?: SortOrder
    companyId?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variantId?: SortOrder
    status?: SortOrder
    size?: SortOrder
    companyId?: SortOrder
  }

  export type EnumpaymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.paymentType | EnumpaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpaymentTypeNullableFilter<$PrismaModel> | $Enums.paymentType | null
  }

  export type DistributorNullableRelationFilter = {
    is?: DistributorWhereInput | null
    isNot?: DistributorWhereInput | null
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributorId?: SortOrder
    paymentType?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributorId?: SortOrder
    paymentType?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributorId?: SortOrder
    paymentType?: SortOrder
    companyId?: SortOrder
  }

  export type EnumpaymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.paymentType | EnumpaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpaymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.paymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpaymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumpaymentTypeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumOrderTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderTypeNullableFilter<$PrismaModel> | $Enums.OrderType | null
  }

  export type EnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    invoiceNumber?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    grandTotal?: SortOrder
    deliveryFees?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    status?: SortOrder
    deleted?: SortOrder
    bookingDate?: SortOrder
    returnDeadline?: SortOrder
    companyId?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    addressId?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    invoiceNumber?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    grandTotal?: SortOrder
    deliveryFees?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    invoiceNumber?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    grandTotal?: SortOrder
    deliveryFees?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    status?: SortOrder
    deleted?: SortOrder
    bookingDate?: SortOrder
    returnDeadline?: SortOrder
    companyId?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    addressId?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    invoiceNumber?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    grandTotal?: SortOrder
    deliveryFees?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    status?: SortOrder
    deleted?: SortOrder
    bookingDate?: SortOrder
    returnDeadline?: SortOrder
    companyId?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    addressId?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    invoiceNumber?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    grandTotal?: SortOrder
    deliveryFees?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumOrderTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TokenEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tokenNo?: SortOrder
    companyId?: SortOrder
    itemId?: SortOrder
    variantId?: SortOrder
    barcode?: SortOrder
    categoryId?: SortOrder
    size?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    sizes?: SortOrder
    totalQty?: SortOrder
  }

  export type TokenEntryAvgOrderByAggregateInput = {
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    totalQty?: SortOrder
  }

  export type TokenEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tokenNo?: SortOrder
    companyId?: SortOrder
    itemId?: SortOrder
    variantId?: SortOrder
    barcode?: SortOrder
    categoryId?: SortOrder
    size?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    totalQty?: SortOrder
  }

  export type TokenEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tokenNo?: SortOrder
    companyId?: SortOrder
    itemId?: SortOrder
    variantId?: SortOrder
    barcode?: SortOrder
    categoryId?: SortOrder
    size?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    totalQty?: SortOrder
  }

  export type TokenEntrySumOrderByAggregateInput = {
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    totalQty?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type VariantNullableRelationFilter = {
    is?: VariantWhereInput | null
    isNot?: VariantWhereInput | null
  }

  export type ItemNullableRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type EntryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    size?: SortOrder
    variantId?: SortOrder
    outOfStock?: SortOrder
    categoryId?: SortOrder
    billId?: SortOrder
    itemId?: SortOrder
  }

  export type EntryAvgOrderByAggregateInput = {
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
  }

  export type EntryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    size?: SortOrder
    variantId?: SortOrder
    outOfStock?: SortOrder
    categoryId?: SortOrder
    billId?: SortOrder
    itemId?: SortOrder
  }

  export type EntryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
    size?: SortOrder
    variantId?: SortOrder
    outOfStock?: SortOrder
    categoryId?: SortOrder
    billId?: SortOrder
    itemId?: SortOrder
  }

  export type EntrySumOrderByAggregateInput = {
    qty?: SortOrder
    rate?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    value?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type EnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type ExpenseCategoryRelationFilter = {
    is?: ExpenseCategoryWhereInput
    isNot?: ExpenseCategoryWhereInput
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    note?: SortOrder
    currency?: SortOrder
    paymentMode?: SortOrder
    status?: SortOrder
    receipt?: SortOrder
    receiptName?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expensecategoryId?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    note?: SortOrder
    currency?: SortOrder
    paymentMode?: SortOrder
    status?: SortOrder
    receipt?: SortOrder
    receiptName?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expensecategoryId?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    note?: SortOrder
    currency?: SortOrder
    paymentMode?: SortOrder
    status?: SortOrder
    receipt?: SortOrder
    receiptName?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expensecategoryId?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    paymentReference?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    paymentReference?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    paymentReference?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    street?: SortOrder
    locality?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    active?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    distributorId?: SortOrder
    companyId?: SortOrder
    accountId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    street?: SortOrder
    locality?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    active?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    distributorId?: SortOrder
    companyId?: SortOrder
    accountId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    street?: SortOrder
    locality?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    active?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    distributorId?: SortOrder
    companyId?: SortOrder
    accountId?: SortOrder
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    text?: SortOrder
    seen?: SortOrder
    replyto?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    text?: SortOrder
    replyto?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    text?: SortOrder
    replyto?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyUserCompanyIdUserIdCompoundUniqueInput = {
    companyId: string
    userId: string
  }

  export type CompanyUserCountOrderByAggregateInput = {
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type CompanyUserMaxOrderByAggregateInput = {
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type CompanyUserMinOrderByAggregateInput = {
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type CompanyClientCompanyIdClientIdCompoundUniqueInput = {
    companyId: string
    clientId: string
  }

  export type CompanyClientCountOrderByAggregateInput = {
    companyId?: SortOrder
    clientId?: SortOrder
  }

  export type CompanyClientMaxOrderByAggregateInput = {
    companyId?: SortOrder
    clientId?: SortOrder
  }

  export type CompanyClientMinOrderByAggregateInput = {
    companyId?: SortOrder
    clientId?: SortOrder
  }

  export type UserConversationUserIdConversationIdCompoundUniqueInput = {
    userId: string
    conversationId: string
  }

  export type UserConversationCountOrderByAggregateInput = {
    userId?: SortOrder
    conversationId?: SortOrder
  }

  export type UserConversationMaxOrderByAggregateInput = {
    userId?: SortOrder
    conversationId?: SortOrder
  }

  export type UserConversationMinOrderByAggregateInput = {
    userId?: SortOrder
    conversationId?: SortOrder
  }

  export type ClientConversationClientIdConversationIdCompoundUniqueInput = {
    clientId: string
    conversationId: string
  }

  export type ClientConversationCountOrderByAggregateInput = {
    clientId?: SortOrder
    conversationId?: SortOrder
  }

  export type ClientConversationMaxOrderByAggregateInput = {
    clientId?: SortOrder
    conversationId?: SortOrder
  }

  export type ClientConversationMinOrderByAggregateInput = {
    clientId?: SortOrder
    conversationId?: SortOrder
  }

  export type UserClientClientIdUserIdCompoundUniqueInput = {
    clientId: string
    userId: string
  }

  export type UserClientCountOrderByAggregateInput = {
    clientId?: SortOrder
    userId?: SortOrder
  }

  export type UserClientMaxOrderByAggregateInput = {
    clientId?: SortOrder
    userId?: SortOrder
  }

  export type UserClientMinOrderByAggregateInput = {
    clientId?: SortOrder
    userId?: SortOrder
  }

  export type DistributorRelationFilter = {
    is?: DistributorWhereInput
    isNot?: DistributorWhereInput
  }

  export type DistributorCompanyDistributorIdCompanyIdCompoundUniqueInput = {
    distributorId: string
    companyId: string
  }

  export type DistributorCompanyCountOrderByAggregateInput = {
    distributorId?: SortOrder
    companyId?: SortOrder
  }

  export type DistributorCompanyMaxOrderByAggregateInput = {
    distributorId?: SortOrder
    companyId?: SortOrder
  }

  export type DistributorCompanyMinOrderByAggregateInput = {
    distributorId?: SortOrder
    companyId?: SortOrder
  }

  export type VariantSizeBarcodeVariantIdSizeCompoundUniqueInput = {
    variantId: string
    size: string
  }

  export type VariantSizeBarcodeCountOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    size?: SortOrder
    barcode?: SortOrder
  }

  export type VariantSizeBarcodeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VariantSizeBarcodeMaxOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    size?: SortOrder
    barcode?: SortOrder
  }

  export type VariantSizeBarcodeMinOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    size?: SortOrder
    barcode?: SortOrder
  }

  export type VariantSizeBarcodeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailOtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailOtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailOtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionPath?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type CompanyUserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type CompanyClientCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyClientCreateWithoutCompanyInput, CompanyClientUncheckedCreateWithoutCompanyInput> | CompanyClientCreateWithoutCompanyInput[] | CompanyClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutCompanyInput | CompanyClientCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyClientCreateManyCompanyInputEnvelope
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CategoryCreateWithoutCompanyInput, CategoryUncheckedCreateWithoutCompanyInput> | CategoryCreateWithoutCompanyInput[] | CategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCompanyInput | CategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: CategoryCreateManyCompanyInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type SubcategoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SubcategoryCreateWithoutCompanyInput, SubcategoryUncheckedCreateWithoutCompanyInput> | SubcategoryCreateWithoutCompanyInput[] | SubcategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCompanyInput | SubcategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: SubcategoryCreateManyCompanyInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type BillCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BillCreateWithoutCompanyInput, BillUncheckedCreateWithoutCompanyInput> | BillCreateWithoutCompanyInput[] | BillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCompanyInput | BillCreateOrConnectWithoutCompanyInput[]
    createMany?: BillCreateManyCompanyInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type TokenEntryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TokenEntryCreateWithoutCompanyInput, TokenEntryUncheckedCreateWithoutCompanyInput> | TokenEntryCreateWithoutCompanyInput[] | TokenEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TokenEntryCreateOrConnectWithoutCompanyInput | TokenEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: TokenEntryCreateManyCompanyInputEnvelope
    connect?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ExpenseCategoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type VariantCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VariantCreateWithoutCompanyInput, VariantUncheckedCreateWithoutCompanyInput> | VariantCreateWithoutCompanyInput[] | VariantUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutCompanyInput | VariantCreateOrConnectWithoutCompanyInput[]
    createMany?: VariantCreateManyCompanyInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemCreateWithoutCompanyInput, ItemUncheckedCreateWithoutCompanyInput> | ItemCreateWithoutCompanyInput[] | ItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCompanyInput | ItemCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemCreateManyCompanyInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type PipelineCreateNestedOneWithoutCompanyInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput
    connect?: PipelineWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<NotificationCreateWithoutCompanyInput, NotificationUncheckedCreateWithoutCompanyInput> | NotificationCreateWithoutCompanyInput[] | NotificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCompanyInput | NotificationCreateOrConnectWithoutCompanyInput[]
    createMany?: NotificationCreateManyCompanyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AddressCreateNestedOneWithoutCompanyInput = {
    create?: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompanyInput
    connect?: AddressWhereUniqueInput
  }

  export type DistributorCompanyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DistributorCompanyCreateWithoutCompanyInput, DistributorCompanyUncheckedCreateWithoutCompanyInput> | DistributorCompanyCreateWithoutCompanyInput[] | DistributorCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutCompanyInput | DistributorCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: DistributorCompanyCreateManyCompanyInputEnvelope
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type CompanyClientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyClientCreateWithoutCompanyInput, CompanyClientUncheckedCreateWithoutCompanyInput> | CompanyClientCreateWithoutCompanyInput[] | CompanyClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutCompanyInput | CompanyClientCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyClientCreateManyCompanyInputEnvelope
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CategoryCreateWithoutCompanyInput, CategoryUncheckedCreateWithoutCompanyInput> | CategoryCreateWithoutCompanyInput[] | CategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCompanyInput | CategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: CategoryCreateManyCompanyInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type SubcategoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SubcategoryCreateWithoutCompanyInput, SubcategoryUncheckedCreateWithoutCompanyInput> | SubcategoryCreateWithoutCompanyInput[] | SubcategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCompanyInput | SubcategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: SubcategoryCreateManyCompanyInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BillCreateWithoutCompanyInput, BillUncheckedCreateWithoutCompanyInput> | BillCreateWithoutCompanyInput[] | BillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCompanyInput | BillCreateOrConnectWithoutCompanyInput[]
    createMany?: BillCreateManyCompanyInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type TokenEntryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TokenEntryCreateWithoutCompanyInput, TokenEntryUncheckedCreateWithoutCompanyInput> | TokenEntryCreateWithoutCompanyInput[] | TokenEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TokenEntryCreateOrConnectWithoutCompanyInput | TokenEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: TokenEntryCreateManyCompanyInputEnvelope
    connect?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type VariantUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VariantCreateWithoutCompanyInput, VariantUncheckedCreateWithoutCompanyInput> | VariantCreateWithoutCompanyInput[] | VariantUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutCompanyInput | VariantCreateOrConnectWithoutCompanyInput[]
    createMany?: VariantCreateManyCompanyInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemCreateWithoutCompanyInput, ItemUncheckedCreateWithoutCompanyInput> | ItemCreateWithoutCompanyInput[] | ItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCompanyInput | ItemCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemCreateManyCompanyInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedOneWithoutCompanyInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput
    connect?: PipelineWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<NotificationCreateWithoutCompanyInput, NotificationUncheckedCreateWithoutCompanyInput> | NotificationCreateWithoutCompanyInput[] | NotificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCompanyInput | NotificationCreateOrConnectWithoutCompanyInput[]
    createMany?: NotificationCreateManyCompanyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutCompanyInput = {
    create?: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompanyInput
    connect?: AddressWhereUniqueInput
  }

  export type DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DistributorCompanyCreateWithoutCompanyInput, DistributorCompanyUncheckedCreateWithoutCompanyInput> | DistributorCompanyCreateWithoutCompanyInput[] | DistributorCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutCompanyInput | DistributorCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: DistributorCompanyCreateManyCompanyInputEnvelope
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumCompanyTypeFieldUpdateOperationsInput = {
    set?: $Enums.CompanyType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type CompanyClientUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyClientCreateWithoutCompanyInput, CompanyClientUncheckedCreateWithoutCompanyInput> | CompanyClientCreateWithoutCompanyInput[] | CompanyClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutCompanyInput | CompanyClientCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyClientUpsertWithWhereUniqueWithoutCompanyInput | CompanyClientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyClientCreateManyCompanyInputEnvelope
    set?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    disconnect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    delete?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    update?: CompanyClientUpdateWithWhereUniqueWithoutCompanyInput | CompanyClientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyClientUpdateManyWithWhereWithoutCompanyInput | CompanyClientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyClientScalarWhereInput | CompanyClientScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCompanyInput | ProductUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCompanyInput | ProductUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCompanyInput | ProductUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CategoryCreateWithoutCompanyInput, CategoryUncheckedCreateWithoutCompanyInput> | CategoryCreateWithoutCompanyInput[] | CategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCompanyInput | CategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCompanyInput | CategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CategoryCreateManyCompanyInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCompanyInput | CategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCompanyInput | CategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type SubcategoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCompanyInput, SubcategoryUncheckedCreateWithoutCompanyInput> | SubcategoryCreateWithoutCompanyInput[] | SubcategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCompanyInput | SubcategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCompanyInput | SubcategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SubcategoryCreateManyCompanyInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCompanyInput | SubcategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCompanyInput | SubcategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type BillUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BillCreateWithoutCompanyInput, BillUncheckedCreateWithoutCompanyInput> | BillCreateWithoutCompanyInput[] | BillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCompanyInput | BillCreateOrConnectWithoutCompanyInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutCompanyInput | BillUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BillCreateManyCompanyInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutCompanyInput | BillUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BillUpdateManyWithWhereWithoutCompanyInput | BillUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type TokenEntryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TokenEntryCreateWithoutCompanyInput, TokenEntryUncheckedCreateWithoutCompanyInput> | TokenEntryCreateWithoutCompanyInput[] | TokenEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TokenEntryCreateOrConnectWithoutCompanyInput | TokenEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: TokenEntryUpsertWithWhereUniqueWithoutCompanyInput | TokenEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TokenEntryCreateManyCompanyInputEnvelope
    set?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    disconnect?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    delete?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    connect?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    update?: TokenEntryUpdateWithWhereUniqueWithoutCompanyInput | TokenEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TokenEntryUpdateManyWithWhereWithoutCompanyInput | TokenEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TokenEntryScalarWhereInput | TokenEntryScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ExpenseCategoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput | ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCompanyInput | ExpenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCompanyInput | ExpenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCompanyInput | ExpenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type VariantUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VariantCreateWithoutCompanyInput, VariantUncheckedCreateWithoutCompanyInput> | VariantCreateWithoutCompanyInput[] | VariantUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutCompanyInput | VariantCreateOrConnectWithoutCompanyInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutCompanyInput | VariantUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VariantCreateManyCompanyInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutCompanyInput | VariantUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutCompanyInput | VariantUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemCreateWithoutCompanyInput, ItemUncheckedCreateWithoutCompanyInput> | ItemCreateWithoutCompanyInput[] | ItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCompanyInput | ItemCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCompanyInput | ItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemCreateManyCompanyInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCompanyInput | ItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCompanyInput | ItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type PipelineUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput
    upsert?: PipelineUpsertWithoutCompanyInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutCompanyInput, PipelineUpdateWithoutCompanyInput>, PipelineUncheckedUpdateWithoutCompanyInput>
  }

  export type NotificationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<NotificationCreateWithoutCompanyInput, NotificationUncheckedCreateWithoutCompanyInput> | NotificationCreateWithoutCompanyInput[] | NotificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCompanyInput | NotificationCreateOrConnectWithoutCompanyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCompanyInput | NotificationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: NotificationCreateManyCompanyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCompanyInput | NotificationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCompanyInput | NotificationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AddressUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompanyInput
    upsert?: AddressUpsertWithoutCompanyInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutCompanyInput, AddressUpdateWithoutCompanyInput>, AddressUncheckedUpdateWithoutCompanyInput>
  }

  export type DistributorCompanyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DistributorCompanyCreateWithoutCompanyInput, DistributorCompanyUncheckedCreateWithoutCompanyInput> | DistributorCompanyCreateWithoutCompanyInput[] | DistributorCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutCompanyInput | DistributorCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: DistributorCompanyUpsertWithWhereUniqueWithoutCompanyInput | DistributorCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DistributorCompanyCreateManyCompanyInputEnvelope
    set?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    disconnect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    delete?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    update?: DistributorCompanyUpdateWithWhereUniqueWithoutCompanyInput | DistributorCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DistributorCompanyUpdateManyWithWhereWithoutCompanyInput | DistributorCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DistributorCompanyScalarWhereInput | DistributorCompanyScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyClientCreateWithoutCompanyInput, CompanyClientUncheckedCreateWithoutCompanyInput> | CompanyClientCreateWithoutCompanyInput[] | CompanyClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutCompanyInput | CompanyClientCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyClientUpsertWithWhereUniqueWithoutCompanyInput | CompanyClientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyClientCreateManyCompanyInputEnvelope
    set?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    disconnect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    delete?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    update?: CompanyClientUpdateWithWhereUniqueWithoutCompanyInput | CompanyClientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyClientUpdateManyWithWhereWithoutCompanyInput | CompanyClientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyClientScalarWhereInput | CompanyClientScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCompanyInput | ProductUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCompanyInput | ProductUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCompanyInput | ProductUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CategoryCreateWithoutCompanyInput, CategoryUncheckedCreateWithoutCompanyInput> | CategoryCreateWithoutCompanyInput[] | CategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCompanyInput | CategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCompanyInput | CategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CategoryCreateManyCompanyInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCompanyInput | CategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCompanyInput | CategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCompanyInput, SubcategoryUncheckedCreateWithoutCompanyInput> | SubcategoryCreateWithoutCompanyInput[] | SubcategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCompanyInput | SubcategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCompanyInput | SubcategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SubcategoryCreateManyCompanyInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCompanyInput | SubcategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCompanyInput | SubcategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BillCreateWithoutCompanyInput, BillUncheckedCreateWithoutCompanyInput> | BillCreateWithoutCompanyInput[] | BillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCompanyInput | BillCreateOrConnectWithoutCompanyInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutCompanyInput | BillUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BillCreateManyCompanyInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutCompanyInput | BillUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BillUpdateManyWithWhereWithoutCompanyInput | BillUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TokenEntryCreateWithoutCompanyInput, TokenEntryUncheckedCreateWithoutCompanyInput> | TokenEntryCreateWithoutCompanyInput[] | TokenEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TokenEntryCreateOrConnectWithoutCompanyInput | TokenEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: TokenEntryUpsertWithWhereUniqueWithoutCompanyInput | TokenEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TokenEntryCreateManyCompanyInputEnvelope
    set?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    disconnect?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    delete?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    connect?: TokenEntryWhereUniqueInput | TokenEntryWhereUniqueInput[]
    update?: TokenEntryUpdateWithWhereUniqueWithoutCompanyInput | TokenEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TokenEntryUpdateManyWithWhereWithoutCompanyInput | TokenEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TokenEntryScalarWhereInput | TokenEntryScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput | ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCompanyInput | ExpenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCompanyInput | ExpenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCompanyInput | ExpenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type VariantUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VariantCreateWithoutCompanyInput, VariantUncheckedCreateWithoutCompanyInput> | VariantCreateWithoutCompanyInput[] | VariantUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutCompanyInput | VariantCreateOrConnectWithoutCompanyInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutCompanyInput | VariantUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VariantCreateManyCompanyInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutCompanyInput | VariantUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutCompanyInput | VariantUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemCreateWithoutCompanyInput, ItemUncheckedCreateWithoutCompanyInput> | ItemCreateWithoutCompanyInput[] | ItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCompanyInput | ItemCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCompanyInput | ItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemCreateManyCompanyInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCompanyInput | ItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCompanyInput | ItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput
    upsert?: PipelineUpsertWithoutCompanyInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutCompanyInput, PipelineUpdateWithoutCompanyInput>, PipelineUncheckedUpdateWithoutCompanyInput>
  }

  export type NotificationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<NotificationCreateWithoutCompanyInput, NotificationUncheckedCreateWithoutCompanyInput> | NotificationCreateWithoutCompanyInput[] | NotificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCompanyInput | NotificationCreateOrConnectWithoutCompanyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCompanyInput | NotificationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: NotificationCreateManyCompanyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCompanyInput | NotificationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCompanyInput | NotificationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompanyInput
    upsert?: AddressUpsertWithoutCompanyInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutCompanyInput, AddressUpdateWithoutCompanyInput>, AddressUncheckedUpdateWithoutCompanyInput>
  }

  export type DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DistributorCompanyCreateWithoutCompanyInput, DistributorCompanyUncheckedCreateWithoutCompanyInput> | DistributorCompanyCreateWithoutCompanyInput[] | DistributorCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutCompanyInput | DistributorCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: DistributorCompanyUpsertWithWhereUniqueWithoutCompanyInput | DistributorCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DistributorCompanyCreateManyCompanyInputEnvelope
    set?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    disconnect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    delete?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    update?: DistributorCompanyUpdateWithWhereUniqueWithoutCompanyInput | DistributorCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DistributorCompanyUpdateManyWithWhereWithoutCompanyInput | DistributorCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DistributorCompanyScalarWhereInput | DistributorCompanyScalarWhereInput[]
  }

  export type DistributorCompanyCreateNestedManyWithoutDistributorInput = {
    create?: XOR<DistributorCompanyCreateWithoutDistributorInput, DistributorCompanyUncheckedCreateWithoutDistributorInput> | DistributorCompanyCreateWithoutDistributorInput[] | DistributorCompanyUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutDistributorInput | DistributorCompanyCreateOrConnectWithoutDistributorInput[]
    createMany?: DistributorCompanyCreateManyDistributorInputEnvelope
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutDistributorInput = {
    create?: XOR<PurchaseOrderCreateWithoutDistributorInput, PurchaseOrderUncheckedCreateWithoutDistributorInput> | PurchaseOrderCreateWithoutDistributorInput[] | PurchaseOrderUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDistributorInput | PurchaseOrderCreateOrConnectWithoutDistributorInput[]
    createMany?: PurchaseOrderCreateManyDistributorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type AddressCreateNestedOneWithoutDistributorInput = {
    create?: XOR<AddressCreateWithoutDistributorInput, AddressUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: AddressCreateOrConnectWithoutDistributorInput
    connect?: AddressWhereUniqueInput
  }

  export type DistributorCompanyUncheckedCreateNestedManyWithoutDistributorInput = {
    create?: XOR<DistributorCompanyCreateWithoutDistributorInput, DistributorCompanyUncheckedCreateWithoutDistributorInput> | DistributorCompanyCreateWithoutDistributorInput[] | DistributorCompanyUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutDistributorInput | DistributorCompanyCreateOrConnectWithoutDistributorInput[]
    createMany?: DistributorCompanyCreateManyDistributorInputEnvelope
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutDistributorInput = {
    create?: XOR<PurchaseOrderCreateWithoutDistributorInput, PurchaseOrderUncheckedCreateWithoutDistributorInput> | PurchaseOrderCreateWithoutDistributorInput[] | PurchaseOrderUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDistributorInput | PurchaseOrderCreateOrConnectWithoutDistributorInput[]
    createMany?: PurchaseOrderCreateManyDistributorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutDistributorInput = {
    create?: XOR<AddressCreateWithoutDistributorInput, AddressUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: AddressCreateOrConnectWithoutDistributorInput
    connect?: AddressWhereUniqueInput
  }

  export type DistributorCompanyUpdateManyWithoutDistributorNestedInput = {
    create?: XOR<DistributorCompanyCreateWithoutDistributorInput, DistributorCompanyUncheckedCreateWithoutDistributorInput> | DistributorCompanyCreateWithoutDistributorInput[] | DistributorCompanyUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutDistributorInput | DistributorCompanyCreateOrConnectWithoutDistributorInput[]
    upsert?: DistributorCompanyUpsertWithWhereUniqueWithoutDistributorInput | DistributorCompanyUpsertWithWhereUniqueWithoutDistributorInput[]
    createMany?: DistributorCompanyCreateManyDistributorInputEnvelope
    set?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    disconnect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    delete?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    update?: DistributorCompanyUpdateWithWhereUniqueWithoutDistributorInput | DistributorCompanyUpdateWithWhereUniqueWithoutDistributorInput[]
    updateMany?: DistributorCompanyUpdateManyWithWhereWithoutDistributorInput | DistributorCompanyUpdateManyWithWhereWithoutDistributorInput[]
    deleteMany?: DistributorCompanyScalarWhereInput | DistributorCompanyScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutDistributorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutDistributorInput, PurchaseOrderUncheckedCreateWithoutDistributorInput> | PurchaseOrderCreateWithoutDistributorInput[] | PurchaseOrderUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDistributorInput | PurchaseOrderCreateOrConnectWithoutDistributorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutDistributorInput | PurchaseOrderUpsertWithWhereUniqueWithoutDistributorInput[]
    createMany?: PurchaseOrderCreateManyDistributorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutDistributorInput | PurchaseOrderUpdateWithWhereUniqueWithoutDistributorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutDistributorInput | PurchaseOrderUpdateManyWithWhereWithoutDistributorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type AddressUpdateOneWithoutDistributorNestedInput = {
    create?: XOR<AddressCreateWithoutDistributorInput, AddressUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: AddressCreateOrConnectWithoutDistributorInput
    upsert?: AddressUpsertWithoutDistributorInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutDistributorInput, AddressUpdateWithoutDistributorInput>, AddressUncheckedUpdateWithoutDistributorInput>
  }

  export type DistributorCompanyUncheckedUpdateManyWithoutDistributorNestedInput = {
    create?: XOR<DistributorCompanyCreateWithoutDistributorInput, DistributorCompanyUncheckedCreateWithoutDistributorInput> | DistributorCompanyCreateWithoutDistributorInput[] | DistributorCompanyUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: DistributorCompanyCreateOrConnectWithoutDistributorInput | DistributorCompanyCreateOrConnectWithoutDistributorInput[]
    upsert?: DistributorCompanyUpsertWithWhereUniqueWithoutDistributorInput | DistributorCompanyUpsertWithWhereUniqueWithoutDistributorInput[]
    createMany?: DistributorCompanyCreateManyDistributorInputEnvelope
    set?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    disconnect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    delete?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    connect?: DistributorCompanyWhereUniqueInput | DistributorCompanyWhereUniqueInput[]
    update?: DistributorCompanyUpdateWithWhereUniqueWithoutDistributorInput | DistributorCompanyUpdateWithWhereUniqueWithoutDistributorInput[]
    updateMany?: DistributorCompanyUpdateManyWithWhereWithoutDistributorInput | DistributorCompanyUpdateManyWithWhereWithoutDistributorInput[]
    deleteMany?: DistributorCompanyScalarWhereInput | DistributorCompanyScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutDistributorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutDistributorInput, PurchaseOrderUncheckedCreateWithoutDistributorInput> | PurchaseOrderCreateWithoutDistributorInput[] | PurchaseOrderUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDistributorInput | PurchaseOrderCreateOrConnectWithoutDistributorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutDistributorInput | PurchaseOrderUpsertWithWhereUniqueWithoutDistributorInput[]
    createMany?: PurchaseOrderCreateManyDistributorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutDistributorInput | PurchaseOrderUpdateWithWhereUniqueWithoutDistributorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutDistributorInput | PurchaseOrderUpdateManyWithWhereWithoutDistributorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutDistributorNestedInput = {
    create?: XOR<AddressCreateWithoutDistributorInput, AddressUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: AddressCreateOrConnectWithoutDistributorInput
    upsert?: AddressUpsertWithoutDistributorInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutDistributorInput, AddressUpdateWithoutDistributorInput>, AddressUncheckedUpdateWithoutDistributorInput>
  }

  export type CompanyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type AddressCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConversationCreateWithoutUserInput, UserConversationUncheckedCreateWithoutUserInput> | UserConversationCreateWithoutUserInput[] | UserConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutUserInput | UserConversationCreateOrConnectWithoutUserInput[]
    createMany?: UserConversationCreateManyUserInputEnvelope
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
  }

  export type UserClientCreateNestedManyWithoutUserInput = {
    create?: XOR<UserClientCreateWithoutUserInput, UserClientUncheckedCreateWithoutUserInput> | UserClientCreateWithoutUserInput[] | UserClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutUserInput | UserClientCreateOrConnectWithoutUserInput[]
    createMany?: UserClientCreateManyUserInputEnvelope
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConversationCreateWithoutUserInput, UserConversationUncheckedCreateWithoutUserInput> | UserConversationCreateWithoutUserInput[] | UserConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutUserInput | UserConversationCreateOrConnectWithoutUserInput[]
    createMany?: UserConversationCreateManyUserInputEnvelope
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
  }

  export type UserClientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserClientCreateWithoutUserInput, UserClientUncheckedCreateWithoutUserInput> | UserClientCreateWithoutUserInput[] | UserClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutUserInput | UserClientCreateOrConnectWithoutUserInput[]
    createMany?: UserClientCreateManyUserInputEnvelope
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type CompanyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type AddressUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserInput, AddressUpdateWithoutUserInput>, AddressUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConversationCreateWithoutUserInput, UserConversationUncheckedCreateWithoutUserInput> | UserConversationCreateWithoutUserInput[] | UserConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutUserInput | UserConversationCreateOrConnectWithoutUserInput[]
    upsert?: UserConversationUpsertWithWhereUniqueWithoutUserInput | UserConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConversationCreateManyUserInputEnvelope
    set?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    disconnect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    delete?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    update?: UserConversationUpdateWithWhereUniqueWithoutUserInput | UserConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConversationUpdateManyWithWhereWithoutUserInput | UserConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConversationScalarWhereInput | UserConversationScalarWhereInput[]
  }

  export type UserClientUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserClientCreateWithoutUserInput, UserClientUncheckedCreateWithoutUserInput> | UserClientCreateWithoutUserInput[] | UserClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutUserInput | UserClientCreateOrConnectWithoutUserInput[]
    upsert?: UserClientUpsertWithWhereUniqueWithoutUserInput | UserClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserClientCreateManyUserInputEnvelope
    set?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    disconnect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    delete?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    update?: UserClientUpdateWithWhereUniqueWithoutUserInput | UserClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserClientUpdateManyWithWhereWithoutUserInput | UserClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserClientScalarWhereInput | UserClientScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserInput, AddressUpdateWithoutUserInput>, AddressUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConversationCreateWithoutUserInput, UserConversationUncheckedCreateWithoutUserInput> | UserConversationCreateWithoutUserInput[] | UserConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutUserInput | UserConversationCreateOrConnectWithoutUserInput[]
    upsert?: UserConversationUpsertWithWhereUniqueWithoutUserInput | UserConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConversationCreateManyUserInputEnvelope
    set?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    disconnect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    delete?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    update?: UserConversationUpdateWithWhereUniqueWithoutUserInput | UserConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConversationUpdateManyWithWhereWithoutUserInput | UserConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConversationScalarWhereInput | UserConversationScalarWhereInput[]
  }

  export type UserClientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserClientCreateWithoutUserInput, UserClientUncheckedCreateWithoutUserInput> | UserClientCreateWithoutUserInput[] | UserClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutUserInput | UserClientCreateOrConnectWithoutUserInput[]
    upsert?: UserClientUpsertWithWhereUniqueWithoutUserInput | UserClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserClientCreateManyUserInputEnvelope
    set?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    disconnect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    delete?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    update?: UserClientUpdateWithWhereUniqueWithoutUserInput | UserClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserClientUpdateManyWithWhereWithoutUserInput | UserClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserClientScalarWhereInput | UserClientScalarWhereInput[]
  }

  export type CompanyClientCreateNestedManyWithoutClientInput = {
    create?: XOR<CompanyClientCreateWithoutClientInput, CompanyClientUncheckedCreateWithoutClientInput> | CompanyClientCreateWithoutClientInput[] | CompanyClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutClientInput | CompanyClientCreateOrConnectWithoutClientInput[]
    createMany?: CompanyClientCreateManyClientInputEnvelope
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutClientInput = {
    create?: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput> | AddressCreateWithoutClientInput[] | AddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutClientInput | AddressCreateOrConnectWithoutClientInput[]
    createMany?: AddressCreateManyClientInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type BillCreateNestedOneWithoutClientInput = {
    create?: XOR<BillCreateWithoutClientInput, BillUncheckedCreateWithoutClientInput>
    connectOrCreate?: BillCreateOrConnectWithoutClientInput
    connect?: BillWhereUniqueInput
  }

  export type ClientConversationCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientConversationCreateWithoutClientInput, ClientConversationUncheckedCreateWithoutClientInput> | ClientConversationCreateWithoutClientInput[] | ClientConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutClientInput | ClientConversationCreateOrConnectWithoutClientInput[]
    createMany?: ClientConversationCreateManyClientInputEnvelope
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
  }

  export type UserClientCreateNestedManyWithoutClientInput = {
    create?: XOR<UserClientCreateWithoutClientInput, UserClientUncheckedCreateWithoutClientInput> | UserClientCreateWithoutClientInput[] | UserClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutClientInput | UserClientCreateOrConnectWithoutClientInput[]
    createMany?: UserClientCreateManyClientInputEnvelope
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
  }

  export type PipelineCreateNestedOneWithoutNewClientsInput = {
    create?: XOR<PipelineCreateWithoutNewClientsInput, PipelineUncheckedCreateWithoutNewClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutNewClientsInput
    connect?: PipelineWhereUniqueInput
  }

  export type PipelineCreateNestedOneWithoutProspectClientsInput = {
    create?: XOR<PipelineCreateWithoutProspectClientsInput, PipelineUncheckedCreateWithoutProspectClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutProspectClientsInput
    connect?: PipelineWhereUniqueInput
  }

  export type PipelineCreateNestedOneWithoutViewingClientsInput = {
    create?: XOR<PipelineCreateWithoutViewingClientsInput, PipelineUncheckedCreateWithoutViewingClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutViewingClientsInput
    connect?: PipelineWhereUniqueInput
  }

  export type PipelineCreateNestedOneWithoutRejectClientsInput = {
    create?: XOR<PipelineCreateWithoutRejectClientsInput, PipelineUncheckedCreateWithoutRejectClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutRejectClientsInput
    connect?: PipelineWhereUniqueInput
  }

  export type PipelineCreateNestedOneWithoutCloseClientsInput = {
    create?: XOR<PipelineCreateWithoutCloseClientsInput, PipelineUncheckedCreateWithoutCloseClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutCloseClientsInput
    connect?: PipelineWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutClientInput = {
    create?: XOR<NotificationCreateWithoutClientInput, NotificationUncheckedCreateWithoutClientInput> | NotificationCreateWithoutClientInput[] | NotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientInput | NotificationCreateOrConnectWithoutClientInput[]
    createMany?: NotificationCreateManyClientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CompanyClientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CompanyClientCreateWithoutClientInput, CompanyClientUncheckedCreateWithoutClientInput> | CompanyClientCreateWithoutClientInput[] | CompanyClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutClientInput | CompanyClientCreateOrConnectWithoutClientInput[]
    createMany?: CompanyClientCreateManyClientInputEnvelope
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput> | AddressCreateWithoutClientInput[] | AddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutClientInput | AddressCreateOrConnectWithoutClientInput[]
    createMany?: AddressCreateManyClientInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedOneWithoutClientInput = {
    create?: XOR<BillCreateWithoutClientInput, BillUncheckedCreateWithoutClientInput>
    connectOrCreate?: BillCreateOrConnectWithoutClientInput
    connect?: BillWhereUniqueInput
  }

  export type ClientConversationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientConversationCreateWithoutClientInput, ClientConversationUncheckedCreateWithoutClientInput> | ClientConversationCreateWithoutClientInput[] | ClientConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutClientInput | ClientConversationCreateOrConnectWithoutClientInput[]
    createMany?: ClientConversationCreateManyClientInputEnvelope
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
  }

  export type UserClientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserClientCreateWithoutClientInput, UserClientUncheckedCreateWithoutClientInput> | UserClientCreateWithoutClientInput[] | UserClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutClientInput | UserClientCreateOrConnectWithoutClientInput[]
    createMany?: UserClientCreateManyClientInputEnvelope
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<NotificationCreateWithoutClientInput, NotificationUncheckedCreateWithoutClientInput> | NotificationCreateWithoutClientInput[] | NotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientInput | NotificationCreateOrConnectWithoutClientInput[]
    createMany?: NotificationCreateManyClientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CompanyClientUpdateManyWithoutClientNestedInput = {
    create?: XOR<CompanyClientCreateWithoutClientInput, CompanyClientUncheckedCreateWithoutClientInput> | CompanyClientCreateWithoutClientInput[] | CompanyClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutClientInput | CompanyClientCreateOrConnectWithoutClientInput[]
    upsert?: CompanyClientUpsertWithWhereUniqueWithoutClientInput | CompanyClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CompanyClientCreateManyClientInputEnvelope
    set?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    disconnect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    delete?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    update?: CompanyClientUpdateWithWhereUniqueWithoutClientInput | CompanyClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CompanyClientUpdateManyWithWhereWithoutClientInput | CompanyClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CompanyClientScalarWhereInput | CompanyClientScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutClientNestedInput = {
    create?: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput> | AddressCreateWithoutClientInput[] | AddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutClientInput | AddressCreateOrConnectWithoutClientInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutClientInput | AddressUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AddressCreateManyClientInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutClientInput | AddressUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutClientInput | AddressUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type BillUpdateOneWithoutClientNestedInput = {
    create?: XOR<BillCreateWithoutClientInput, BillUncheckedCreateWithoutClientInput>
    connectOrCreate?: BillCreateOrConnectWithoutClientInput
    upsert?: BillUpsertWithoutClientInput
    disconnect?: BillWhereInput | boolean
    delete?: BillWhereInput | boolean
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutClientInput, BillUpdateWithoutClientInput>, BillUncheckedUpdateWithoutClientInput>
  }

  export type ClientConversationUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientConversationCreateWithoutClientInput, ClientConversationUncheckedCreateWithoutClientInput> | ClientConversationCreateWithoutClientInput[] | ClientConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutClientInput | ClientConversationCreateOrConnectWithoutClientInput[]
    upsert?: ClientConversationUpsertWithWhereUniqueWithoutClientInput | ClientConversationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientConversationCreateManyClientInputEnvelope
    set?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    disconnect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    delete?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    update?: ClientConversationUpdateWithWhereUniqueWithoutClientInput | ClientConversationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientConversationUpdateManyWithWhereWithoutClientInput | ClientConversationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientConversationScalarWhereInput | ClientConversationScalarWhereInput[]
  }

  export type UserClientUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserClientCreateWithoutClientInput, UserClientUncheckedCreateWithoutClientInput> | UserClientCreateWithoutClientInput[] | UserClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutClientInput | UserClientCreateOrConnectWithoutClientInput[]
    upsert?: UserClientUpsertWithWhereUniqueWithoutClientInput | UserClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserClientCreateManyClientInputEnvelope
    set?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    disconnect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    delete?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    update?: UserClientUpdateWithWhereUniqueWithoutClientInput | UserClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserClientUpdateManyWithWhereWithoutClientInput | UserClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserClientScalarWhereInput | UserClientScalarWhereInput[]
  }

  export type PipelineUpdateOneWithoutNewClientsNestedInput = {
    create?: XOR<PipelineCreateWithoutNewClientsInput, PipelineUncheckedCreateWithoutNewClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutNewClientsInput
    upsert?: PipelineUpsertWithoutNewClientsInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutNewClientsInput, PipelineUpdateWithoutNewClientsInput>, PipelineUncheckedUpdateWithoutNewClientsInput>
  }

  export type PipelineUpdateOneWithoutProspectClientsNestedInput = {
    create?: XOR<PipelineCreateWithoutProspectClientsInput, PipelineUncheckedCreateWithoutProspectClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutProspectClientsInput
    upsert?: PipelineUpsertWithoutProspectClientsInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutProspectClientsInput, PipelineUpdateWithoutProspectClientsInput>, PipelineUncheckedUpdateWithoutProspectClientsInput>
  }

  export type PipelineUpdateOneWithoutViewingClientsNestedInput = {
    create?: XOR<PipelineCreateWithoutViewingClientsInput, PipelineUncheckedCreateWithoutViewingClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutViewingClientsInput
    upsert?: PipelineUpsertWithoutViewingClientsInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutViewingClientsInput, PipelineUpdateWithoutViewingClientsInput>, PipelineUncheckedUpdateWithoutViewingClientsInput>
  }

  export type PipelineUpdateOneWithoutRejectClientsNestedInput = {
    create?: XOR<PipelineCreateWithoutRejectClientsInput, PipelineUncheckedCreateWithoutRejectClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutRejectClientsInput
    upsert?: PipelineUpsertWithoutRejectClientsInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutRejectClientsInput, PipelineUpdateWithoutRejectClientsInput>, PipelineUncheckedUpdateWithoutRejectClientsInput>
  }

  export type PipelineUpdateOneWithoutCloseClientsNestedInput = {
    create?: XOR<PipelineCreateWithoutCloseClientsInput, PipelineUncheckedCreateWithoutCloseClientsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutCloseClientsInput
    upsert?: PipelineUpsertWithoutCloseClientsInput
    disconnect?: PipelineWhereInput | boolean
    delete?: PipelineWhereInput | boolean
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutCloseClientsInput, PipelineUpdateWithoutCloseClientsInput>, PipelineUncheckedUpdateWithoutCloseClientsInput>
  }

  export type NotificationUpdateManyWithoutClientNestedInput = {
    create?: XOR<NotificationCreateWithoutClientInput, NotificationUncheckedCreateWithoutClientInput> | NotificationCreateWithoutClientInput[] | NotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientInput | NotificationCreateOrConnectWithoutClientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutClientInput | NotificationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: NotificationCreateManyClientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutClientInput | NotificationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutClientInput | NotificationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CompanyClientUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CompanyClientCreateWithoutClientInput, CompanyClientUncheckedCreateWithoutClientInput> | CompanyClientCreateWithoutClientInput[] | CompanyClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CompanyClientCreateOrConnectWithoutClientInput | CompanyClientCreateOrConnectWithoutClientInput[]
    upsert?: CompanyClientUpsertWithWhereUniqueWithoutClientInput | CompanyClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CompanyClientCreateManyClientInputEnvelope
    set?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    disconnect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    delete?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    connect?: CompanyClientWhereUniqueInput | CompanyClientWhereUniqueInput[]
    update?: CompanyClientUpdateWithWhereUniqueWithoutClientInput | CompanyClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CompanyClientUpdateManyWithWhereWithoutClientInput | CompanyClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CompanyClientScalarWhereInput | CompanyClientScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput> | AddressCreateWithoutClientInput[] | AddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutClientInput | AddressCreateOrConnectWithoutClientInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutClientInput | AddressUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AddressCreateManyClientInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutClientInput | AddressUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutClientInput | AddressUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type BillUncheckedUpdateOneWithoutClientNestedInput = {
    create?: XOR<BillCreateWithoutClientInput, BillUncheckedCreateWithoutClientInput>
    connectOrCreate?: BillCreateOrConnectWithoutClientInput
    upsert?: BillUpsertWithoutClientInput
    disconnect?: BillWhereInput | boolean
    delete?: BillWhereInput | boolean
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutClientInput, BillUpdateWithoutClientInput>, BillUncheckedUpdateWithoutClientInput>
  }

  export type ClientConversationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientConversationCreateWithoutClientInput, ClientConversationUncheckedCreateWithoutClientInput> | ClientConversationCreateWithoutClientInput[] | ClientConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutClientInput | ClientConversationCreateOrConnectWithoutClientInput[]
    upsert?: ClientConversationUpsertWithWhereUniqueWithoutClientInput | ClientConversationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientConversationCreateManyClientInputEnvelope
    set?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    disconnect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    delete?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    update?: ClientConversationUpdateWithWhereUniqueWithoutClientInput | ClientConversationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientConversationUpdateManyWithWhereWithoutClientInput | ClientConversationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientConversationScalarWhereInput | ClientConversationScalarWhereInput[]
  }

  export type UserClientUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserClientCreateWithoutClientInput, UserClientUncheckedCreateWithoutClientInput> | UserClientCreateWithoutClientInput[] | UserClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserClientCreateOrConnectWithoutClientInput | UserClientCreateOrConnectWithoutClientInput[]
    upsert?: UserClientUpsertWithWhereUniqueWithoutClientInput | UserClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserClientCreateManyClientInputEnvelope
    set?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    disconnect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    delete?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    connect?: UserClientWhereUniqueInput | UserClientWhereUniqueInput[]
    update?: UserClientUpdateWithWhereUniqueWithoutClientInput | UserClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserClientUpdateManyWithWhereWithoutClientInput | UserClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserClientScalarWhereInput | UserClientScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<NotificationCreateWithoutClientInput, NotificationUncheckedCreateWithoutClientInput> | NotificationCreateWithoutClientInput[] | NotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientInput | NotificationCreateOrConnectWithoutClientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutClientInput | NotificationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: NotificationCreateManyClientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutClientInput | NotificationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutClientInput | NotificationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPipelineInput = {
    create?: XOR<CompanyCreateWithoutPipelineInput, CompanyUncheckedCreateWithoutPipelineInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPipelineInput
    connect?: CompanyWhereUniqueInput
  }

  export type ClientCreateNestedManyWithoutNewPipelineInput = {
    create?: XOR<ClientCreateWithoutNewPipelineInput, ClientUncheckedCreateWithoutNewPipelineInput> | ClientCreateWithoutNewPipelineInput[] | ClientUncheckedCreateWithoutNewPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutNewPipelineInput | ClientCreateOrConnectWithoutNewPipelineInput[]
    createMany?: ClientCreateManyNewPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutProspectPipelineInput = {
    create?: XOR<ClientCreateWithoutProspectPipelineInput, ClientUncheckedCreateWithoutProspectPipelineInput> | ClientCreateWithoutProspectPipelineInput[] | ClientUncheckedCreateWithoutProspectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutProspectPipelineInput | ClientCreateOrConnectWithoutProspectPipelineInput[]
    createMany?: ClientCreateManyProspectPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutViewingPipelineInput = {
    create?: XOR<ClientCreateWithoutViewingPipelineInput, ClientUncheckedCreateWithoutViewingPipelineInput> | ClientCreateWithoutViewingPipelineInput[] | ClientUncheckedCreateWithoutViewingPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutViewingPipelineInput | ClientCreateOrConnectWithoutViewingPipelineInput[]
    createMany?: ClientCreateManyViewingPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutRejectPipelineInput = {
    create?: XOR<ClientCreateWithoutRejectPipelineInput, ClientUncheckedCreateWithoutRejectPipelineInput> | ClientCreateWithoutRejectPipelineInput[] | ClientUncheckedCreateWithoutRejectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutRejectPipelineInput | ClientCreateOrConnectWithoutRejectPipelineInput[]
    createMany?: ClientCreateManyRejectPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutClosePipelineInput = {
    create?: XOR<ClientCreateWithoutClosePipelineInput, ClientUncheckedCreateWithoutClosePipelineInput> | ClientCreateWithoutClosePipelineInput[] | ClientUncheckedCreateWithoutClosePipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutClosePipelineInput | ClientCreateOrConnectWithoutClosePipelineInput[]
    createMany?: ClientCreateManyClosePipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutNewPipelineInput = {
    create?: XOR<ClientCreateWithoutNewPipelineInput, ClientUncheckedCreateWithoutNewPipelineInput> | ClientCreateWithoutNewPipelineInput[] | ClientUncheckedCreateWithoutNewPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutNewPipelineInput | ClientCreateOrConnectWithoutNewPipelineInput[]
    createMany?: ClientCreateManyNewPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutProspectPipelineInput = {
    create?: XOR<ClientCreateWithoutProspectPipelineInput, ClientUncheckedCreateWithoutProspectPipelineInput> | ClientCreateWithoutProspectPipelineInput[] | ClientUncheckedCreateWithoutProspectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutProspectPipelineInput | ClientCreateOrConnectWithoutProspectPipelineInput[]
    createMany?: ClientCreateManyProspectPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutViewingPipelineInput = {
    create?: XOR<ClientCreateWithoutViewingPipelineInput, ClientUncheckedCreateWithoutViewingPipelineInput> | ClientCreateWithoutViewingPipelineInput[] | ClientUncheckedCreateWithoutViewingPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutViewingPipelineInput | ClientCreateOrConnectWithoutViewingPipelineInput[]
    createMany?: ClientCreateManyViewingPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutRejectPipelineInput = {
    create?: XOR<ClientCreateWithoutRejectPipelineInput, ClientUncheckedCreateWithoutRejectPipelineInput> | ClientCreateWithoutRejectPipelineInput[] | ClientUncheckedCreateWithoutRejectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutRejectPipelineInput | ClientCreateOrConnectWithoutRejectPipelineInput[]
    createMany?: ClientCreateManyRejectPipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutClosePipelineInput = {
    create?: XOR<ClientCreateWithoutClosePipelineInput, ClientUncheckedCreateWithoutClosePipelineInput> | ClientCreateWithoutClosePipelineInput[] | ClientUncheckedCreateWithoutClosePipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutClosePipelineInput | ClientCreateOrConnectWithoutClosePipelineInput[]
    createMany?: ClientCreateManyClosePipelineInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPipelineNestedInput = {
    create?: XOR<CompanyCreateWithoutPipelineInput, CompanyUncheckedCreateWithoutPipelineInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPipelineInput
    upsert?: CompanyUpsertWithoutPipelineInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPipelineInput, CompanyUpdateWithoutPipelineInput>, CompanyUncheckedUpdateWithoutPipelineInput>
  }

  export type ClientUpdateManyWithoutNewPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutNewPipelineInput, ClientUncheckedCreateWithoutNewPipelineInput> | ClientCreateWithoutNewPipelineInput[] | ClientUncheckedCreateWithoutNewPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutNewPipelineInput | ClientCreateOrConnectWithoutNewPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutNewPipelineInput | ClientUpsertWithWhereUniqueWithoutNewPipelineInput[]
    createMany?: ClientCreateManyNewPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutNewPipelineInput | ClientUpdateWithWhereUniqueWithoutNewPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutNewPipelineInput | ClientUpdateManyWithWhereWithoutNewPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutProspectPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutProspectPipelineInput, ClientUncheckedCreateWithoutProspectPipelineInput> | ClientCreateWithoutProspectPipelineInput[] | ClientUncheckedCreateWithoutProspectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutProspectPipelineInput | ClientCreateOrConnectWithoutProspectPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutProspectPipelineInput | ClientUpsertWithWhereUniqueWithoutProspectPipelineInput[]
    createMany?: ClientCreateManyProspectPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutProspectPipelineInput | ClientUpdateWithWhereUniqueWithoutProspectPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutProspectPipelineInput | ClientUpdateManyWithWhereWithoutProspectPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutViewingPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutViewingPipelineInput, ClientUncheckedCreateWithoutViewingPipelineInput> | ClientCreateWithoutViewingPipelineInput[] | ClientUncheckedCreateWithoutViewingPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutViewingPipelineInput | ClientCreateOrConnectWithoutViewingPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutViewingPipelineInput | ClientUpsertWithWhereUniqueWithoutViewingPipelineInput[]
    createMany?: ClientCreateManyViewingPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutViewingPipelineInput | ClientUpdateWithWhereUniqueWithoutViewingPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutViewingPipelineInput | ClientUpdateManyWithWhereWithoutViewingPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutRejectPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutRejectPipelineInput, ClientUncheckedCreateWithoutRejectPipelineInput> | ClientCreateWithoutRejectPipelineInput[] | ClientUncheckedCreateWithoutRejectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutRejectPipelineInput | ClientCreateOrConnectWithoutRejectPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutRejectPipelineInput | ClientUpsertWithWhereUniqueWithoutRejectPipelineInput[]
    createMany?: ClientCreateManyRejectPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutRejectPipelineInput | ClientUpdateWithWhereUniqueWithoutRejectPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutRejectPipelineInput | ClientUpdateManyWithWhereWithoutRejectPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutClosePipelineNestedInput = {
    create?: XOR<ClientCreateWithoutClosePipelineInput, ClientUncheckedCreateWithoutClosePipelineInput> | ClientCreateWithoutClosePipelineInput[] | ClientUncheckedCreateWithoutClosePipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutClosePipelineInput | ClientCreateOrConnectWithoutClosePipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutClosePipelineInput | ClientUpsertWithWhereUniqueWithoutClosePipelineInput[]
    createMany?: ClientCreateManyClosePipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutClosePipelineInput | ClientUpdateWithWhereUniqueWithoutClosePipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutClosePipelineInput | ClientUpdateManyWithWhereWithoutClosePipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutNewPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutNewPipelineInput, ClientUncheckedCreateWithoutNewPipelineInput> | ClientCreateWithoutNewPipelineInput[] | ClientUncheckedCreateWithoutNewPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutNewPipelineInput | ClientCreateOrConnectWithoutNewPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutNewPipelineInput | ClientUpsertWithWhereUniqueWithoutNewPipelineInput[]
    createMany?: ClientCreateManyNewPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutNewPipelineInput | ClientUpdateWithWhereUniqueWithoutNewPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutNewPipelineInput | ClientUpdateManyWithWhereWithoutNewPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutProspectPipelineInput, ClientUncheckedCreateWithoutProspectPipelineInput> | ClientCreateWithoutProspectPipelineInput[] | ClientUncheckedCreateWithoutProspectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutProspectPipelineInput | ClientCreateOrConnectWithoutProspectPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutProspectPipelineInput | ClientUpsertWithWhereUniqueWithoutProspectPipelineInput[]
    createMany?: ClientCreateManyProspectPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutProspectPipelineInput | ClientUpdateWithWhereUniqueWithoutProspectPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutProspectPipelineInput | ClientUpdateManyWithWhereWithoutProspectPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutViewingPipelineInput, ClientUncheckedCreateWithoutViewingPipelineInput> | ClientCreateWithoutViewingPipelineInput[] | ClientUncheckedCreateWithoutViewingPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutViewingPipelineInput | ClientCreateOrConnectWithoutViewingPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutViewingPipelineInput | ClientUpsertWithWhereUniqueWithoutViewingPipelineInput[]
    createMany?: ClientCreateManyViewingPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutViewingPipelineInput | ClientUpdateWithWhereUniqueWithoutViewingPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutViewingPipelineInput | ClientUpdateManyWithWhereWithoutViewingPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput = {
    create?: XOR<ClientCreateWithoutRejectPipelineInput, ClientUncheckedCreateWithoutRejectPipelineInput> | ClientCreateWithoutRejectPipelineInput[] | ClientUncheckedCreateWithoutRejectPipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutRejectPipelineInput | ClientCreateOrConnectWithoutRejectPipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutRejectPipelineInput | ClientUpsertWithWhereUniqueWithoutRejectPipelineInput[]
    createMany?: ClientCreateManyRejectPipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutRejectPipelineInput | ClientUpdateWithWhereUniqueWithoutRejectPipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutRejectPipelineInput | ClientUpdateManyWithWhereWithoutRejectPipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutClosePipelineNestedInput = {
    create?: XOR<ClientCreateWithoutClosePipelineInput, ClientUncheckedCreateWithoutClosePipelineInput> | ClientCreateWithoutClosePipelineInput[] | ClientUncheckedCreateWithoutClosePipelineInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutClosePipelineInput | ClientCreateOrConnectWithoutClosePipelineInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutClosePipelineInput | ClientUpsertWithWhereUniqueWithoutClosePipelineInput[]
    createMany?: ClientCreateManyClosePipelineInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutClosePipelineInput | ClientUpdateWithWhereUniqueWithoutClosePipelineInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutClosePipelineInput | ClientUpdateManyWithWhereWithoutClosePipelineInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<CompanyCreateWithoutCategoriesInput, CompanyUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCategoriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type EntryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EntryCreateWithoutCategoryInput, EntryUncheckedCreateWithoutCategoryInput> | EntryCreateWithoutCategoryInput[] | EntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutCategoryInput | EntryCreateOrConnectWithoutCategoryInput[]
    createMany?: EntryCreateManyCategoryInputEnvelope
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type EntryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EntryCreateWithoutCategoryInput, EntryUncheckedCreateWithoutCategoryInput> | EntryCreateWithoutCategoryInput[] | EntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutCategoryInput | EntryCreateOrConnectWithoutCategoryInput[]
    createMany?: EntryCreateManyCategoryInputEnvelope
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumTaxTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaxType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<CompanyCreateWithoutCategoriesInput, CompanyUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCategoriesInput
    upsert?: CompanyUpsertWithoutCategoriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCategoriesInput, CompanyUpdateWithoutCategoriesInput>, CompanyUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type EntryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EntryCreateWithoutCategoryInput, EntryUncheckedCreateWithoutCategoryInput> | EntryCreateWithoutCategoryInput[] | EntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutCategoryInput | EntryCreateOrConnectWithoutCategoryInput[]
    upsert?: EntryUpsertWithWhereUniqueWithoutCategoryInput | EntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EntryCreateManyCategoryInputEnvelope
    set?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    disconnect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    delete?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    update?: EntryUpdateWithWhereUniqueWithoutCategoryInput | EntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EntryUpdateManyWithWhereWithoutCategoryInput | EntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EntryScalarWhereInput | EntryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type EntryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EntryCreateWithoutCategoryInput, EntryUncheckedCreateWithoutCategoryInput> | EntryCreateWithoutCategoryInput[] | EntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutCategoryInput | EntryCreateOrConnectWithoutCategoryInput[]
    upsert?: EntryUpsertWithWhereUniqueWithoutCategoryInput | EntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EntryCreateManyCategoryInputEnvelope
    set?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    disconnect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    delete?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    update?: EntryUpdateWithWhereUniqueWithoutCategoryInput | EntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EntryUpdateManyWithWhereWithoutCategoryInput | EntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EntryScalarWhereInput | EntryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CompanyCreateWithoutSubcategoriesInput, CompanyUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubcategoriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput> | ProductCreateWithoutSubcategoryInput[] | ProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubcategoryInput | ProductCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ProductCreateManySubcategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput> | ProductCreateWithoutSubcategoryInput[] | ProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubcategoryInput | ProductCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ProductCreateManySubcategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<CompanyCreateWithoutSubcategoriesInput, CompanyUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubcategoriesInput
    upsert?: CompanyUpsertWithoutSubcategoriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSubcategoriesInput, CompanyUpdateWithoutSubcategoriesInput>, CompanyUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ProductUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput> | ProductCreateWithoutSubcategoryInput[] | ProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubcategoryInput | ProductCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubcategoryInput | ProductUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ProductCreateManySubcategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubcategoryInput | ProductUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubcategoryInput | ProductUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutSubcategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: CategoryUpsertWithoutSubcategoriesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubcategoriesInput, CategoryUpdateWithoutSubcategoriesInput>, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ProductUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput> | ProductCreateWithoutSubcategoryInput[] | ProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubcategoryInput | ProductCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubcategoryInput | ProductUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ProductCreateManySubcategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubcategoryInput | ProductUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubcategoryInput | ProductUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutProductsInput = {
    create?: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SubcategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<SubcategoryCreateWithoutProductsInput, SubcategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutProductsInput
    connect?: SubcategoryWhereUniqueInput
  }

  export type VariantCreateNestedManyWithoutProductInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutProductsInput = {
    create?: XOR<PurchaseOrderCreateWithoutProductsInput, PurchaseOrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProductsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type VariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductsInput
    upsert?: CompanyUpsertWithoutProductsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProductsInput, CompanyUpdateWithoutProductsInput>, CompanyUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type SubcategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<SubcategoryCreateWithoutProductsInput, SubcategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutProductsInput
    upsert?: SubcategoryUpsertWithoutProductsInput
    disconnect?: SubcategoryWhereInput | boolean
    delete?: SubcategoryWhereInput | boolean
    connect?: SubcategoryWhereUniqueInput
    update?: XOR<XOR<SubcategoryUpdateToOneWithWhereWithoutProductsInput, SubcategoryUpdateWithoutProductsInput>, SubcategoryUncheckedUpdateWithoutProductsInput>
  }

  export type VariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutProductInput | VariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutProductInput | VariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutProductInput | VariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type PurchaseOrderUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutProductsInput, PurchaseOrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProductsInput
    upsert?: PurchaseOrderUpsertWithoutProductsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutProductsInput, PurchaseOrderUpdateWithoutProductsInput>, PurchaseOrderUncheckedUpdateWithoutProductsInput>
  }

  export type VariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutProductInput | VariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutProductInput | VariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutProductInput | VariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type VariantCreateimagesInput = {
    set: string[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<ItemCreateWithoutVariantInput, ItemUncheckedCreateWithoutVariantInput> | ItemCreateWithoutVariantInput[] | ItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutVariantInput | ItemCreateOrConnectWithoutVariantInput[]
    createMany?: ItemCreateManyVariantInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type EntryCreateNestedManyWithoutVariantInput = {
    create?: XOR<EntryCreateWithoutVariantInput, EntryUncheckedCreateWithoutVariantInput> | EntryCreateWithoutVariantInput[] | EntryUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutVariantInput | EntryCreateOrConnectWithoutVariantInput[]
    createMany?: EntryCreateManyVariantInputEnvelope
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutVariantsInput = {
    create?: XOR<CompanyCreateWithoutVariantsInput, CompanyUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVariantsInput
    connect?: CompanyWhereUniqueInput
  }

  export type VariantSizeBarcodeCreateNestedManyWithoutVariantInput = {
    create?: XOR<VariantSizeBarcodeCreateWithoutVariantInput, VariantSizeBarcodeUncheckedCreateWithoutVariantInput> | VariantSizeBarcodeCreateWithoutVariantInput[] | VariantSizeBarcodeUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantSizeBarcodeCreateOrConnectWithoutVariantInput | VariantSizeBarcodeCreateOrConnectWithoutVariantInput[]
    createMany?: VariantSizeBarcodeCreateManyVariantInputEnvelope
    connect?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<ItemCreateWithoutVariantInput, ItemUncheckedCreateWithoutVariantInput> | ItemCreateWithoutVariantInput[] | ItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutVariantInput | ItemCreateOrConnectWithoutVariantInput[]
    createMany?: ItemCreateManyVariantInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type EntryUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<EntryCreateWithoutVariantInput, EntryUncheckedCreateWithoutVariantInput> | EntryCreateWithoutVariantInput[] | EntryUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutVariantInput | EntryCreateOrConnectWithoutVariantInput[]
    createMany?: EntryCreateManyVariantInputEnvelope
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
  }

  export type VariantSizeBarcodeUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<VariantSizeBarcodeCreateWithoutVariantInput, VariantSizeBarcodeUncheckedCreateWithoutVariantInput> | VariantSizeBarcodeCreateWithoutVariantInput[] | VariantSizeBarcodeUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantSizeBarcodeCreateOrConnectWithoutVariantInput | VariantSizeBarcodeCreateOrConnectWithoutVariantInput[]
    createMany?: VariantSizeBarcodeCreateManyVariantInputEnvelope
    connect?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VariantUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ItemCreateWithoutVariantInput, ItemUncheckedCreateWithoutVariantInput> | ItemCreateWithoutVariantInput[] | ItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutVariantInput | ItemCreateOrConnectWithoutVariantInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutVariantInput | ItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ItemCreateManyVariantInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutVariantInput | ItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutVariantInput | ItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type EntryUpdateManyWithoutVariantNestedInput = {
    create?: XOR<EntryCreateWithoutVariantInput, EntryUncheckedCreateWithoutVariantInput> | EntryCreateWithoutVariantInput[] | EntryUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutVariantInput | EntryCreateOrConnectWithoutVariantInput[]
    upsert?: EntryUpsertWithWhereUniqueWithoutVariantInput | EntryUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: EntryCreateManyVariantInputEnvelope
    set?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    disconnect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    delete?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    update?: EntryUpdateWithWhereUniqueWithoutVariantInput | EntryUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: EntryUpdateManyWithWhereWithoutVariantInput | EntryUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: EntryScalarWhereInput | EntryScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<CompanyCreateWithoutVariantsInput, CompanyUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVariantsInput
    upsert?: CompanyUpsertWithoutVariantsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVariantsInput, CompanyUpdateWithoutVariantsInput>, CompanyUncheckedUpdateWithoutVariantsInput>
  }

  export type VariantSizeBarcodeUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VariantSizeBarcodeCreateWithoutVariantInput, VariantSizeBarcodeUncheckedCreateWithoutVariantInput> | VariantSizeBarcodeCreateWithoutVariantInput[] | VariantSizeBarcodeUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantSizeBarcodeCreateOrConnectWithoutVariantInput | VariantSizeBarcodeCreateOrConnectWithoutVariantInput[]
    upsert?: VariantSizeBarcodeUpsertWithWhereUniqueWithoutVariantInput | VariantSizeBarcodeUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VariantSizeBarcodeCreateManyVariantInputEnvelope
    set?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    disconnect?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    delete?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    connect?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    update?: VariantSizeBarcodeUpdateWithWhereUniqueWithoutVariantInput | VariantSizeBarcodeUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VariantSizeBarcodeUpdateManyWithWhereWithoutVariantInput | VariantSizeBarcodeUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VariantSizeBarcodeScalarWhereInput | VariantSizeBarcodeScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ItemCreateWithoutVariantInput, ItemUncheckedCreateWithoutVariantInput> | ItemCreateWithoutVariantInput[] | ItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutVariantInput | ItemCreateOrConnectWithoutVariantInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutVariantInput | ItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ItemCreateManyVariantInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutVariantInput | ItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutVariantInput | ItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type EntryUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<EntryCreateWithoutVariantInput, EntryUncheckedCreateWithoutVariantInput> | EntryCreateWithoutVariantInput[] | EntryUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutVariantInput | EntryCreateOrConnectWithoutVariantInput[]
    upsert?: EntryUpsertWithWhereUniqueWithoutVariantInput | EntryUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: EntryCreateManyVariantInputEnvelope
    set?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    disconnect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    delete?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    update?: EntryUpdateWithWhereUniqueWithoutVariantInput | EntryUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: EntryUpdateManyWithWhereWithoutVariantInput | EntryUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: EntryScalarWhereInput | EntryScalarWhereInput[]
  }

  export type VariantSizeBarcodeUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VariantSizeBarcodeCreateWithoutVariantInput, VariantSizeBarcodeUncheckedCreateWithoutVariantInput> | VariantSizeBarcodeCreateWithoutVariantInput[] | VariantSizeBarcodeUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantSizeBarcodeCreateOrConnectWithoutVariantInput | VariantSizeBarcodeCreateOrConnectWithoutVariantInput[]
    upsert?: VariantSizeBarcodeUpsertWithWhereUniqueWithoutVariantInput | VariantSizeBarcodeUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VariantSizeBarcodeCreateManyVariantInputEnvelope
    set?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    disconnect?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    delete?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    connect?: VariantSizeBarcodeWhereUniqueInput | VariantSizeBarcodeWhereUniqueInput[]
    update?: VariantSizeBarcodeUpdateWithWhereUniqueWithoutVariantInput | VariantSizeBarcodeUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VariantSizeBarcodeUpdateManyWithWhereWithoutVariantInput | VariantSizeBarcodeUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VariantSizeBarcodeScalarWhereInput | VariantSizeBarcodeScalarWhereInput[]
  }

  export type VariantCreateNestedOneWithoutItemsInput = {
    create?: XOR<VariantCreateWithoutItemsInput, VariantUncheckedCreateWithoutItemsInput>
    connectOrCreate?: VariantCreateOrConnectWithoutItemsInput
    connect?: VariantWhereUniqueInput
  }

  export type EntryCreateNestedOneWithoutItemInput = {
    create?: XOR<EntryCreateWithoutItemInput, EntryUncheckedCreateWithoutItemInput>
    connectOrCreate?: EntryCreateOrConnectWithoutItemInput
    connect?: EntryWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutItemsInput = {
    create?: XOR<CompanyCreateWithoutItemsInput, CompanyUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EntryUncheckedCreateNestedOneWithoutItemInput = {
    create?: XOR<EntryCreateWithoutItemInput, EntryUncheckedCreateWithoutItemInput>
    connectOrCreate?: EntryCreateOrConnectWithoutItemInput
    connect?: EntryWhereUniqueInput
  }

  export type VariantUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<VariantCreateWithoutItemsInput, VariantUncheckedCreateWithoutItemsInput>
    connectOrCreate?: VariantCreateOrConnectWithoutItemsInput
    upsert?: VariantUpsertWithoutItemsInput
    connect?: VariantWhereUniqueInput
    update?: XOR<XOR<VariantUpdateToOneWithWhereWithoutItemsInput, VariantUpdateWithoutItemsInput>, VariantUncheckedUpdateWithoutItemsInput>
  }

  export type EntryUpdateOneWithoutItemNestedInput = {
    create?: XOR<EntryCreateWithoutItemInput, EntryUncheckedCreateWithoutItemInput>
    connectOrCreate?: EntryCreateOrConnectWithoutItemInput
    upsert?: EntryUpsertWithoutItemInput
    disconnect?: EntryWhereInput | boolean
    delete?: EntryWhereInput | boolean
    connect?: EntryWhereUniqueInput
    update?: XOR<XOR<EntryUpdateToOneWithWhereWithoutItemInput, EntryUpdateWithoutItemInput>, EntryUncheckedUpdateWithoutItemInput>
  }

  export type CompanyUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CompanyCreateWithoutItemsInput, CompanyUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemsInput
    upsert?: CompanyUpsertWithoutItemsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutItemsInput, CompanyUpdateWithoutItemsInput>, CompanyUncheckedUpdateWithoutItemsInput>
  }

  export type EntryUncheckedUpdateOneWithoutItemNestedInput = {
    create?: XOR<EntryCreateWithoutItemInput, EntryUncheckedCreateWithoutItemInput>
    connectOrCreate?: EntryCreateOrConnectWithoutItemInput
    upsert?: EntryUpsertWithoutItemInput
    disconnect?: EntryWhereInput | boolean
    delete?: EntryWhereInput | boolean
    connect?: EntryWhereUniqueInput
    update?: XOR<XOR<EntryUpdateToOneWithWhereWithoutItemInput, EntryUpdateWithoutItemInput>, EntryUncheckedUpdateWithoutItemInput>
  }

  export type ProductCreateNestedManyWithoutPurchaseorderInput = {
    create?: XOR<ProductCreateWithoutPurchaseorderInput, ProductUncheckedCreateWithoutPurchaseorderInput> | ProductCreateWithoutPurchaseorderInput[] | ProductUncheckedCreateWithoutPurchaseorderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseorderInput | ProductCreateOrConnectWithoutPurchaseorderInput[]
    createMany?: ProductCreateManyPurchaseorderInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type DistributorCreateNestedOneWithoutPurchaseordersInput = {
    create?: XOR<DistributorCreateWithoutPurchaseordersInput, DistributorUncheckedCreateWithoutPurchaseordersInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutPurchaseordersInput
    connect?: DistributorWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutPurchaseorderInput = {
    create?: XOR<ProductCreateWithoutPurchaseorderInput, ProductUncheckedCreateWithoutPurchaseorderInput> | ProductCreateWithoutPurchaseorderInput[] | ProductUncheckedCreateWithoutPurchaseorderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseorderInput | ProductCreateOrConnectWithoutPurchaseorderInput[]
    createMany?: ProductCreateManyPurchaseorderInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type NullableEnumpaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.paymentType | null
  }

  export type ProductUpdateManyWithoutPurchaseorderNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseorderInput, ProductUncheckedCreateWithoutPurchaseorderInput> | ProductCreateWithoutPurchaseorderInput[] | ProductUncheckedCreateWithoutPurchaseorderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseorderInput | ProductCreateOrConnectWithoutPurchaseorderInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPurchaseorderInput | ProductUpsertWithWhereUniqueWithoutPurchaseorderInput[]
    createMany?: ProductCreateManyPurchaseorderInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPurchaseorderInput | ProductUpdateWithWhereUniqueWithoutPurchaseorderInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPurchaseorderInput | ProductUpdateManyWithWhereWithoutPurchaseorderInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type DistributorUpdateOneWithoutPurchaseordersNestedInput = {
    create?: XOR<DistributorCreateWithoutPurchaseordersInput, DistributorUncheckedCreateWithoutPurchaseordersInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutPurchaseordersInput
    upsert?: DistributorUpsertWithoutPurchaseordersInput
    disconnect?: DistributorWhereInput | boolean
    delete?: DistributorWhereInput | boolean
    connect?: DistributorWhereUniqueInput
    update?: XOR<XOR<DistributorUpdateToOneWithWhereWithoutPurchaseordersInput, DistributorUpdateWithoutPurchaseordersInput>, DistributorUncheckedUpdateWithoutPurchaseordersInput>
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: CompanyUpsertWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput, CompanyUpdateWithoutPurchaseOrdersInput>, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type ProductUncheckedUpdateManyWithoutPurchaseorderNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseorderInput, ProductUncheckedCreateWithoutPurchaseorderInput> | ProductCreateWithoutPurchaseorderInput[] | ProductUncheckedCreateWithoutPurchaseorderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseorderInput | ProductCreateOrConnectWithoutPurchaseorderInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPurchaseorderInput | ProductUpsertWithWhereUniqueWithoutPurchaseorderInput[]
    createMany?: ProductCreateManyPurchaseorderInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPurchaseorderInput | ProductUpdateWithWhereUniqueWithoutPurchaseorderInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPurchaseorderInput | ProductUpdateManyWithWhereWithoutPurchaseorderInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type EntryCreateNestedManyWithoutBillInput = {
    create?: XOR<EntryCreateWithoutBillInput, EntryUncheckedCreateWithoutBillInput> | EntryCreateWithoutBillInput[] | EntryUncheckedCreateWithoutBillInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutBillInput | EntryCreateOrConnectWithoutBillInput[]
    createMany?: EntryCreateManyBillInputEnvelope
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutBillsInput = {
    create?: XOR<CompanyCreateWithoutBillsInput, CompanyUncheckedCreateWithoutBillsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBillsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutBillInput = {
    create?: XOR<AccountCreateWithoutBillInput, AccountUncheckedCreateWithoutBillInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBillInput
    connect?: AccountWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutBillInput = {
    create?: XOR<ClientCreateWithoutBillInput, ClientUncheckedCreateWithoutBillInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBillInput
    connect?: ClientWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutBillInput = {
    create?: XOR<AddressCreateWithoutBillInput, AddressUncheckedCreateWithoutBillInput>
    connectOrCreate?: AddressCreateOrConnectWithoutBillInput
    connect?: AddressWhereUniqueInput
  }

  export type EntryUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<EntryCreateWithoutBillInput, EntryUncheckedCreateWithoutBillInput> | EntryCreateWithoutBillInput[] | EntryUncheckedCreateWithoutBillInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutBillInput | EntryCreateOrConnectWithoutBillInput[]
    createMany?: EntryCreateManyBillInputEnvelope
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type NullableEnumOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderType | null
  }

  export type NullableEnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EntryUpdateManyWithoutBillNestedInput = {
    create?: XOR<EntryCreateWithoutBillInput, EntryUncheckedCreateWithoutBillInput> | EntryCreateWithoutBillInput[] | EntryUncheckedCreateWithoutBillInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutBillInput | EntryCreateOrConnectWithoutBillInput[]
    upsert?: EntryUpsertWithWhereUniqueWithoutBillInput | EntryUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: EntryCreateManyBillInputEnvelope
    set?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    disconnect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    delete?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    update?: EntryUpdateWithWhereUniqueWithoutBillInput | EntryUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: EntryUpdateManyWithWhereWithoutBillInput | EntryUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: EntryScalarWhereInput | EntryScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<CompanyCreateWithoutBillsInput, CompanyUncheckedCreateWithoutBillsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBillsInput
    upsert?: CompanyUpsertWithoutBillsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBillsInput, CompanyUpdateWithoutBillsInput>, CompanyUncheckedUpdateWithoutBillsInput>
  }

  export type AccountUpdateOneWithoutBillNestedInput = {
    create?: XOR<AccountCreateWithoutBillInput, AccountUncheckedCreateWithoutBillInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBillInput
    upsert?: AccountUpsertWithoutBillInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBillInput, AccountUpdateWithoutBillInput>, AccountUncheckedUpdateWithoutBillInput>
  }

  export type ClientUpdateOneWithoutBillNestedInput = {
    create?: XOR<ClientCreateWithoutBillInput, ClientUncheckedCreateWithoutBillInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBillInput
    upsert?: ClientUpsertWithoutBillInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutBillInput, ClientUpdateWithoutBillInput>, ClientUncheckedUpdateWithoutBillInput>
  }

  export type AddressUpdateOneWithoutBillNestedInput = {
    create?: XOR<AddressCreateWithoutBillInput, AddressUncheckedCreateWithoutBillInput>
    connectOrCreate?: AddressCreateOrConnectWithoutBillInput
    upsert?: AddressUpsertWithoutBillInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutBillInput, AddressUpdateWithoutBillInput>, AddressUncheckedUpdateWithoutBillInput>
  }

  export type EntryUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<EntryCreateWithoutBillInput, EntryUncheckedCreateWithoutBillInput> | EntryCreateWithoutBillInput[] | EntryUncheckedCreateWithoutBillInput[]
    connectOrCreate?: EntryCreateOrConnectWithoutBillInput | EntryCreateOrConnectWithoutBillInput[]
    upsert?: EntryUpsertWithWhereUniqueWithoutBillInput | EntryUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: EntryCreateManyBillInputEnvelope
    set?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    disconnect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    delete?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    connect?: EntryWhereUniqueInput | EntryWhereUniqueInput[]
    update?: EntryUpdateWithWhereUniqueWithoutBillInput | EntryUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: EntryUpdateManyWithWhereWithoutBillInput | EntryUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: EntryScalarWhereInput | EntryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutTokenbillsInput = {
    create?: XOR<CompanyCreateWithoutTokenbillsInput, CompanyUncheckedCreateWithoutTokenbillsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTokenbillsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutTokenbillsNestedInput = {
    create?: XOR<CompanyCreateWithoutTokenbillsInput, CompanyUncheckedCreateWithoutTokenbillsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTokenbillsInput
    upsert?: CompanyUpsertWithoutTokenbillsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTokenbillsInput, CompanyUpdateWithoutTokenbillsInput>, CompanyUncheckedUpdateWithoutTokenbillsInput>
  }

  export type VariantCreateNestedOneWithoutEntriesInput = {
    create?: XOR<VariantCreateWithoutEntriesInput, VariantUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: VariantCreateOrConnectWithoutEntriesInput
    connect?: VariantWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutEntriesInput = {
    create?: XOR<CategoryCreateWithoutEntriesInput, CategoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEntriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type BillCreateNestedOneWithoutEntriesInput = {
    create?: XOR<BillCreateWithoutEntriesInput, BillUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: BillCreateOrConnectWithoutEntriesInput
    connect?: BillWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEntryInput = {
    create?: XOR<ItemCreateWithoutEntryInput, ItemUncheckedCreateWithoutEntryInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEntryInput
    connect?: ItemWhereUniqueInput
  }

  export type VariantUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<VariantCreateWithoutEntriesInput, VariantUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: VariantCreateOrConnectWithoutEntriesInput
    upsert?: VariantUpsertWithoutEntriesInput
    disconnect?: VariantWhereInput | boolean
    delete?: VariantWhereInput | boolean
    connect?: VariantWhereUniqueInput
    update?: XOR<XOR<VariantUpdateToOneWithWhereWithoutEntriesInput, VariantUpdateWithoutEntriesInput>, VariantUncheckedUpdateWithoutEntriesInput>
  }

  export type CategoryUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<CategoryCreateWithoutEntriesInput, CategoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEntriesInput
    upsert?: CategoryUpsertWithoutEntriesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutEntriesInput, CategoryUpdateWithoutEntriesInput>, CategoryUncheckedUpdateWithoutEntriesInput>
  }

  export type BillUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<BillCreateWithoutEntriesInput, BillUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: BillCreateOrConnectWithoutEntriesInput
    upsert?: BillUpsertWithoutEntriesInput
    disconnect?: BillWhereInput | boolean
    delete?: BillWhereInput | boolean
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutEntriesInput, BillUpdateWithoutEntriesInput>, BillUncheckedUpdateWithoutEntriesInput>
  }

  export type ItemUpdateOneWithoutEntryNestedInput = {
    create?: XOR<ItemCreateWithoutEntryInput, ItemUncheckedCreateWithoutEntryInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEntryInput
    upsert?: ItemUpsertWithoutEntryInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEntryInput, ItemUpdateWithoutEntryInput>, ItemUncheckedUpdateWithoutEntryInput>
  }

  export type BillCreateNestedManyWithoutAccountInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type AddressCreateNestedOneWithoutAccountInput = {
    create?: XOR<AddressCreateWithoutAccountInput, AddressUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AddressCreateOrConnectWithoutAccountInput
    connect?: AddressWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAccountsInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type BillUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<AddressCreateWithoutAccountInput, AddressUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AddressCreateOrConnectWithoutAccountInput
    connect?: AddressWhereUniqueInput
  }

  export type BillUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutAccountInput | BillUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutAccountInput | BillUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BillUpdateManyWithWhereWithoutAccountInput | BillUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type AddressUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AddressCreateWithoutAccountInput, AddressUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AddressCreateOrConnectWithoutAccountInput
    upsert?: AddressUpsertWithoutAccountInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutAccountInput, AddressUpdateWithoutAccountInput>, AddressUncheckedUpdateWithoutAccountInput>
  }

  export type CompanyUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    upsert?: CompanyUpsertWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAccountsInput, CompanyUpdateWithoutAccountsInput>, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type BillUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutAccountInput | BillUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutAccountInput | BillUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BillUpdateManyWithWhereWithoutAccountInput | BillUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AddressCreateWithoutAccountInput, AddressUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AddressCreateOrConnectWithoutAccountInput
    upsert?: AddressUpsertWithoutAccountInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutAccountInput, AddressUpdateWithoutAccountInput>, AddressUncheckedUpdateWithoutAccountInput>
  }

  export type ExpenseCreateNestedManyWithoutExpensecategoryInput = {
    create?: XOR<ExpenseCreateWithoutExpensecategoryInput, ExpenseUncheckedCreateWithoutExpensecategoryInput> | ExpenseCreateWithoutExpensecategoryInput[] | ExpenseUncheckedCreateWithoutExpensecategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutExpensecategoryInput | ExpenseCreateOrConnectWithoutExpensecategoryInput[]
    createMany?: ExpenseCreateManyExpensecategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutExpenseCategoriesInput = {
    create?: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpenseCategoriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ExpenseUncheckedCreateNestedManyWithoutExpensecategoryInput = {
    create?: XOR<ExpenseCreateWithoutExpensecategoryInput, ExpenseUncheckedCreateWithoutExpensecategoryInput> | ExpenseCreateWithoutExpensecategoryInput[] | ExpenseUncheckedCreateWithoutExpensecategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutExpensecategoryInput | ExpenseCreateOrConnectWithoutExpensecategoryInput[]
    createMany?: ExpenseCreateManyExpensecategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutExpensecategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutExpensecategoryInput, ExpenseUncheckedCreateWithoutExpensecategoryInput> | ExpenseCreateWithoutExpensecategoryInput[] | ExpenseUncheckedCreateWithoutExpensecategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutExpensecategoryInput | ExpenseCreateOrConnectWithoutExpensecategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutExpensecategoryInput | ExpenseUpsertWithWhereUniqueWithoutExpensecategoryInput[]
    createMany?: ExpenseCreateManyExpensecategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutExpensecategoryInput | ExpenseUpdateWithWhereUniqueWithoutExpensecategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutExpensecategoryInput | ExpenseUpdateManyWithWhereWithoutExpensecategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput = {
    create?: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpenseCategoriesInput
    upsert?: CompanyUpsertWithoutExpenseCategoriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExpenseCategoriesInput, CompanyUpdateWithoutExpenseCategoriesInput>, CompanyUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutExpensecategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutExpensecategoryInput, ExpenseUncheckedCreateWithoutExpensecategoryInput> | ExpenseCreateWithoutExpensecategoryInput[] | ExpenseUncheckedCreateWithoutExpensecategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutExpensecategoryInput | ExpenseCreateOrConnectWithoutExpensecategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutExpensecategoryInput | ExpenseUpsertWithWhereUniqueWithoutExpensecategoryInput[]
    createMany?: ExpenseCreateManyExpensecategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutExpensecategoryInput | ExpenseUpdateWithWhereUniqueWithoutExpensecategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutExpensecategoryInput | ExpenseUpdateManyWithWhereWithoutExpensecategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseCategoryCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutExpensesInput = {
    create?: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode
  }

  export type ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    upsert?: ExpenseCategoryUpsertWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput, ExpenseCategoryUpdateWithoutExpensesInput>, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesInput
    upsert?: CompanyUpsertWithoutExpensesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExpensesInput, CompanyUpdateWithoutExpensesInput>, CompanyUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyCreateNestedOneWithoutPaymentInput = {
    create?: XOR<CompanyCreateWithoutPaymentInput, CompanyUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<CompanyCreateWithoutPaymentInput, CompanyUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentInput
    upsert?: CompanyUpsertWithoutPaymentInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPaymentInput, CompanyUpdateWithoutPaymentInput>, CompanyUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAddressInput = {
    create?: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAddressInput
    connect?: ClientWhereUniqueInput
  }

  export type DistributorCreateNestedOneWithoutAddressInput = {
    create?: XOR<DistributorCreateWithoutAddressInput, DistributorUncheckedCreateWithoutAddressInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutAddressInput
    connect?: DistributorWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAddressInput = {
    create?: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAddressInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutAddressInput = {
    create?: XOR<AccountCreateWithoutAddressInput, AccountUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAddressInput
    connect?: AccountWhereUniqueInput
  }

  export type BillCreateNestedManyWithoutAddressInput = {
    create?: XOR<BillCreateWithoutAddressInput, BillUncheckedCreateWithoutAddressInput> | BillCreateWithoutAddressInput[] | BillUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAddressInput | BillCreateOrConnectWithoutAddressInput[]
    createMany?: BillCreateManyAddressInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<BillCreateWithoutAddressInput, BillUncheckedCreateWithoutAddressInput> | BillCreateWithoutAddressInput[] | BillUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAddressInput | BillCreateOrConnectWithoutAddressInput[]
    createMany?: BillCreateManyAddressInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressInput, UserUpdateWithoutAddressInput>, UserUncheckedUpdateWithoutAddressInput>
  }

  export type ClientUpdateOneWithoutAddressNestedInput = {
    create?: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAddressInput
    upsert?: ClientUpsertWithoutAddressInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAddressInput, ClientUpdateWithoutAddressInput>, ClientUncheckedUpdateWithoutAddressInput>
  }

  export type DistributorUpdateOneWithoutAddressNestedInput = {
    create?: XOR<DistributorCreateWithoutAddressInput, DistributorUncheckedCreateWithoutAddressInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutAddressInput
    upsert?: DistributorUpsertWithoutAddressInput
    disconnect?: DistributorWhereInput | boolean
    delete?: DistributorWhereInput | boolean
    connect?: DistributorWhereUniqueInput
    update?: XOR<XOR<DistributorUpdateToOneWithWhereWithoutAddressInput, DistributorUpdateWithoutAddressInput>, DistributorUncheckedUpdateWithoutAddressInput>
  }

  export type CompanyUpdateOneWithoutAddressNestedInput = {
    create?: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAddressInput
    upsert?: CompanyUpsertWithoutAddressInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAddressInput, CompanyUpdateWithoutAddressInput>, CompanyUncheckedUpdateWithoutAddressInput>
  }

  export type AccountUpdateOneWithoutAddressNestedInput = {
    create?: XOR<AccountCreateWithoutAddressInput, AccountUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAddressInput
    upsert?: AccountUpsertWithoutAddressInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAddressInput, AccountUpdateWithoutAddressInput>, AccountUncheckedUpdateWithoutAddressInput>
  }

  export type BillUpdateManyWithoutAddressNestedInput = {
    create?: XOR<BillCreateWithoutAddressInput, BillUncheckedCreateWithoutAddressInput> | BillCreateWithoutAddressInput[] | BillUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAddressInput | BillCreateOrConnectWithoutAddressInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutAddressInput | BillUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: BillCreateManyAddressInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutAddressInput | BillUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: BillUpdateManyWithWhereWithoutAddressInput | BillUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<BillCreateWithoutAddressInput, BillUncheckedCreateWithoutAddressInput> | BillCreateWithoutAddressInput[] | BillUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAddressInput | BillCreateOrConnectWithoutAddressInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutAddressInput | BillUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: BillCreateManyAddressInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutAddressInput | BillUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: BillUpdateManyWithWhereWithoutAddressInput | BillUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserConversationCreateNestedManyWithoutConversationInput = {
    create?: XOR<UserConversationCreateWithoutConversationInput, UserConversationUncheckedCreateWithoutConversationInput> | UserConversationCreateWithoutConversationInput[] | UserConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutConversationInput | UserConversationCreateOrConnectWithoutConversationInput[]
    createMany?: UserConversationCreateManyConversationInputEnvelope
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
  }

  export type ClientConversationCreateNestedManyWithoutConversationInput = {
    create?: XOR<ClientConversationCreateWithoutConversationInput, ClientConversationUncheckedCreateWithoutConversationInput> | ClientConversationCreateWithoutConversationInput[] | ClientConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutConversationInput | ClientConversationCreateOrConnectWithoutConversationInput[]
    createMany?: ClientConversationCreateManyConversationInputEnvelope
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserConversationUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<UserConversationCreateWithoutConversationInput, UserConversationUncheckedCreateWithoutConversationInput> | UserConversationCreateWithoutConversationInput[] | UserConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutConversationInput | UserConversationCreateOrConnectWithoutConversationInput[]
    createMany?: UserConversationCreateManyConversationInputEnvelope
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
  }

  export type ClientConversationUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ClientConversationCreateWithoutConversationInput, ClientConversationUncheckedCreateWithoutConversationInput> | ClientConversationCreateWithoutConversationInput[] | ClientConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutConversationInput | ClientConversationCreateOrConnectWithoutConversationInput[]
    createMany?: ClientConversationCreateManyConversationInputEnvelope
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserConversationUpdateManyWithoutConversationNestedInput = {
    create?: XOR<UserConversationCreateWithoutConversationInput, UserConversationUncheckedCreateWithoutConversationInput> | UserConversationCreateWithoutConversationInput[] | UserConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutConversationInput | UserConversationCreateOrConnectWithoutConversationInput[]
    upsert?: UserConversationUpsertWithWhereUniqueWithoutConversationInput | UserConversationUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: UserConversationCreateManyConversationInputEnvelope
    set?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    disconnect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    delete?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    update?: UserConversationUpdateWithWhereUniqueWithoutConversationInput | UserConversationUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: UserConversationUpdateManyWithWhereWithoutConversationInput | UserConversationUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: UserConversationScalarWhereInput | UserConversationScalarWhereInput[]
  }

  export type ClientConversationUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ClientConversationCreateWithoutConversationInput, ClientConversationUncheckedCreateWithoutConversationInput> | ClientConversationCreateWithoutConversationInput[] | ClientConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutConversationInput | ClientConversationCreateOrConnectWithoutConversationInput[]
    upsert?: ClientConversationUpsertWithWhereUniqueWithoutConversationInput | ClientConversationUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ClientConversationCreateManyConversationInputEnvelope
    set?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    disconnect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    delete?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    update?: ClientConversationUpdateWithWhereUniqueWithoutConversationInput | ClientConversationUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ClientConversationUpdateManyWithWhereWithoutConversationInput | ClientConversationUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ClientConversationScalarWhereInput | ClientConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserConversationUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<UserConversationCreateWithoutConversationInput, UserConversationUncheckedCreateWithoutConversationInput> | UserConversationCreateWithoutConversationInput[] | UserConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationCreateOrConnectWithoutConversationInput | UserConversationCreateOrConnectWithoutConversationInput[]
    upsert?: UserConversationUpsertWithWhereUniqueWithoutConversationInput | UserConversationUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: UserConversationCreateManyConversationInputEnvelope
    set?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    disconnect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    delete?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    connect?: UserConversationWhereUniqueInput | UserConversationWhereUniqueInput[]
    update?: UserConversationUpdateWithWhereUniqueWithoutConversationInput | UserConversationUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: UserConversationUpdateManyWithWhereWithoutConversationInput | UserConversationUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: UserConversationScalarWhereInput | UserConversationScalarWhereInput[]
  }

  export type ClientConversationUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ClientConversationCreateWithoutConversationInput, ClientConversationUncheckedCreateWithoutConversationInput> | ClientConversationCreateWithoutConversationInput[] | ClientConversationUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ClientConversationCreateOrConnectWithoutConversationInput | ClientConversationCreateOrConnectWithoutConversationInput[]
    upsert?: ClientConversationUpsertWithWhereUniqueWithoutConversationInput | ClientConversationUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ClientConversationCreateManyConversationInputEnvelope
    set?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    disconnect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    delete?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    connect?: ClientConversationWhereUniqueInput | ClientConversationWhereUniqueInput[]
    update?: ClientConversationUpdateWithWhereUniqueWithoutConversationInput | ClientConversationUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ClientConversationUpdateManyWithWhereWithoutConversationInput | ClientConversationUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ClientConversationScalarWhereInput | ClientConversationScalarWhereInput[]
  }

  export type MessageCreateseenInput = {
    set: string[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type MessageUpdateseenInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    upsert?: UserUpsertWithoutCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompaniesInput, UserUpdateWithoutCompaniesInput>, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompanyCreateNestedOneWithoutClientsInput = {
    create?: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutClientsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<ClientCreateWithoutCompaniesInput, ClientUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCompaniesInput
    connect?: ClientWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutClientsInput
    upsert?: CompanyUpsertWithoutClientsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutClientsInput, CompanyUpdateWithoutClientsInput>, CompanyUncheckedUpdateWithoutClientsInput>
  }

  export type ClientUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<ClientCreateWithoutCompaniesInput, ClientUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCompaniesInput
    upsert?: ClientUpsertWithoutCompaniesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutCompaniesInput, ClientUpdateWithoutCompaniesInput>, ClientUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutUsersInput = {
    create?: XOR<ConversationCreateWithoutUsersInput, ConversationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutUsersInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type ConversationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ConversationCreateWithoutUsersInput, ConversationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutUsersInput
    upsert?: ConversationUpsertWithoutUsersInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutUsersInput, ConversationUpdateWithoutUsersInput>, ConversationUncheckedUpdateWithoutUsersInput>
  }

  export type ClientCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutConversationsInput
    connect?: ClientWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutClientsInput = {
    create?: XOR<ConversationCreateWithoutClientsInput, ConversationUncheckedCreateWithoutClientsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutClientsInput
    connect?: ConversationWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutConversationsInput
    upsert?: ClientUpsertWithoutConversationsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutConversationsInput, ClientUpdateWithoutConversationsInput>, ClientUncheckedUpdateWithoutConversationsInput>
  }

  export type ConversationUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<ConversationCreateWithoutClientsInput, ConversationUncheckedCreateWithoutClientsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutClientsInput
    upsert?: ConversationUpsertWithoutClientsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutClientsInput, ConversationUpdateWithoutClientsInput>, ConversationUncheckedUpdateWithoutClientsInput>
  }

  export type ClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientsInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    connect?: UserWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    upsert?: ClientUpsertWithoutUsersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUsersInput, ClientUpdateWithoutUsersInput>, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    upsert?: UserUpsertWithoutClientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsInput, UserUpdateWithoutClientsInput>, UserUncheckedUpdateWithoutClientsInput>
  }

  export type DistributorCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<DistributorCreateWithoutCompaniesInput, DistributorUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutCompaniesInput
    connect?: DistributorWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDistributorInput = {
    create?: XOR<CompanyCreateWithoutDistributorInput, CompanyUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDistributorInput
    connect?: CompanyWhereUniqueInput
  }

  export type DistributorUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<DistributorCreateWithoutCompaniesInput, DistributorUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutCompaniesInput
    upsert?: DistributorUpsertWithoutCompaniesInput
    connect?: DistributorWhereUniqueInput
    update?: XOR<XOR<DistributorUpdateToOneWithWhereWithoutCompaniesInput, DistributorUpdateWithoutCompaniesInput>, DistributorUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompanyUpdateOneRequiredWithoutDistributorNestedInput = {
    create?: XOR<CompanyCreateWithoutDistributorInput, CompanyUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDistributorInput
    upsert?: CompanyUpsertWithoutDistributorInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDistributorInput, CompanyUpdateWithoutDistributorInput>, CompanyUncheckedUpdateWithoutDistributorInput>
  }

  export type VariantCreateNestedOneWithoutVariantSizeBarcodeInput = {
    create?: XOR<VariantCreateWithoutVariantSizeBarcodeInput, VariantUncheckedCreateWithoutVariantSizeBarcodeInput>
    connectOrCreate?: VariantCreateOrConnectWithoutVariantSizeBarcodeInput
    connect?: VariantWhereUniqueInput
  }

  export type VariantUpdateOneRequiredWithoutVariantSizeBarcodeNestedInput = {
    create?: XOR<VariantCreateWithoutVariantSizeBarcodeInput, VariantUncheckedCreateWithoutVariantSizeBarcodeInput>
    connectOrCreate?: VariantCreateOrConnectWithoutVariantSizeBarcodeInput
    upsert?: VariantUpsertWithoutVariantSizeBarcodeInput
    connect?: VariantWhereUniqueInput
    update?: XOR<XOR<VariantUpdateToOneWithWhereWithoutVariantSizeBarcodeInput, VariantUpdateWithoutVariantSizeBarcodeInput>, VariantUncheckedUpdateWithoutVariantSizeBarcodeInput>
  }

  export type CompanyCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CompanyCreateWithoutNotificationsInput, CompanyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutNotificationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ClientCreateWithoutNotificationsInput, ClientUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNotificationsInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type CompanyUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CompanyCreateWithoutNotificationsInput, CompanyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutNotificationsInput
    upsert?: CompanyUpsertWithoutNotificationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutNotificationsInput, CompanyUpdateWithoutNotificationsInput>, CompanyUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ClientUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ClientCreateWithoutNotificationsInput, ClientUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNotificationsInput
    upsert?: ClientUpsertWithoutNotificationsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutNotificationsInput, ClientUpdateWithoutNotificationsInput>, ClientUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCompanyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeFilter<$PrismaModel> | $Enums.CompanyType
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCompanyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CompanyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyTypeFilter<$PrismaModel>
    _max?: NestedEnumCompanyTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumTaxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeFilter<$PrismaModel> | $Enums.TaxType
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTaxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumpaymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.paymentType | EnumpaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpaymentTypeNullableFilter<$PrismaModel> | $Enums.paymentType | null
  }

  export type NestedEnumpaymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.paymentType | EnumpaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.paymentType[] | ListEnumpaymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpaymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.paymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpaymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumpaymentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumOrderTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderTypeNullableFilter<$PrismaModel> | $Enums.OrderType | null
  }

  export type NestedEnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type CompanyUserCreateWithoutCompanyInput = {
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyUserUncheckedCreateWithoutCompanyInput = {
    userId: string
  }

  export type CompanyUserCreateOrConnectWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserCreateManyCompanyInputEnvelope = {
    data: CompanyUserCreateManyCompanyInput | CompanyUserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyClientCreateWithoutCompanyInput = {
    client: ClientCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyClientUncheckedCreateWithoutCompanyInput = {
    clientId: string
  }

  export type CompanyClientCreateOrConnectWithoutCompanyInput = {
    where: CompanyClientWhereUniqueInput
    create: XOR<CompanyClientCreateWithoutCompanyInput, CompanyClientUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyClientCreateManyCompanyInputEnvelope = {
    data: CompanyClientCreateManyCompanyInput | CompanyClientCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    category?: CategoryCreateNestedOneWithoutProductsInput
    subcategory?: SubcategoryCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
    purchaseorder: PurchaseOrderCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    categoryId?: string | null
    subcategoryId?: string | null
    purchaseorderId: string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCreateManyCompanyInputEnvelope = {
    data: ProductCreateManyCompanyInput | ProductCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    products?: ProductCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    entries?: EntryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    entries?: EntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCompanyInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCompanyInput, CategoryUncheckedCreateWithoutCompanyInput>
  }

  export type CategoryCreateManyCompanyInputEnvelope = {
    data: CategoryCreateManyCompanyInput | CategoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SubcategoryCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    products?: ProductCreateNestedManyWithoutSubcategoryInput
    category?: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    categoryId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutCompanyInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutCompanyInput, SubcategoryUncheckedCreateWithoutCompanyInput>
  }

  export type SubcategoryCreateManyCompanyInputEnvelope = {
    data: SubcategoryCreateManyCompanyInput | SubcategoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutCompanyInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    entries?: EntryCreateNestedManyWithoutBillInput
    account?: AccountCreateNestedOneWithoutBillInput
    client?: ClientCreateNestedOneWithoutBillInput
    address?: AddressCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    accountId?: string | null
    clientId?: string | null
    addressId?: string | null
    entries?: EntryUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutCompanyInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutCompanyInput, BillUncheckedCreateWithoutCompanyInput>
  }

  export type BillCreateManyCompanyInputEnvelope = {
    data: BillCreateManyCompanyInput | BillCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TokenEntryCreateWithoutCompanyInput = {
    id?: string
    createdAt: Date | string
    tokenNo: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonNullValueInput | InputJsonValue
    totalQty: number
  }

  export type TokenEntryUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt: Date | string
    tokenNo: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonNullValueInput | InputJsonValue
    totalQty: number
  }

  export type TokenEntryCreateOrConnectWithoutCompanyInput = {
    where: TokenEntryWhereUniqueInput
    create: XOR<TokenEntryCreateWithoutCompanyInput, TokenEntryUncheckedCreateWithoutCompanyInput>
  }

  export type TokenEntryCreateManyCompanyInputEnvelope = {
    data: TokenEntryCreateManyCompanyInput | TokenEntryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutCompanyInput = {
    id?: string
    name: string
    phone: string
    bill?: BillCreateNestedManyWithoutAccountInput
    address?: AddressCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    phone: string
    bill?: BillUncheckedCreateNestedManyWithoutAccountInput
    address?: AddressUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountCreateManyCompanyInputEnvelope = {
    data: AccountCreateManyCompanyInput | AccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCategoryCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutExpensecategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutExpensecategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutCompanyInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCategoryCreateManyCompanyInputEnvelope = {
    data: ExpenseCategoryCreateManyCompanyInput | ExpenseCategoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutCompanyInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expensecategory: ExpenseCategoryCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCompanyInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expensecategoryId: string
  }

  export type ExpenseCreateOrConnectWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCreateManyCompanyInputEnvelope = {
    data: ExpenseCreateManyCompanyInput | ExpenseCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCompanyInput = {
    id?: string
    paymentDate?: Date | string
    paymentMode: string
    paymentReference?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutCompanyInput = {
    id?: string
    paymentDate?: Date | string
    paymentMode: string
    paymentReference?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentCreateManyCompanyInputEnvelope = {
    data: PaymentCreateManyCompanyInput | PaymentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VariantCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    product: ProductCreateNestedOneWithoutVariantsInput
    items?: ItemCreateNestedManyWithoutVariantInput
    entries?: EntryCreateNestedManyWithoutVariantInput
    VariantSizeBarcode?: VariantSizeBarcodeCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
    items?: ItemUncheckedCreateNestedManyWithoutVariantInput
    entries?: EntryUncheckedCreateNestedManyWithoutVariantInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutCompanyInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutCompanyInput, VariantUncheckedCreateWithoutCompanyInput>
  }

  export type VariantCreateManyCompanyInputEnvelope = {
    data: VariantCreateManyCompanyInput | VariantCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentType?: $Enums.paymentType | null
    products?: ProductCreateNestedManyWithoutPurchaseorderInput
    distributor?: DistributorCreateNestedOneWithoutPurchaseordersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    distributorId?: string | null
    paymentType?: $Enums.paymentType | null
    products?: ProductUncheckedCreateNestedManyWithoutPurchaseorderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderCreateManyCompanyInputEnvelope = {
    data: PurchaseOrderCreateManyCompanyInput | PurchaseOrderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutCompanyInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    size?: string | null
    variant: VariantCreateNestedOneWithoutItemsInput
    entry?: EntryCreateNestedOneWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCompanyInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variantId: string
    status?: string
    size?: string | null
    entry?: EntryUncheckedCreateNestedOneWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCompanyInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCompanyInput, ItemUncheckedCreateWithoutCompanyInput>
  }

  export type ItemCreateManyCompanyInputEnvelope = {
    data: ItemCreateManyCompanyInput | ItemCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PipelineCreateWithoutCompanyInput = {
    id?: string
    newClients?: ClientCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUncheckedCreateWithoutCompanyInput = {
    id?: string
    newClients?: ClientUncheckedCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientUncheckedCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientUncheckedCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientUncheckedCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientUncheckedCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineCreateOrConnectWithoutCompanyInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
  }

  export type NotificationCreateWithoutCompanyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
    client?: ClientCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId?: string | null
    clientId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCompanyInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCompanyInput, NotificationUncheckedCreateWithoutCompanyInput>
  }

  export type NotificationCreateManyCompanyInputEnvelope = {
    data: NotificationCreateManyCompanyInput | NotificationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    user?: UserCreateNestedOneWithoutAddressInput
    client?: ClientCreateNestedOneWithoutAddressInput
    distributor?: DistributorCreateNestedOneWithoutAddressInput
    account?: AccountCreateNestedOneWithoutAddressInput
    bill?: BillCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    clientId?: string | null
    distributorId?: string | null
    accountId?: string | null
    bill?: BillUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCompanyInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
  }

  export type DistributorCompanyCreateWithoutCompanyInput = {
    distributor: DistributorCreateNestedOneWithoutCompaniesInput
  }

  export type DistributorCompanyUncheckedCreateWithoutCompanyInput = {
    distributorId: string
  }

  export type DistributorCompanyCreateOrConnectWithoutCompanyInput = {
    where: DistributorCompanyWhereUniqueInput
    create: XOR<DistributorCompanyCreateWithoutCompanyInput, DistributorCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type DistributorCompanyCreateManyCompanyInputEnvelope = {
    data: DistributorCompanyCreateManyCompanyInput | DistributorCompanyCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyUserScalarWhereInput = {
    AND?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    OR?: CompanyUserScalarWhereInput[]
    NOT?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    companyId?: StringFilter<"CompanyUser"> | string
    userId?: StringFilter<"CompanyUser"> | string
  }

  export type CompanyClientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyClientWhereUniqueInput
    update: XOR<CompanyClientUpdateWithoutCompanyInput, CompanyClientUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyClientCreateWithoutCompanyInput, CompanyClientUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyClientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyClientWhereUniqueInput
    data: XOR<CompanyClientUpdateWithoutCompanyInput, CompanyClientUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyClientUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyClientScalarWhereInput
    data: XOR<CompanyClientUpdateManyMutationInput, CompanyClientUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyClientScalarWhereInput = {
    AND?: CompanyClientScalarWhereInput | CompanyClientScalarWhereInput[]
    OR?: CompanyClientScalarWhereInput[]
    NOT?: CompanyClientScalarWhereInput | CompanyClientScalarWhereInput[]
    companyId?: StringFilter<"CompanyClient"> | string
    clientId?: StringFilter<"CompanyClient"> | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCompanyInput, ProductUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCompanyInput, ProductUncheckedUpdateWithoutCompanyInput>
  }

  export type ProductUpdateManyWithWhereWithoutCompanyInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    brand?: StringNullableFilter<"Product"> | string | null
    status?: BoolFilter<"Product"> | boolean
    rating?: FloatNullableFilter<"Product"> | number | null
    description?: StringNullableFilter<"Product"> | string | null
    companyId?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    subcategoryId?: StringNullableFilter<"Product"> | string | null
    purchaseorderId?: StringFilter<"Product"> | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutCompanyInput, CategoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<CategoryCreateWithoutCompanyInput, CategoryUncheckedCreateWithoutCompanyInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutCompanyInput, CategoryUncheckedUpdateWithoutCompanyInput>
  }

  export type CategoryUpdateManyWithWhereWithoutCompanyInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    status?: BoolFilter<"Category"> | boolean
    image?: StringNullableFilter<"Category"> | string | null
    companyId?: StringFilter<"Category"> | string
    hsn?: StringNullableFilter<"Category"> | string | null
    taxType?: EnumTaxTypeFilter<"Category"> | $Enums.TaxType
    fixedTax?: FloatNullableFilter<"Category"> | number | null
    thresholdAmount?: FloatNullableFilter<"Category"> | number | null
    taxBelowThreshold?: FloatNullableFilter<"Category"> | number | null
    taxAboveThreshold?: FloatNullableFilter<"Category"> | number | null
  }

  export type SubcategoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SubcategoryWhereUniqueInput
    update: XOR<SubcategoryUpdateWithoutCompanyInput, SubcategoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<SubcategoryCreateWithoutCompanyInput, SubcategoryUncheckedCreateWithoutCompanyInput>
  }

  export type SubcategoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SubcategoryWhereUniqueInput
    data: XOR<SubcategoryUpdateWithoutCompanyInput, SubcategoryUncheckedUpdateWithoutCompanyInput>
  }

  export type SubcategoryUpdateManyWithWhereWithoutCompanyInput = {
    where: SubcategoryScalarWhereInput
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SubcategoryScalarWhereInput = {
    AND?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    OR?: SubcategoryScalarWhereInput[]
    NOT?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    createdAt?: DateTimeFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeFilter<"Subcategory"> | Date | string
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    status?: BoolFilter<"Subcategory"> | boolean
    image?: StringNullableFilter<"Subcategory"> | string | null
    companyId?: StringFilter<"Subcategory"> | string
    categoryId?: StringNullableFilter<"Subcategory"> | string | null
  }

  export type BillUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutCompanyInput, BillUncheckedUpdateWithoutCompanyInput>
    create: XOR<BillCreateWithoutCompanyInput, BillUncheckedCreateWithoutCompanyInput>
  }

  export type BillUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutCompanyInput, BillUncheckedUpdateWithoutCompanyInput>
  }

  export type BillUpdateManyWithWhereWithoutCompanyInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: StringFilter<"Bill"> | string
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    invoiceNumber?: IntNullableFilter<"Bill"> | number | null
    subtotal?: FloatNullableFilter<"Bill"> | number | null
    discount?: FloatNullableFilter<"Bill"> | number | null
    tax?: FloatNullableFilter<"Bill"> | number | null
    grandTotal?: FloatNullableFilter<"Bill"> | number | null
    deliveryFees?: FloatNullableFilter<"Bill"> | number | null
    paymentMethod?: StringNullableFilter<"Bill"> | string | null
    paymentStatus?: EnumPaymentStatusFilter<"Bill"> | $Enums.PaymentStatus
    transactionId?: StringNullableFilter<"Bill"> | string | null
    notes?: StringNullableFilter<"Bill"> | string | null
    type?: EnumOrderTypeNullableFilter<"Bill"> | $Enums.OrderType | null
    status?: EnumOrderStatusNullableFilter<"Bill"> | $Enums.OrderStatus | null
    deleted?: BoolNullableFilter<"Bill"> | boolean | null
    bookingDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    returnDeadline?: StringNullableFilter<"Bill"> | string | null
    companyId?: StringFilter<"Bill"> | string
    accountId?: StringNullableFilter<"Bill"> | string | null
    clientId?: StringNullableFilter<"Bill"> | string | null
    addressId?: StringNullableFilter<"Bill"> | string | null
  }

  export type TokenEntryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TokenEntryWhereUniqueInput
    update: XOR<TokenEntryUpdateWithoutCompanyInput, TokenEntryUncheckedUpdateWithoutCompanyInput>
    create: XOR<TokenEntryCreateWithoutCompanyInput, TokenEntryUncheckedCreateWithoutCompanyInput>
  }

  export type TokenEntryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TokenEntryWhereUniqueInput
    data: XOR<TokenEntryUpdateWithoutCompanyInput, TokenEntryUncheckedUpdateWithoutCompanyInput>
  }

  export type TokenEntryUpdateManyWithWhereWithoutCompanyInput = {
    where: TokenEntryScalarWhereInput
    data: XOR<TokenEntryUpdateManyMutationInput, TokenEntryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TokenEntryScalarWhereInput = {
    AND?: TokenEntryScalarWhereInput | TokenEntryScalarWhereInput[]
    OR?: TokenEntryScalarWhereInput[]
    NOT?: TokenEntryScalarWhereInput | TokenEntryScalarWhereInput[]
    id?: StringFilter<"TokenEntry"> | string
    createdAt?: DateTimeFilter<"TokenEntry"> | Date | string
    tokenNo?: StringFilter<"TokenEntry"> | string
    companyId?: StringFilter<"TokenEntry"> | string
    itemId?: StringFilter<"TokenEntry"> | string
    variantId?: StringFilter<"TokenEntry"> | string
    barcode?: StringFilter<"TokenEntry"> | string
    categoryId?: StringFilter<"TokenEntry"> | string
    size?: StringFilter<"TokenEntry"> | string
    name?: StringFilter<"TokenEntry"> | string
    qty?: IntFilter<"TokenEntry"> | number
    rate?: IntFilter<"TokenEntry"> | number
    discount?: IntFilter<"TokenEntry"> | number
    tax?: IntFilter<"TokenEntry"> | number
    value?: IntFilter<"TokenEntry"> | number
    sizes?: JsonFilter<"TokenEntry">
    totalQty?: IntFilter<"TokenEntry"> | number
  }

  export type AccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
  }

  export type AccountUpdateManyWithWhereWithoutCompanyInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    phone?: StringFilter<"Account"> | string
    companyId?: StringFilter<"Account"> | string
  }

  export type ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseCategoryWhereUniqueInput
    update: XOR<ExpenseCategoryUpdateWithoutCompanyInput, ExpenseCategoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseCategoryWhereUniqueInput
    data: XOR<ExpenseCategoryUpdateWithoutCompanyInput, ExpenseCategoryUncheckedUpdateWithoutCompanyInput>
  }

  export type ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput = {
    where: ExpenseCategoryScalarWhereInput
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExpenseCategoryScalarWhereInput = {
    AND?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    OR?: ExpenseCategoryScalarWhereInput[]
    NOT?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    status?: BoolFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    companyId?: StringFilter<"ExpenseCategory"> | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCompanyInput, ExpenseUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCompanyInput, ExpenseUncheckedUpdateWithoutCompanyInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCompanyInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    note?: StringNullableFilter<"Expense"> | string | null
    currency?: StringFilter<"Expense"> | string
    paymentMode?: EnumPaymentModeFilter<"Expense"> | $Enums.PaymentMode
    status?: StringFilter<"Expense"> | string
    receipt?: StringNullableFilter<"Expense"> | string | null
    receiptName?: StringNullableFilter<"Expense"> | string | null
    taxAmount?: FloatNullableFilter<"Expense"> | number | null
    totalAmount?: FloatFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    expensecategoryId?: StringFilter<"Expense"> | string
    companyId?: StringFilter<"Expense"> | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCompanyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMode?: StringFilter<"Payment"> | string
    paymentReference?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    companyId?: StringFilter<"Payment"> | string
  }

  export type VariantUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VariantWhereUniqueInput
    update: XOR<VariantUpdateWithoutCompanyInput, VariantUncheckedUpdateWithoutCompanyInput>
    create: XOR<VariantCreateWithoutCompanyInput, VariantUncheckedCreateWithoutCompanyInput>
  }

  export type VariantUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VariantWhereUniqueInput
    data: XOR<VariantUpdateWithoutCompanyInput, VariantUncheckedUpdateWithoutCompanyInput>
  }

  export type VariantUpdateManyWithWhereWithoutCompanyInput = {
    where: VariantScalarWhereInput
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VariantScalarWhereInput = {
    AND?: VariantScalarWhereInput | VariantScalarWhereInput[]
    OR?: VariantScalarWhereInput[]
    NOT?: VariantScalarWhereInput | VariantScalarWhereInput[]
    id?: StringFilter<"Variant"> | string
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    name?: StringFilter<"Variant"> | string
    code?: StringNullableFilter<"Variant"> | string | null
    status?: BoolFilter<"Variant"> | boolean
    sprice?: FloatFilter<"Variant"> | number
    pprice?: FloatNullableFilter<"Variant"> | number | null
    qty?: IntNullableFilter<"Variant"> | number | null
    discount?: FloatNullableFilter<"Variant"> | number | null
    dprice?: FloatNullableFilter<"Variant"> | number | null
    sizes?: JsonNullableFilter<"Variant">
    images?: StringNullableListFilter<"Variant">
    tax?: FloatFilter<"Variant"> | number
    productId?: StringFilter<"Variant"> | string
    companyId?: StringFilter<"Variant"> | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    distributorId?: StringNullableFilter<"PurchaseOrder"> | string | null
    paymentType?: EnumpaymentTypeNullableFilter<"PurchaseOrder"> | $Enums.paymentType | null
    companyId?: StringFilter<"PurchaseOrder"> | string
  }

  export type ItemUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCompanyInput, ItemUncheckedUpdateWithoutCompanyInput>
    create: XOR<ItemCreateWithoutCompanyInput, ItemUncheckedCreateWithoutCompanyInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCompanyInput, ItemUncheckedUpdateWithoutCompanyInput>
  }

  export type ItemUpdateManyWithWhereWithoutCompanyInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    barcode?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    variantId?: StringFilter<"Item"> | string
    status?: StringFilter<"Item"> | string
    size?: StringNullableFilter<"Item"> | string | null
    companyId?: StringFilter<"Item"> | string
  }

  export type PipelineUpsertWithoutCompanyInput = {
    update: XOR<PipelineUpdateWithoutCompanyInput, PipelineUncheckedUpdateWithoutCompanyInput>
    create: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutCompanyInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutCompanyInput, PipelineUncheckedUpdateWithoutCompanyInput>
  }

  export type PipelineUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUncheckedUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUncheckedUpdateManyWithoutClosePipelineNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCompanyInput, NotificationUncheckedUpdateWithoutCompanyInput>
    create: XOR<NotificationCreateWithoutCompanyInput, NotificationUncheckedCreateWithoutCompanyInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCompanyInput, NotificationUncheckedUpdateWithoutCompanyInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCompanyInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    companyId?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    clientId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionPath?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AddressUpsertWithoutCompanyInput = {
    update: XOR<AddressUpdateWithoutCompanyInput, AddressUncheckedUpdateWithoutCompanyInput>
    create: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutCompanyInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutCompanyInput, AddressUncheckedUpdateWithoutCompanyInput>
  }

  export type AddressUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAddressNestedInput
    client?: ClientUpdateOneWithoutAddressNestedInput
    distributor?: DistributorUpdateOneWithoutAddressNestedInput
    account?: AccountUpdateOneWithoutAddressNestedInput
    bill?: BillUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type DistributorCompanyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DistributorCompanyWhereUniqueInput
    update: XOR<DistributorCompanyUpdateWithoutCompanyInput, DistributorCompanyUncheckedUpdateWithoutCompanyInput>
    create: XOR<DistributorCompanyCreateWithoutCompanyInput, DistributorCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type DistributorCompanyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DistributorCompanyWhereUniqueInput
    data: XOR<DistributorCompanyUpdateWithoutCompanyInput, DistributorCompanyUncheckedUpdateWithoutCompanyInput>
  }

  export type DistributorCompanyUpdateManyWithWhereWithoutCompanyInput = {
    where: DistributorCompanyScalarWhereInput
    data: XOR<DistributorCompanyUpdateManyMutationInput, DistributorCompanyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DistributorCompanyScalarWhereInput = {
    AND?: DistributorCompanyScalarWhereInput | DistributorCompanyScalarWhereInput[]
    OR?: DistributorCompanyScalarWhereInput[]
    NOT?: DistributorCompanyScalarWhereInput | DistributorCompanyScalarWhereInput[]
    distributorId?: StringFilter<"DistributorCompany"> | string
    companyId?: StringFilter<"DistributorCompany"> | string
  }

  export type DistributorCompanyCreateWithoutDistributorInput = {
    company: CompanyCreateNestedOneWithoutDistributorInput
  }

  export type DistributorCompanyUncheckedCreateWithoutDistributorInput = {
    companyId: string
  }

  export type DistributorCompanyCreateOrConnectWithoutDistributorInput = {
    where: DistributorCompanyWhereUniqueInput
    create: XOR<DistributorCompanyCreateWithoutDistributorInput, DistributorCompanyUncheckedCreateWithoutDistributorInput>
  }

  export type DistributorCompanyCreateManyDistributorInputEnvelope = {
    data: DistributorCompanyCreateManyDistributorInput | DistributorCompanyCreateManyDistributorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutDistributorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentType?: $Enums.paymentType | null
    products?: ProductCreateNestedManyWithoutPurchaseorderInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutDistributorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentType?: $Enums.paymentType | null
    companyId: string
    products?: ProductUncheckedCreateNestedManyWithoutPurchaseorderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutDistributorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutDistributorInput, PurchaseOrderUncheckedCreateWithoutDistributorInput>
  }

  export type PurchaseOrderCreateManyDistributorInputEnvelope = {
    data: PurchaseOrderCreateManyDistributorInput | PurchaseOrderCreateManyDistributorInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutDistributorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    user?: UserCreateNestedOneWithoutAddressInput
    client?: ClientCreateNestedOneWithoutAddressInput
    company?: CompanyCreateNestedOneWithoutAddressInput
    account?: AccountCreateNestedOneWithoutAddressInput
    bill?: BillCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutDistributorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    clientId?: string | null
    companyId?: string | null
    accountId?: string | null
    bill?: BillUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutDistributorInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutDistributorInput, AddressUncheckedCreateWithoutDistributorInput>
  }

  export type DistributorCompanyUpsertWithWhereUniqueWithoutDistributorInput = {
    where: DistributorCompanyWhereUniqueInput
    update: XOR<DistributorCompanyUpdateWithoutDistributorInput, DistributorCompanyUncheckedUpdateWithoutDistributorInput>
    create: XOR<DistributorCompanyCreateWithoutDistributorInput, DistributorCompanyUncheckedCreateWithoutDistributorInput>
  }

  export type DistributorCompanyUpdateWithWhereUniqueWithoutDistributorInput = {
    where: DistributorCompanyWhereUniqueInput
    data: XOR<DistributorCompanyUpdateWithoutDistributorInput, DistributorCompanyUncheckedUpdateWithoutDistributorInput>
  }

  export type DistributorCompanyUpdateManyWithWhereWithoutDistributorInput = {
    where: DistributorCompanyScalarWhereInput
    data: XOR<DistributorCompanyUpdateManyMutationInput, DistributorCompanyUncheckedUpdateManyWithoutDistributorInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutDistributorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutDistributorInput, PurchaseOrderUncheckedUpdateWithoutDistributorInput>
    create: XOR<PurchaseOrderCreateWithoutDistributorInput, PurchaseOrderUncheckedCreateWithoutDistributorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutDistributorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutDistributorInput, PurchaseOrderUncheckedUpdateWithoutDistributorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutDistributorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutDistributorInput>
  }

  export type AddressUpsertWithoutDistributorInput = {
    update: XOR<AddressUpdateWithoutDistributorInput, AddressUncheckedUpdateWithoutDistributorInput>
    create: XOR<AddressCreateWithoutDistributorInput, AddressUncheckedCreateWithoutDistributorInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutDistributorInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutDistributorInput, AddressUncheckedUpdateWithoutDistributorInput>
  }

  export type AddressUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAddressNestedInput
    client?: ClientUpdateOneWithoutAddressNestedInput
    company?: CompanyUpdateOneWithoutAddressNestedInput
    account?: AccountUpdateOneWithoutAddressNestedInput
    bill?: BillUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type CompanyUserCreateWithoutUserInput = {
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type CompanyUserUncheckedCreateWithoutUserInput = {
    companyId: string
  }

  export type CompanyUserCreateOrConnectWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserCreateManyUserInputEnvelope = {
    data: CompanyUserCreateManyUserInput | CompanyUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    client?: ClientCreateNestedOneWithoutAddressInput
    distributor?: DistributorCreateNestedOneWithoutAddressInput
    company?: CompanyCreateNestedOneWithoutAddressInput
    account?: AccountCreateNestedOneWithoutAddressInput
    bill?: BillCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    clientId?: string | null
    distributorId?: string | null
    companyId?: string | null
    accountId?: string | null
    bill?: BillUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutNotificationsInput
    client?: ClientCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    clientId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserConversationCreateWithoutUserInput = {
    conversation: ConversationCreateNestedOneWithoutUsersInput
  }

  export type UserConversationUncheckedCreateWithoutUserInput = {
    conversationId: string
  }

  export type UserConversationCreateOrConnectWithoutUserInput = {
    where: UserConversationWhereUniqueInput
    create: XOR<UserConversationCreateWithoutUserInput, UserConversationUncheckedCreateWithoutUserInput>
  }

  export type UserConversationCreateManyUserInputEnvelope = {
    data: UserConversationCreateManyUserInput | UserConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserClientCreateWithoutUserInput = {
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserClientUncheckedCreateWithoutUserInput = {
    clientId: string
  }

  export type UserClientCreateOrConnectWithoutUserInput = {
    where: UserClientWhereUniqueInput
    create: XOR<UserClientCreateWithoutUserInput, UserClientUncheckedCreateWithoutUserInput>
  }

  export type UserClientCreateManyUserInputEnvelope = {
    data: UserClientCreateManyUserInput | UserClientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutUserInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressUpsertWithoutUserInput = {
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutUserInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUpdateOneWithoutAddressNestedInput
    distributor?: DistributorUpdateOneWithoutAddressNestedInput
    company?: CompanyUpdateOneWithoutAddressNestedInput
    account?: AccountUpdateOneWithoutAddressNestedInput
    bill?: BillUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserConversationWhereUniqueInput
    update: XOR<UserConversationUpdateWithoutUserInput, UserConversationUncheckedUpdateWithoutUserInput>
    create: XOR<UserConversationCreateWithoutUserInput, UserConversationUncheckedCreateWithoutUserInput>
  }

  export type UserConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserConversationWhereUniqueInput
    data: XOR<UserConversationUpdateWithoutUserInput, UserConversationUncheckedUpdateWithoutUserInput>
  }

  export type UserConversationUpdateManyWithWhereWithoutUserInput = {
    where: UserConversationScalarWhereInput
    data: XOR<UserConversationUpdateManyMutationInput, UserConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserConversationScalarWhereInput = {
    AND?: UserConversationScalarWhereInput | UserConversationScalarWhereInput[]
    OR?: UserConversationScalarWhereInput[]
    NOT?: UserConversationScalarWhereInput | UserConversationScalarWhereInput[]
    userId?: StringFilter<"UserConversation"> | string
    conversationId?: StringFilter<"UserConversation"> | string
  }

  export type UserClientUpsertWithWhereUniqueWithoutUserInput = {
    where: UserClientWhereUniqueInput
    update: XOR<UserClientUpdateWithoutUserInput, UserClientUncheckedUpdateWithoutUserInput>
    create: XOR<UserClientCreateWithoutUserInput, UserClientUncheckedCreateWithoutUserInput>
  }

  export type UserClientUpdateWithWhereUniqueWithoutUserInput = {
    where: UserClientWhereUniqueInput
    data: XOR<UserClientUpdateWithoutUserInput, UserClientUncheckedUpdateWithoutUserInput>
  }

  export type UserClientUpdateManyWithWhereWithoutUserInput = {
    where: UserClientScalarWhereInput
    data: XOR<UserClientUpdateManyMutationInput, UserClientUncheckedUpdateManyWithoutUserInput>
  }

  export type UserClientScalarWhereInput = {
    AND?: UserClientScalarWhereInput | UserClientScalarWhereInput[]
    OR?: UserClientScalarWhereInput[]
    NOT?: UserClientScalarWhereInput | UserClientScalarWhereInput[]
    clientId?: StringFilter<"UserClient"> | string
    userId?: StringFilter<"UserClient"> | string
  }

  export type CompanyClientCreateWithoutClientInput = {
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type CompanyClientUncheckedCreateWithoutClientInput = {
    companyId: string
  }

  export type CompanyClientCreateOrConnectWithoutClientInput = {
    where: CompanyClientWhereUniqueInput
    create: XOR<CompanyClientCreateWithoutClientInput, CompanyClientUncheckedCreateWithoutClientInput>
  }

  export type CompanyClientCreateManyClientInputEnvelope = {
    data: CompanyClientCreateManyClientInput | CompanyClientCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    user?: UserCreateNestedOneWithoutAddressInput
    distributor?: DistributorCreateNestedOneWithoutAddressInput
    company?: CompanyCreateNestedOneWithoutAddressInput
    account?: AccountCreateNestedOneWithoutAddressInput
    bill?: BillCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    distributorId?: string | null
    companyId?: string | null
    accountId?: string | null
    bill?: BillUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutClientInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput>
  }

  export type AddressCreateManyClientInputEnvelope = {
    data: AddressCreateManyClientInput | AddressCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutClientInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    entries?: EntryCreateNestedManyWithoutBillInput
    company: CompanyCreateNestedOneWithoutBillsInput
    account?: AccountCreateNestedOneWithoutBillInput
    address?: AddressCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutClientInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    accountId?: string | null
    addressId?: string | null
    entries?: EntryUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutClientInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutClientInput, BillUncheckedCreateWithoutClientInput>
  }

  export type ClientConversationCreateWithoutClientInput = {
    conversation: ConversationCreateNestedOneWithoutClientsInput
  }

  export type ClientConversationUncheckedCreateWithoutClientInput = {
    conversationId: string
  }

  export type ClientConversationCreateOrConnectWithoutClientInput = {
    where: ClientConversationWhereUniqueInput
    create: XOR<ClientConversationCreateWithoutClientInput, ClientConversationUncheckedCreateWithoutClientInput>
  }

  export type ClientConversationCreateManyClientInputEnvelope = {
    data: ClientConversationCreateManyClientInput | ClientConversationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserClientCreateWithoutClientInput = {
    user: UserCreateNestedOneWithoutClientsInput
  }

  export type UserClientUncheckedCreateWithoutClientInput = {
    userId: string
  }

  export type UserClientCreateOrConnectWithoutClientInput = {
    where: UserClientWhereUniqueInput
    create: XOR<UserClientCreateWithoutClientInput, UserClientUncheckedCreateWithoutClientInput>
  }

  export type UserClientCreateManyClientInputEnvelope = {
    data: UserClientCreateManyClientInput | UserClientCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PipelineCreateWithoutNewClientsInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutPipelineInput
    prospectClients?: ClientCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUncheckedCreateWithoutNewClientsInput = {
    id?: string
    companyId: string
    prospectClients?: ClientUncheckedCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientUncheckedCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientUncheckedCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientUncheckedCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineCreateOrConnectWithoutNewClientsInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutNewClientsInput, PipelineUncheckedCreateWithoutNewClientsInput>
  }

  export type PipelineCreateWithoutProspectClientsInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutPipelineInput
    newClients?: ClientCreateNestedManyWithoutNewPipelineInput
    viewingClients?: ClientCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUncheckedCreateWithoutProspectClientsInput = {
    id?: string
    companyId: string
    newClients?: ClientUncheckedCreateNestedManyWithoutNewPipelineInput
    viewingClients?: ClientUncheckedCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientUncheckedCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientUncheckedCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineCreateOrConnectWithoutProspectClientsInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutProspectClientsInput, PipelineUncheckedCreateWithoutProspectClientsInput>
  }

  export type PipelineCreateWithoutViewingClientsInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutPipelineInput
    newClients?: ClientCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientCreateNestedManyWithoutProspectPipelineInput
    rejectClients?: ClientCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUncheckedCreateWithoutViewingClientsInput = {
    id?: string
    companyId: string
    newClients?: ClientUncheckedCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientUncheckedCreateNestedManyWithoutProspectPipelineInput
    rejectClients?: ClientUncheckedCreateNestedManyWithoutRejectPipelineInput
    closeClients?: ClientUncheckedCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineCreateOrConnectWithoutViewingClientsInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutViewingClientsInput, PipelineUncheckedCreateWithoutViewingClientsInput>
  }

  export type PipelineCreateWithoutRejectClientsInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutPipelineInput
    newClients?: ClientCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientCreateNestedManyWithoutViewingPipelineInput
    closeClients?: ClientCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineUncheckedCreateWithoutRejectClientsInput = {
    id?: string
    companyId: string
    newClients?: ClientUncheckedCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientUncheckedCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientUncheckedCreateNestedManyWithoutViewingPipelineInput
    closeClients?: ClientUncheckedCreateNestedManyWithoutClosePipelineInput
  }

  export type PipelineCreateOrConnectWithoutRejectClientsInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutRejectClientsInput, PipelineUncheckedCreateWithoutRejectClientsInput>
  }

  export type PipelineCreateWithoutCloseClientsInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutPipelineInput
    newClients?: ClientCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientCreateNestedManyWithoutRejectPipelineInput
  }

  export type PipelineUncheckedCreateWithoutCloseClientsInput = {
    id?: string
    companyId: string
    newClients?: ClientUncheckedCreateNestedManyWithoutNewPipelineInput
    prospectClients?: ClientUncheckedCreateNestedManyWithoutProspectPipelineInput
    viewingClients?: ClientUncheckedCreateNestedManyWithoutViewingPipelineInput
    rejectClients?: ClientUncheckedCreateNestedManyWithoutRejectPipelineInput
  }

  export type PipelineCreateOrConnectWithoutCloseClientsInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutCloseClientsInput, PipelineUncheckedCreateWithoutCloseClientsInput>
  }

  export type NotificationCreateWithoutClientInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutNotificationsInput
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutClientInput = {
    id?: string
    companyId: string
    userId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutClientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutClientInput, NotificationUncheckedCreateWithoutClientInput>
  }

  export type NotificationCreateManyClientInputEnvelope = {
    data: NotificationCreateManyClientInput | NotificationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CompanyClientUpsertWithWhereUniqueWithoutClientInput = {
    where: CompanyClientWhereUniqueInput
    update: XOR<CompanyClientUpdateWithoutClientInput, CompanyClientUncheckedUpdateWithoutClientInput>
    create: XOR<CompanyClientCreateWithoutClientInput, CompanyClientUncheckedCreateWithoutClientInput>
  }

  export type CompanyClientUpdateWithWhereUniqueWithoutClientInput = {
    where: CompanyClientWhereUniqueInput
    data: XOR<CompanyClientUpdateWithoutClientInput, CompanyClientUncheckedUpdateWithoutClientInput>
  }

  export type CompanyClientUpdateManyWithWhereWithoutClientInput = {
    where: CompanyClientScalarWhereInput
    data: XOR<CompanyClientUpdateManyMutationInput, CompanyClientUncheckedUpdateManyWithoutClientInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutClientInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutClientInput, AddressUncheckedUpdateWithoutClientInput>
    create: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutClientInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutClientInput, AddressUncheckedUpdateWithoutClientInput>
  }

  export type AddressUpdateManyWithWhereWithoutClientInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutClientInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    name?: StringNullableFilter<"Address"> | string | null
    street?: StringFilter<"Address"> | string
    locality?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    pincode?: StringFilter<"Address"> | string
    active?: BoolFilter<"Address"> | boolean
    userId?: StringNullableFilter<"Address"> | string | null
    clientId?: StringNullableFilter<"Address"> | string | null
    distributorId?: StringNullableFilter<"Address"> | string | null
    companyId?: StringNullableFilter<"Address"> | string | null
    accountId?: StringNullableFilter<"Address"> | string | null
  }

  export type BillUpsertWithoutClientInput = {
    update: XOR<BillUpdateWithoutClientInput, BillUncheckedUpdateWithoutClientInput>
    create: XOR<BillCreateWithoutClientInput, BillUncheckedCreateWithoutClientInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutClientInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutClientInput, BillUncheckedUpdateWithoutClientInput>
  }

  export type BillUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUpdateManyWithoutBillNestedInput
    company?: CompanyUpdateOneRequiredWithoutBillsNestedInput
    account?: AccountUpdateOneWithoutBillNestedInput
    address?: AddressUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUncheckedUpdateManyWithoutBillNestedInput
  }

  export type ClientConversationUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientConversationWhereUniqueInput
    update: XOR<ClientConversationUpdateWithoutClientInput, ClientConversationUncheckedUpdateWithoutClientInput>
    create: XOR<ClientConversationCreateWithoutClientInput, ClientConversationUncheckedCreateWithoutClientInput>
  }

  export type ClientConversationUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientConversationWhereUniqueInput
    data: XOR<ClientConversationUpdateWithoutClientInput, ClientConversationUncheckedUpdateWithoutClientInput>
  }

  export type ClientConversationUpdateManyWithWhereWithoutClientInput = {
    where: ClientConversationScalarWhereInput
    data: XOR<ClientConversationUpdateManyMutationInput, ClientConversationUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientConversationScalarWhereInput = {
    AND?: ClientConversationScalarWhereInput | ClientConversationScalarWhereInput[]
    OR?: ClientConversationScalarWhereInput[]
    NOT?: ClientConversationScalarWhereInput | ClientConversationScalarWhereInput[]
    clientId?: StringFilter<"ClientConversation"> | string
    conversationId?: StringFilter<"ClientConversation"> | string
  }

  export type UserClientUpsertWithWhereUniqueWithoutClientInput = {
    where: UserClientWhereUniqueInput
    update: XOR<UserClientUpdateWithoutClientInput, UserClientUncheckedUpdateWithoutClientInput>
    create: XOR<UserClientCreateWithoutClientInput, UserClientUncheckedCreateWithoutClientInput>
  }

  export type UserClientUpdateWithWhereUniqueWithoutClientInput = {
    where: UserClientWhereUniqueInput
    data: XOR<UserClientUpdateWithoutClientInput, UserClientUncheckedUpdateWithoutClientInput>
  }

  export type UserClientUpdateManyWithWhereWithoutClientInput = {
    where: UserClientScalarWhereInput
    data: XOR<UserClientUpdateManyMutationInput, UserClientUncheckedUpdateManyWithoutClientInput>
  }

  export type PipelineUpsertWithoutNewClientsInput = {
    update: XOR<PipelineUpdateWithoutNewClientsInput, PipelineUncheckedUpdateWithoutNewClientsInput>
    create: XOR<PipelineCreateWithoutNewClientsInput, PipelineUncheckedCreateWithoutNewClientsInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutNewClientsInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutNewClientsInput, PipelineUncheckedUpdateWithoutNewClientsInput>
  }

  export type PipelineUpdateWithoutNewClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPipelineNestedInput
    prospectClients?: ClientUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutNewClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    prospectClients?: ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUncheckedUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUpsertWithoutProspectClientsInput = {
    update: XOR<PipelineUpdateWithoutProspectClientsInput, PipelineUncheckedUpdateWithoutProspectClientsInput>
    create: XOR<PipelineCreateWithoutProspectClientsInput, PipelineUncheckedCreateWithoutProspectClientsInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutProspectClientsInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutProspectClientsInput, PipelineUncheckedUpdateWithoutProspectClientsInput>
  }

  export type PipelineUpdateWithoutProspectClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPipelineNestedInput
    newClients?: ClientUpdateManyWithoutNewPipelineNestedInput
    viewingClients?: ClientUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutProspectClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUncheckedUpdateManyWithoutNewPipelineNestedInput
    viewingClients?: ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUncheckedUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUpsertWithoutViewingClientsInput = {
    update: XOR<PipelineUpdateWithoutViewingClientsInput, PipelineUncheckedUpdateWithoutViewingClientsInput>
    create: XOR<PipelineCreateWithoutViewingClientsInput, PipelineUncheckedCreateWithoutViewingClientsInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutViewingClientsInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutViewingClientsInput, PipelineUncheckedUpdateWithoutViewingClientsInput>
  }

  export type PipelineUpdateWithoutViewingClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPipelineNestedInput
    newClients?: ClientUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUpdateManyWithoutProspectPipelineNestedInput
    rejectClients?: ClientUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutViewingClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUncheckedUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput
    rejectClients?: ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput
    closeClients?: ClientUncheckedUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUpsertWithoutRejectClientsInput = {
    update: XOR<PipelineUpdateWithoutRejectClientsInput, PipelineUncheckedUpdateWithoutRejectClientsInput>
    create: XOR<PipelineCreateWithoutRejectClientsInput, PipelineUncheckedCreateWithoutRejectClientsInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutRejectClientsInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutRejectClientsInput, PipelineUncheckedUpdateWithoutRejectClientsInput>
  }

  export type PipelineUpdateWithoutRejectClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPipelineNestedInput
    newClients?: ClientUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUpdateManyWithoutViewingPipelineNestedInput
    closeClients?: ClientUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutRejectClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUncheckedUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput
    closeClients?: ClientUncheckedUpdateManyWithoutClosePipelineNestedInput
  }

  export type PipelineUpsertWithoutCloseClientsInput = {
    update: XOR<PipelineUpdateWithoutCloseClientsInput, PipelineUncheckedUpdateWithoutCloseClientsInput>
    create: XOR<PipelineCreateWithoutCloseClientsInput, PipelineUncheckedCreateWithoutCloseClientsInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutCloseClientsInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutCloseClientsInput, PipelineUncheckedUpdateWithoutCloseClientsInput>
  }

  export type PipelineUpdateWithoutCloseClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPipelineNestedInput
    newClients?: ClientUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUpdateManyWithoutRejectPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutCloseClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    newClients?: ClientUncheckedUpdateManyWithoutNewPipelineNestedInput
    prospectClients?: ClientUncheckedUpdateManyWithoutProspectPipelineNestedInput
    viewingClients?: ClientUncheckedUpdateManyWithoutViewingPipelineNestedInput
    rejectClients?: ClientUncheckedUpdateManyWithoutRejectPipelineNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutClientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutClientInput, NotificationUncheckedUpdateWithoutClientInput>
    create: XOR<NotificationCreateWithoutClientInput, NotificationUncheckedCreateWithoutClientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutClientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutClientInput, NotificationUncheckedUpdateWithoutClientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutClientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutClientInput>
  }

  export type CompanyCreateWithoutPipelineInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPipelineInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPipelineInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPipelineInput, CompanyUncheckedCreateWithoutPipelineInput>
  }

  export type ClientCreateWithoutNewPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutNewPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutNewPipelineInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutNewPipelineInput, ClientUncheckedCreateWithoutNewPipelineInput>
  }

  export type ClientCreateManyNewPipelineInputEnvelope = {
    data: ClientCreateManyNewPipelineInput | ClientCreateManyNewPipelineInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutProspectPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProspectPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProspectPipelineInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProspectPipelineInput, ClientUncheckedCreateWithoutProspectPipelineInput>
  }

  export type ClientCreateManyProspectPipelineInputEnvelope = {
    data: ClientCreateManyProspectPipelineInput | ClientCreateManyProspectPipelineInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutViewingPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutViewingPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutViewingPipelineInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutViewingPipelineInput, ClientUncheckedCreateWithoutViewingPipelineInput>
  }

  export type ClientCreateManyViewingPipelineInputEnvelope = {
    data: ClientCreateManyViewingPipelineInput | ClientCreateManyViewingPipelineInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutRejectPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutRejectPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutRejectPipelineInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRejectPipelineInput, ClientUncheckedCreateWithoutRejectPipelineInput>
  }

  export type ClientCreateManyRejectPipelineInputEnvelope = {
    data: ClientCreateManyRejectPipelineInput | ClientCreateManyRejectPipelineInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutClosePipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClosePipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClosePipelineInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClosePipelineInput, ClientUncheckedCreateWithoutClosePipelineInput>
  }

  export type ClientCreateManyClosePipelineInputEnvelope = {
    data: ClientCreateManyClosePipelineInput | ClientCreateManyClosePipelineInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPipelineInput = {
    update: XOR<CompanyUpdateWithoutPipelineInput, CompanyUncheckedUpdateWithoutPipelineInput>
    create: XOR<CompanyCreateWithoutPipelineInput, CompanyUncheckedCreateWithoutPipelineInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPipelineInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPipelineInput, CompanyUncheckedUpdateWithoutPipelineInput>
  }

  export type CompanyUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientUpsertWithWhereUniqueWithoutNewPipelineInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutNewPipelineInput, ClientUncheckedUpdateWithoutNewPipelineInput>
    create: XOR<ClientCreateWithoutNewPipelineInput, ClientUncheckedCreateWithoutNewPipelineInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutNewPipelineInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutNewPipelineInput, ClientUncheckedUpdateWithoutNewPipelineInput>
  }

  export type ClientUpdateManyWithWhereWithoutNewPipelineInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutNewPipelineInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    name?: StringFilter<"Client"> | string
    password?: StringNullableFilter<"Client"> | string | null
    phone?: StringFilter<"Client"> | string
    status?: BoolFilter<"Client"> | boolean
    pipelineStatus?: StringFilter<"Client"> | string
    newPipelineId?: StringNullableFilter<"Client"> | string | null
    prospectPipelineId?: StringNullableFilter<"Client"> | string | null
    viewingPipelineId?: StringNullableFilter<"Client"> | string | null
    rejectPipelineId?: StringNullableFilter<"Client"> | string | null
    closePipelineId?: StringNullableFilter<"Client"> | string | null
  }

  export type ClientUpsertWithWhereUniqueWithoutProspectPipelineInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutProspectPipelineInput, ClientUncheckedUpdateWithoutProspectPipelineInput>
    create: XOR<ClientCreateWithoutProspectPipelineInput, ClientUncheckedCreateWithoutProspectPipelineInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutProspectPipelineInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutProspectPipelineInput, ClientUncheckedUpdateWithoutProspectPipelineInput>
  }

  export type ClientUpdateManyWithWhereWithoutProspectPipelineInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutProspectPipelineInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutViewingPipelineInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutViewingPipelineInput, ClientUncheckedUpdateWithoutViewingPipelineInput>
    create: XOR<ClientCreateWithoutViewingPipelineInput, ClientUncheckedCreateWithoutViewingPipelineInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutViewingPipelineInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutViewingPipelineInput, ClientUncheckedUpdateWithoutViewingPipelineInput>
  }

  export type ClientUpdateManyWithWhereWithoutViewingPipelineInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutViewingPipelineInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutRejectPipelineInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutRejectPipelineInput, ClientUncheckedUpdateWithoutRejectPipelineInput>
    create: XOR<ClientCreateWithoutRejectPipelineInput, ClientUncheckedCreateWithoutRejectPipelineInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutRejectPipelineInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutRejectPipelineInput, ClientUncheckedUpdateWithoutRejectPipelineInput>
  }

  export type ClientUpdateManyWithWhereWithoutRejectPipelineInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutRejectPipelineInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutClosePipelineInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutClosePipelineInput, ClientUncheckedUpdateWithoutClosePipelineInput>
    create: XOR<ClientCreateWithoutClosePipelineInput, ClientUncheckedCreateWithoutClosePipelineInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutClosePipelineInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutClosePipelineInput, ClientUncheckedUpdateWithoutClosePipelineInput>
  }

  export type ClientUpdateManyWithWhereWithoutClosePipelineInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutClosePipelineInput>
  }

  export type CompanyCreateWithoutCategoriesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCategoriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCategoriesInput, CompanyUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    company: CompanyCreateNestedOneWithoutProductsInput
    subcategory?: SubcategoryCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
    purchaseorder: PurchaseOrderCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    subcategoryId?: string | null
    purchaseorderId: string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubcategoryCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    company: CompanyCreateNestedOneWithoutSubcategoriesInput
    products?: ProductCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    products?: ProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryCreateManyCategoryInputEnvelope = {
    data: SubcategoryCreateManyCategoryInput | SubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EntryCreateWithoutCategoryInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    variant?: VariantCreateNestedOneWithoutEntriesInput
    bill?: BillCreateNestedOneWithoutEntriesInput
    item?: ItemCreateNestedOneWithoutEntryInput
  }

  export type EntryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    billId?: string | null
    itemId?: string | null
  }

  export type EntryCreateOrConnectWithoutCategoryInput = {
    where: EntryWhereUniqueInput
    create: XOR<EntryCreateWithoutCategoryInput, EntryUncheckedCreateWithoutCategoryInput>
  }

  export type EntryCreateManyCategoryInputEnvelope = {
    data: EntryCreateManyCategoryInput | EntryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutCategoriesInput = {
    update: XOR<CompanyUpdateWithoutCategoriesInput, CompanyUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CompanyCreateWithoutCategoriesInput, CompanyUncheckedCreateWithoutCategoriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCategoriesInput, CompanyUncheckedUpdateWithoutCategoriesInput>
  }

  export type CompanyUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    update: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    data: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubcategoryScalarWhereInput
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EntryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EntryWhereUniqueInput
    update: XOR<EntryUpdateWithoutCategoryInput, EntryUncheckedUpdateWithoutCategoryInput>
    create: XOR<EntryCreateWithoutCategoryInput, EntryUncheckedCreateWithoutCategoryInput>
  }

  export type EntryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EntryWhereUniqueInput
    data: XOR<EntryUpdateWithoutCategoryInput, EntryUncheckedUpdateWithoutCategoryInput>
  }

  export type EntryUpdateManyWithWhereWithoutCategoryInput = {
    where: EntryScalarWhereInput
    data: XOR<EntryUpdateManyMutationInput, EntryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EntryScalarWhereInput = {
    AND?: EntryScalarWhereInput | EntryScalarWhereInput[]
    OR?: EntryScalarWhereInput[]
    NOT?: EntryScalarWhereInput | EntryScalarWhereInput[]
    id?: StringFilter<"Entry"> | string
    name?: StringNullableFilter<"Entry"> | string | null
    barcode?: StringNullableFilter<"Entry"> | string | null
    qty?: FloatNullableFilter<"Entry"> | number | null
    rate?: FloatNullableFilter<"Entry"> | number | null
    discount?: FloatNullableFilter<"Entry"> | number | null
    tax?: FloatNullableFilter<"Entry"> | number | null
    value?: FloatNullableFilter<"Entry"> | number | null
    size?: StringNullableFilter<"Entry"> | string | null
    variantId?: StringNullableFilter<"Entry"> | string | null
    outOfStock?: BoolNullableFilter<"Entry"> | boolean | null
    categoryId?: StringNullableFilter<"Entry"> | string | null
    billId?: StringNullableFilter<"Entry"> | string | null
    itemId?: StringNullableFilter<"Entry"> | string | null
  }

  export type CompanyCreateWithoutSubcategoriesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSubcategoriesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSubcategoriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSubcategoriesInput, CompanyUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ProductCreateWithoutSubcategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
    purchaseorder: PurchaseOrderCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutSubcategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    purchaseorderId: string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSubcategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput>
  }

  export type ProductCreateManySubcategoryInputEnvelope = {
    data: ProductCreateManySubcategoryInput | ProductCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutSubcategoriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    company: CompanyCreateNestedOneWithoutCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    entries?: EntryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    entries?: EntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type CompanyUpsertWithoutSubcategoriesInput = {
    update: XOR<CompanyUpdateWithoutSubcategoriesInput, CompanyUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CompanyCreateWithoutSubcategoriesInput, CompanyUncheckedCreateWithoutSubcategoriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSubcategoriesInput, CompanyUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CompanyUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSubcategoryInput, ProductUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSubcategoryInput, ProductUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type CategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CategoryUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    entries?: EntryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: EntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CompanyCreateWithoutProductsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProductsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    company: CompanyCreateNestedOneWithoutCategoriesInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    entries?: EntryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    entries?: EntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type SubcategoryCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    company: CompanyCreateNestedOneWithoutSubcategoriesInput
    category?: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    categoryId?: string | null
  }

  export type SubcategoryCreateOrConnectWithoutProductsInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutProductsInput, SubcategoryUncheckedCreateWithoutProductsInput>
  }

  export type VariantCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    items?: ItemCreateNestedManyWithoutVariantInput
    entries?: EntryCreateNestedManyWithoutVariantInput
    company: CompanyCreateNestedOneWithoutVariantsInput
    VariantSizeBarcode?: VariantSizeBarcodeCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    companyId: string
    items?: ItemUncheckedCreateNestedManyWithoutVariantInput
    entries?: EntryUncheckedCreateNestedManyWithoutVariantInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutProductInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput>
  }

  export type VariantCreateManyProductInputEnvelope = {
    data: VariantCreateManyProductInput | VariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentType?: $Enums.paymentType | null
    distributor?: DistributorCreateNestedOneWithoutPurchaseordersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    distributorId?: string | null
    paymentType?: $Enums.paymentType | null
    companyId: string
  }

  export type PurchaseOrderCreateOrConnectWithoutProductsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutProductsInput, PurchaseOrderUncheckedCreateWithoutProductsInput>
  }

  export type CompanyUpsertWithoutProductsInput = {
    update: XOR<CompanyUpdateWithoutProductsInput, CompanyUncheckedUpdateWithoutProductsInput>
    create: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProductsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProductsInput, CompanyUncheckedUpdateWithoutProductsInput>
  }

  export type CompanyUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutCategoriesNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    entries?: EntryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: EntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SubcategoryUpsertWithoutProductsInput = {
    update: XOR<SubcategoryUpdateWithoutProductsInput, SubcategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<SubcategoryCreateWithoutProductsInput, SubcategoryUncheckedCreateWithoutProductsInput>
    where?: SubcategoryWhereInput
  }

  export type SubcategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: SubcategoryWhereInput
    data: XOR<SubcategoryUpdateWithoutProductsInput, SubcategoryUncheckedUpdateWithoutProductsInput>
  }

  export type SubcategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutSubcategoriesNestedInput
    category?: CategoryUpdateOneWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VariantUpsertWithWhereUniqueWithoutProductInput = {
    where: VariantWhereUniqueInput
    update: XOR<VariantUpdateWithoutProductInput, VariantUncheckedUpdateWithoutProductInput>
    create: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput>
  }

  export type VariantUpdateWithWhereUniqueWithoutProductInput = {
    where: VariantWhereUniqueInput
    data: XOR<VariantUpdateWithoutProductInput, VariantUncheckedUpdateWithoutProductInput>
  }

  export type VariantUpdateManyWithWhereWithoutProductInput = {
    where: VariantScalarWhereInput
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseOrderUpsertWithoutProductsInput = {
    update: XOR<PurchaseOrderUpdateWithoutProductsInput, PurchaseOrderUncheckedUpdateWithoutProductsInput>
    create: XOR<PurchaseOrderCreateWithoutProductsInput, PurchaseOrderUncheckedCreateWithoutProductsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutProductsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutProductsInput, PurchaseOrderUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseOrderUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    distributor?: DistributorUpdateOneWithoutPurchaseordersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    subcategory?: SubcategoryCreateNestedOneWithoutProductsInput
    purchaseorder: PurchaseOrderCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    subcategoryId?: string | null
    purchaseorderId: string
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type ItemCreateWithoutVariantInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    size?: string | null
    entry?: EntryCreateNestedOneWithoutItemInput
    company: CompanyCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutVariantInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    size?: string | null
    companyId: string
    entry?: EntryUncheckedCreateNestedOneWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutVariantInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutVariantInput, ItemUncheckedCreateWithoutVariantInput>
  }

  export type ItemCreateManyVariantInputEnvelope = {
    data: ItemCreateManyVariantInput | ItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type EntryCreateWithoutVariantInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    category?: CategoryCreateNestedOneWithoutEntriesInput
    bill?: BillCreateNestedOneWithoutEntriesInput
    item?: ItemCreateNestedOneWithoutEntryInput
  }

  export type EntryUncheckedCreateWithoutVariantInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    billId?: string | null
    itemId?: string | null
  }

  export type EntryCreateOrConnectWithoutVariantInput = {
    where: EntryWhereUniqueInput
    create: XOR<EntryCreateWithoutVariantInput, EntryUncheckedCreateWithoutVariantInput>
  }

  export type EntryCreateManyVariantInputEnvelope = {
    data: EntryCreateManyVariantInput | EntryCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutVariantsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVariantsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVariantsInput, CompanyUncheckedCreateWithoutVariantsInput>
  }

  export type VariantSizeBarcodeCreateWithoutVariantInput = {
    size?: string | null
    barcode: string
  }

  export type VariantSizeBarcodeUncheckedCreateWithoutVariantInput = {
    id?: number
    size?: string | null
    barcode: string
  }

  export type VariantSizeBarcodeCreateOrConnectWithoutVariantInput = {
    where: VariantSizeBarcodeWhereUniqueInput
    create: XOR<VariantSizeBarcodeCreateWithoutVariantInput, VariantSizeBarcodeUncheckedCreateWithoutVariantInput>
  }

  export type VariantSizeBarcodeCreateManyVariantInputEnvelope = {
    data: VariantSizeBarcodeCreateManyVariantInput | VariantSizeBarcodeCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutProductsNestedInput
    purchaseorder?: PurchaseOrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutVariantInput, ItemUncheckedUpdateWithoutVariantInput>
    create: XOR<ItemCreateWithoutVariantInput, ItemUncheckedCreateWithoutVariantInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutVariantInput, ItemUncheckedUpdateWithoutVariantInput>
  }

  export type ItemUpdateManyWithWhereWithoutVariantInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type EntryUpsertWithWhereUniqueWithoutVariantInput = {
    where: EntryWhereUniqueInput
    update: XOR<EntryUpdateWithoutVariantInput, EntryUncheckedUpdateWithoutVariantInput>
    create: XOR<EntryCreateWithoutVariantInput, EntryUncheckedCreateWithoutVariantInput>
  }

  export type EntryUpdateWithWhereUniqueWithoutVariantInput = {
    where: EntryWhereUniqueInput
    data: XOR<EntryUpdateWithoutVariantInput, EntryUncheckedUpdateWithoutVariantInput>
  }

  export type EntryUpdateManyWithWhereWithoutVariantInput = {
    where: EntryScalarWhereInput
    data: XOR<EntryUpdateManyMutationInput, EntryUncheckedUpdateManyWithoutVariantInput>
  }

  export type CompanyUpsertWithoutVariantsInput = {
    update: XOR<CompanyUpdateWithoutVariantsInput, CompanyUncheckedUpdateWithoutVariantsInput>
    create: XOR<CompanyCreateWithoutVariantsInput, CompanyUncheckedCreateWithoutVariantsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVariantsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVariantsInput, CompanyUncheckedUpdateWithoutVariantsInput>
  }

  export type CompanyUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VariantSizeBarcodeUpsertWithWhereUniqueWithoutVariantInput = {
    where: VariantSizeBarcodeWhereUniqueInput
    update: XOR<VariantSizeBarcodeUpdateWithoutVariantInput, VariantSizeBarcodeUncheckedUpdateWithoutVariantInput>
    create: XOR<VariantSizeBarcodeCreateWithoutVariantInput, VariantSizeBarcodeUncheckedCreateWithoutVariantInput>
  }

  export type VariantSizeBarcodeUpdateWithWhereUniqueWithoutVariantInput = {
    where: VariantSizeBarcodeWhereUniqueInput
    data: XOR<VariantSizeBarcodeUpdateWithoutVariantInput, VariantSizeBarcodeUncheckedUpdateWithoutVariantInput>
  }

  export type VariantSizeBarcodeUpdateManyWithWhereWithoutVariantInput = {
    where: VariantSizeBarcodeScalarWhereInput
    data: XOR<VariantSizeBarcodeUpdateManyMutationInput, VariantSizeBarcodeUncheckedUpdateManyWithoutVariantInput>
  }

  export type VariantSizeBarcodeScalarWhereInput = {
    AND?: VariantSizeBarcodeScalarWhereInput | VariantSizeBarcodeScalarWhereInput[]
    OR?: VariantSizeBarcodeScalarWhereInput[]
    NOT?: VariantSizeBarcodeScalarWhereInput | VariantSizeBarcodeScalarWhereInput[]
    id?: IntFilter<"VariantSizeBarcode"> | number
    variantId?: StringFilter<"VariantSizeBarcode"> | string
    size?: StringNullableFilter<"VariantSizeBarcode"> | string | null
    barcode?: StringFilter<"VariantSizeBarcode"> | string
  }

  export type VariantCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    product: ProductCreateNestedOneWithoutVariantsInput
    entries?: EntryCreateNestedManyWithoutVariantInput
    company: CompanyCreateNestedOneWithoutVariantsInput
    VariantSizeBarcode?: VariantSizeBarcodeCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
    companyId: string
    entries?: EntryUncheckedCreateNestedManyWithoutVariantInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutItemsInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutItemsInput, VariantUncheckedCreateWithoutItemsInput>
  }

  export type EntryCreateWithoutItemInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    variant?: VariantCreateNestedOneWithoutEntriesInput
    category?: CategoryCreateNestedOneWithoutEntriesInput
    bill?: BillCreateNestedOneWithoutEntriesInput
  }

  export type EntryUncheckedCreateWithoutItemInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    billId?: string | null
  }

  export type EntryCreateOrConnectWithoutItemInput = {
    where: EntryWhereUniqueInput
    create: XOR<EntryCreateWithoutItemInput, EntryUncheckedCreateWithoutItemInput>
  }

  export type CompanyCreateWithoutItemsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutItemsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutItemsInput, CompanyUncheckedCreateWithoutItemsInput>
  }

  export type VariantUpsertWithoutItemsInput = {
    update: XOR<VariantUpdateWithoutItemsInput, VariantUncheckedUpdateWithoutItemsInput>
    create: XOR<VariantCreateWithoutItemsInput, VariantUncheckedCreateWithoutItemsInput>
    where?: VariantWhereInput
  }

  export type VariantUpdateToOneWithWhereWithoutItemsInput = {
    where?: VariantWhereInput
    data: XOR<VariantUpdateWithoutItemsInput, VariantUncheckedUpdateWithoutItemsInput>
  }

  export type VariantUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    entries?: EntryUpdateManyWithoutVariantNestedInput
    company?: CompanyUpdateOneRequiredWithoutVariantsNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entries?: EntryUncheckedUpdateManyWithoutVariantNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type EntryUpsertWithoutItemInput = {
    update: XOR<EntryUpdateWithoutItemInput, EntryUncheckedUpdateWithoutItemInput>
    create: XOR<EntryCreateWithoutItemInput, EntryUncheckedCreateWithoutItemInput>
    where?: EntryWhereInput
  }

  export type EntryUpdateToOneWithWhereWithoutItemInput = {
    where?: EntryWhereInput
    data: XOR<EntryUpdateWithoutItemInput, EntryUncheckedUpdateWithoutItemInput>
  }

  export type EntryUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    variant?: VariantUpdateOneWithoutEntriesNestedInput
    category?: CategoryUpdateOneWithoutEntriesNestedInput
    bill?: BillUpdateOneWithoutEntriesNestedInput
  }

  export type EntryUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyUpsertWithoutItemsInput = {
    update: XOR<CompanyUpdateWithoutItemsInput, CompanyUncheckedUpdateWithoutItemsInput>
    create: XOR<CompanyCreateWithoutItemsInput, CompanyUncheckedCreateWithoutItemsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutItemsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutItemsInput, CompanyUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductCreateWithoutPurchaseorderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    subcategory?: SubcategoryCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseorderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    subcategoryId?: string | null
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseorderInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseorderInput, ProductUncheckedCreateWithoutPurchaseorderInput>
  }

  export type ProductCreateManyPurchaseorderInputEnvelope = {
    data: ProductCreateManyPurchaseorderInput | ProductCreateManyPurchaseorderInput[]
    skipDuplicates?: boolean
  }

  export type DistributorCreateWithoutPurchaseordersInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    companies?: DistributorCompanyCreateNestedManyWithoutDistributorInput
    address?: AddressCreateNestedOneWithoutDistributorInput
  }

  export type DistributorUncheckedCreateWithoutPurchaseordersInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    companies?: DistributorCompanyUncheckedCreateNestedManyWithoutDistributorInput
    address?: AddressUncheckedCreateNestedOneWithoutDistributorInput
  }

  export type DistributorCreateOrConnectWithoutPurchaseordersInput = {
    where: DistributorWhereUniqueInput
    create: XOR<DistributorCreateWithoutPurchaseordersInput, DistributorUncheckedCreateWithoutPurchaseordersInput>
  }

  export type CompanyCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseOrdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutPurchaseorderInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPurchaseorderInput, ProductUncheckedUpdateWithoutPurchaseorderInput>
    create: XOR<ProductCreateWithoutPurchaseorderInput, ProductUncheckedCreateWithoutPurchaseorderInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPurchaseorderInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPurchaseorderInput, ProductUncheckedUpdateWithoutPurchaseorderInput>
  }

  export type ProductUpdateManyWithWhereWithoutPurchaseorderInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutPurchaseorderInput>
  }

  export type DistributorUpsertWithoutPurchaseordersInput = {
    update: XOR<DistributorUpdateWithoutPurchaseordersInput, DistributorUncheckedUpdateWithoutPurchaseordersInput>
    create: XOR<DistributorCreateWithoutPurchaseordersInput, DistributorUncheckedCreateWithoutPurchaseordersInput>
    where?: DistributorWhereInput
  }

  export type DistributorUpdateToOneWithWhereWithoutPurchaseordersInput = {
    where?: DistributorWhereInput
    data: XOR<DistributorUpdateWithoutPurchaseordersInput, DistributorUncheckedUpdateWithoutPurchaseordersInput>
  }

  export type DistributorUpdateWithoutPurchaseordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: DistributorCompanyUpdateManyWithoutDistributorNestedInput
    address?: AddressUpdateOneWithoutDistributorNestedInput
  }

  export type DistributorUncheckedUpdateWithoutPurchaseordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: DistributorCompanyUncheckedUpdateManyWithoutDistributorNestedInput
    address?: AddressUncheckedUpdateOneWithoutDistributorNestedInput
  }

  export type CompanyUpsertWithoutPurchaseOrdersInput = {
    update: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CompanyUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EntryCreateWithoutBillInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    variant?: VariantCreateNestedOneWithoutEntriesInput
    category?: CategoryCreateNestedOneWithoutEntriesInput
    item?: ItemCreateNestedOneWithoutEntryInput
  }

  export type EntryUncheckedCreateWithoutBillInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    itemId?: string | null
  }

  export type EntryCreateOrConnectWithoutBillInput = {
    where: EntryWhereUniqueInput
    create: XOR<EntryCreateWithoutBillInput, EntryUncheckedCreateWithoutBillInput>
  }

  export type EntryCreateManyBillInputEnvelope = {
    data: EntryCreateManyBillInput | EntryCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutBillsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBillsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBillsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBillsInput, CompanyUncheckedCreateWithoutBillsInput>
  }

  export type AccountCreateWithoutBillInput = {
    id?: string
    name: string
    phone: string
    address?: AddressCreateNestedOneWithoutAccountInput
    company: CompanyCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutBillInput = {
    id?: string
    name: string
    phone: string
    companyId: string
    address?: AddressUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutBillInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBillInput, AccountUncheckedCreateWithoutBillInput>
  }

  export type ClientCreateWithoutBillInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutBillInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutBillInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutBillInput, ClientUncheckedCreateWithoutBillInput>
  }

  export type AddressCreateWithoutBillInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    user?: UserCreateNestedOneWithoutAddressInput
    client?: ClientCreateNestedOneWithoutAddressInput
    distributor?: DistributorCreateNestedOneWithoutAddressInput
    company?: CompanyCreateNestedOneWithoutAddressInput
    account?: AccountCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutBillInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    clientId?: string | null
    distributorId?: string | null
    companyId?: string | null
    accountId?: string | null
  }

  export type AddressCreateOrConnectWithoutBillInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutBillInput, AddressUncheckedCreateWithoutBillInput>
  }

  export type EntryUpsertWithWhereUniqueWithoutBillInput = {
    where: EntryWhereUniqueInput
    update: XOR<EntryUpdateWithoutBillInput, EntryUncheckedUpdateWithoutBillInput>
    create: XOR<EntryCreateWithoutBillInput, EntryUncheckedCreateWithoutBillInput>
  }

  export type EntryUpdateWithWhereUniqueWithoutBillInput = {
    where: EntryWhereUniqueInput
    data: XOR<EntryUpdateWithoutBillInput, EntryUncheckedUpdateWithoutBillInput>
  }

  export type EntryUpdateManyWithWhereWithoutBillInput = {
    where: EntryScalarWhereInput
    data: XOR<EntryUpdateManyMutationInput, EntryUncheckedUpdateManyWithoutBillInput>
  }

  export type CompanyUpsertWithoutBillsInput = {
    update: XOR<CompanyUpdateWithoutBillsInput, CompanyUncheckedUpdateWithoutBillsInput>
    create: XOR<CompanyCreateWithoutBillsInput, CompanyUncheckedCreateWithoutBillsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBillsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBillsInput, CompanyUncheckedUpdateWithoutBillsInput>
  }

  export type CompanyUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithoutBillInput = {
    update: XOR<AccountUpdateWithoutBillInput, AccountUncheckedUpdateWithoutBillInput>
    create: XOR<AccountCreateWithoutBillInput, AccountUncheckedCreateWithoutBillInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBillInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBillInput, AccountUncheckedUpdateWithoutBillInput>
  }

  export type AccountUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutAccountNestedInput
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type ClientUpsertWithoutBillInput = {
    update: XOR<ClientUpdateWithoutBillInput, ClientUncheckedUpdateWithoutBillInput>
    create: XOR<ClientCreateWithoutBillInput, ClientUncheckedCreateWithoutBillInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutBillInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutBillInput, ClientUncheckedUpdateWithoutBillInput>
  }

  export type ClientUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AddressUpsertWithoutBillInput = {
    update: XOR<AddressUpdateWithoutBillInput, AddressUncheckedUpdateWithoutBillInput>
    create: XOR<AddressCreateWithoutBillInput, AddressUncheckedCreateWithoutBillInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutBillInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutBillInput, AddressUncheckedUpdateWithoutBillInput>
  }

  export type AddressUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAddressNestedInput
    client?: ClientUpdateOneWithoutAddressNestedInput
    distributor?: DistributorUpdateOneWithoutAddressNestedInput
    company?: CompanyUpdateOneWithoutAddressNestedInput
    account?: AccountUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateWithoutTokenbillsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTokenbillsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTokenbillsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTokenbillsInput, CompanyUncheckedCreateWithoutTokenbillsInput>
  }

  export type CompanyUpsertWithoutTokenbillsInput = {
    update: XOR<CompanyUpdateWithoutTokenbillsInput, CompanyUncheckedUpdateWithoutTokenbillsInput>
    create: XOR<CompanyCreateWithoutTokenbillsInput, CompanyUncheckedCreateWithoutTokenbillsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTokenbillsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTokenbillsInput, CompanyUncheckedUpdateWithoutTokenbillsInput>
  }

  export type CompanyUpdateWithoutTokenbillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTokenbillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VariantCreateWithoutEntriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    product: ProductCreateNestedOneWithoutVariantsInput
    items?: ItemCreateNestedManyWithoutVariantInput
    company: CompanyCreateNestedOneWithoutVariantsInput
    VariantSizeBarcode?: VariantSizeBarcodeCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutEntriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
    companyId: string
    items?: ItemUncheckedCreateNestedManyWithoutVariantInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutEntriesInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutEntriesInput, VariantUncheckedCreateWithoutEntriesInput>
  }

  export type CategoryCreateWithoutEntriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    company: CompanyCreateNestedOneWithoutCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutEntriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutEntriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutEntriesInput, CategoryUncheckedCreateWithoutEntriesInput>
  }

  export type BillCreateWithoutEntriesInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    company: CompanyCreateNestedOneWithoutBillsInput
    account?: AccountCreateNestedOneWithoutBillInput
    client?: ClientCreateNestedOneWithoutBillInput
    address?: AddressCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutEntriesInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    accountId?: string | null
    clientId?: string | null
    addressId?: string | null
  }

  export type BillCreateOrConnectWithoutEntriesInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutEntriesInput, BillUncheckedCreateWithoutEntriesInput>
  }

  export type ItemCreateWithoutEntryInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    size?: string | null
    variant: VariantCreateNestedOneWithoutItemsInput
    company: CompanyCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutEntryInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variantId: string
    status?: string
    size?: string | null
    companyId: string
  }

  export type ItemCreateOrConnectWithoutEntryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEntryInput, ItemUncheckedCreateWithoutEntryInput>
  }

  export type VariantUpsertWithoutEntriesInput = {
    update: XOR<VariantUpdateWithoutEntriesInput, VariantUncheckedUpdateWithoutEntriesInput>
    create: XOR<VariantCreateWithoutEntriesInput, VariantUncheckedCreateWithoutEntriesInput>
    where?: VariantWhereInput
  }

  export type VariantUpdateToOneWithWhereWithoutEntriesInput = {
    where?: VariantWhereInput
    data: XOR<VariantUpdateWithoutEntriesInput, VariantUncheckedUpdateWithoutEntriesInput>
  }

  export type VariantUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    items?: ItemUpdateManyWithoutVariantNestedInput
    company?: CompanyUpdateOneRequiredWithoutVariantsNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutVariantNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type CategoryUpsertWithoutEntriesInput = {
    update: XOR<CategoryUpdateWithoutEntriesInput, CategoryUncheckedUpdateWithoutEntriesInput>
    create: XOR<CategoryCreateWithoutEntriesInput, CategoryUncheckedCreateWithoutEntriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutEntriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutEntriesInput, CategoryUncheckedUpdateWithoutEntriesInput>
  }

  export type CategoryUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BillUpsertWithoutEntriesInput = {
    update: XOR<BillUpdateWithoutEntriesInput, BillUncheckedUpdateWithoutEntriesInput>
    create: XOR<BillCreateWithoutEntriesInput, BillUncheckedCreateWithoutEntriesInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutEntriesInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutEntriesInput, BillUncheckedUpdateWithoutEntriesInput>
  }

  export type BillUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutBillsNestedInput
    account?: AccountUpdateOneWithoutBillNestedInput
    client?: ClientUpdateOneWithoutBillNestedInput
    address?: AddressUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUpsertWithoutEntryInput = {
    update: XOR<ItemUpdateWithoutEntryInput, ItemUncheckedUpdateWithoutEntryInput>
    create: XOR<ItemCreateWithoutEntryInput, ItemUncheckedCreateWithoutEntryInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEntryInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEntryInput, ItemUncheckedUpdateWithoutEntryInput>
  }

  export type ItemUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: VariantUpdateOneRequiredWithoutItemsNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type BillCreateWithoutAccountInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    entries?: EntryCreateNestedManyWithoutBillInput
    company: CompanyCreateNestedOneWithoutBillsInput
    client?: ClientCreateNestedOneWithoutBillInput
    address?: AddressCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutAccountInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    clientId?: string | null
    addressId?: string | null
    entries?: EntryUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutAccountInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput>
  }

  export type BillCreateManyAccountInputEnvelope = {
    data: BillCreateManyAccountInput | BillCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    user?: UserCreateNestedOneWithoutAddressInput
    client?: ClientCreateNestedOneWithoutAddressInput
    distributor?: DistributorCreateNestedOneWithoutAddressInput
    company?: CompanyCreateNestedOneWithoutAddressInput
    bill?: BillCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    clientId?: string | null
    distributorId?: string | null
    companyId?: string | null
    bill?: BillUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutAccountInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutAccountInput, AddressUncheckedCreateWithoutAccountInput>
  }

  export type CompanyCreateWithoutAccountsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
  }

  export type BillUpsertWithWhereUniqueWithoutAccountInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutAccountInput, BillUncheckedUpdateWithoutAccountInput>
    create: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput>
  }

  export type BillUpdateWithWhereUniqueWithoutAccountInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutAccountInput, BillUncheckedUpdateWithoutAccountInput>
  }

  export type BillUpdateManyWithWhereWithoutAccountInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutAccountInput>
  }

  export type AddressUpsertWithoutAccountInput = {
    update: XOR<AddressUpdateWithoutAccountInput, AddressUncheckedUpdateWithoutAccountInput>
    create: XOR<AddressCreateWithoutAccountInput, AddressUncheckedCreateWithoutAccountInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutAccountInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutAccountInput, AddressUncheckedUpdateWithoutAccountInput>
  }

  export type AddressUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAddressNestedInput
    client?: ClientUpdateOneWithoutAddressNestedInput
    distributor?: DistributorUpdateOneWithoutAddressNestedInput
    company?: CompanyUpdateOneWithoutAddressNestedInput
    bill?: BillUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type CompanyUpsertWithoutAccountsInput = {
    update: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type CompanyUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ExpenseCreateWithoutExpensecategoryInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutExpensecategoryInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ExpenseCreateOrConnectWithoutExpensecategoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutExpensecategoryInput, ExpenseUncheckedCreateWithoutExpensecategoryInput>
  }

  export type ExpenseCreateManyExpensecategoryInputEnvelope = {
    data: ExpenseCreateManyExpensecategoryInput | ExpenseCreateManyExpensecategoryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutExpenseCategoriesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExpenseCategoriesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExpenseCategoriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutExpensecategoryInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutExpensecategoryInput, ExpenseUncheckedUpdateWithoutExpensecategoryInput>
    create: XOR<ExpenseCreateWithoutExpensecategoryInput, ExpenseUncheckedCreateWithoutExpensecategoryInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutExpensecategoryInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutExpensecategoryInput, ExpenseUncheckedUpdateWithoutExpensecategoryInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutExpensecategoryInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutExpensecategoryInput>
  }

  export type CompanyUpsertWithoutExpenseCategoriesInput = {
    update: XOR<CompanyUpdateWithoutExpenseCategoriesInput, CompanyUncheckedUpdateWithoutExpenseCategoriesInput>
    create: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExpenseCategoriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExpenseCategoriesInput, CompanyUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type CompanyUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ExpenseCategoryCreateWithoutExpensesInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExpenseCategoriesInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ExpenseCategoryCreateOrConnectWithoutExpensesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
  }

  export type CompanyCreateWithoutExpensesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExpensesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpsertWithoutExpensesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUpsertWithoutExpensesInput = {
    update: XOR<CompanyUpdateWithoutExpensesInput, CompanyUncheckedUpdateWithoutExpensesInput>
    create: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExpensesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExpensesInput, CompanyUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPaymentInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPaymentInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPaymentInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPaymentInput, CompanyUncheckedCreateWithoutPaymentInput>
  }

  export type CompanyUpsertWithoutPaymentInput = {
    update: XOR<CompanyUpdateWithoutPaymentInput, CompanyUncheckedUpdateWithoutPaymentInput>
    create: XOR<CompanyCreateWithoutPaymentInput, CompanyUncheckedCreateWithoutPaymentInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPaymentInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPaymentInput, CompanyUncheckedUpdateWithoutPaymentInput>
  }

  export type CompanyUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversations?: UserConversationCreateNestedManyWithoutUserInput
    clients?: UserClientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversations?: UserConversationUncheckedCreateNestedManyWithoutUserInput
    clients?: UserClientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type ClientCreateWithoutAddressInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAddressInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAddressInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput>
  }

  export type DistributorCreateWithoutAddressInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    companies?: DistributorCompanyCreateNestedManyWithoutDistributorInput
    purchaseorders?: PurchaseOrderCreateNestedManyWithoutDistributorInput
  }

  export type DistributorUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    companies?: DistributorCompanyUncheckedCreateNestedManyWithoutDistributorInput
    purchaseorders?: PurchaseOrderUncheckedCreateNestedManyWithoutDistributorInput
  }

  export type DistributorCreateOrConnectWithoutAddressInput = {
    where: DistributorWhereUniqueInput
    create: XOR<DistributorCreateWithoutAddressInput, DistributorUncheckedCreateWithoutAddressInput>
  }

  export type CompanyCreateWithoutAddressInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAddressInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput>
  }

  export type AccountCreateWithoutAddressInput = {
    id?: string
    name: string
    phone: string
    bill?: BillCreateNestedManyWithoutAccountInput
    company: CompanyCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    phone: string
    companyId: string
    bill?: BillUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAddressInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAddressInput, AccountUncheckedCreateWithoutAddressInput>
  }

  export type BillCreateWithoutAddressInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    entries?: EntryCreateNestedManyWithoutBillInput
    company: CompanyCreateNestedOneWithoutBillsInput
    account?: AccountCreateNestedOneWithoutBillInput
    client?: ClientCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutAddressInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    accountId?: string | null
    clientId?: string | null
    entries?: EntryUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutAddressInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutAddressInput, BillUncheckedCreateWithoutAddressInput>
  }

  export type BillCreateManyAddressInputEnvelope = {
    data: BillCreateManyAddressInput | BillCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUpdateManyWithoutUserNestedInput
    clients?: UserClientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUncheckedUpdateManyWithoutUserNestedInput
    clients?: UserClientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClientUpsertWithoutAddressInput = {
    update: XOR<ClientUpdateWithoutAddressInput, ClientUncheckedUpdateWithoutAddressInput>
    create: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAddressInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAddressInput, ClientUncheckedUpdateWithoutAddressInput>
  }

  export type ClientUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DistributorUpsertWithoutAddressInput = {
    update: XOR<DistributorUpdateWithoutAddressInput, DistributorUncheckedUpdateWithoutAddressInput>
    create: XOR<DistributorCreateWithoutAddressInput, DistributorUncheckedCreateWithoutAddressInput>
    where?: DistributorWhereInput
  }

  export type DistributorUpdateToOneWithWhereWithoutAddressInput = {
    where?: DistributorWhereInput
    data: XOR<DistributorUpdateWithoutAddressInput, DistributorUncheckedUpdateWithoutAddressInput>
  }

  export type DistributorUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: DistributorCompanyUpdateManyWithoutDistributorNestedInput
    purchaseorders?: PurchaseOrderUpdateManyWithoutDistributorNestedInput
  }

  export type DistributorUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: DistributorCompanyUncheckedUpdateManyWithoutDistributorNestedInput
    purchaseorders?: PurchaseOrderUncheckedUpdateManyWithoutDistributorNestedInput
  }

  export type CompanyUpsertWithoutAddressInput = {
    update: XOR<CompanyUpdateWithoutAddressInput, CompanyUncheckedUpdateWithoutAddressInput>
    create: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAddressInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAddressInput, CompanyUncheckedUpdateWithoutAddressInput>
  }

  export type CompanyUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithoutAddressInput = {
    update: XOR<AccountUpdateWithoutAddressInput, AccountUncheckedUpdateWithoutAddressInput>
    create: XOR<AccountCreateWithoutAddressInput, AccountUncheckedCreateWithoutAddressInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAddressInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAddressInput, AccountUncheckedUpdateWithoutAddressInput>
  }

  export type AccountUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bill?: BillUpdateManyWithoutAccountNestedInput
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    bill?: BillUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type BillUpsertWithWhereUniqueWithoutAddressInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutAddressInput, BillUncheckedUpdateWithoutAddressInput>
    create: XOR<BillCreateWithoutAddressInput, BillUncheckedCreateWithoutAddressInput>
  }

  export type BillUpdateWithWhereUniqueWithoutAddressInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutAddressInput, BillUncheckedUpdateWithoutAddressInput>
  }

  export type BillUpdateManyWithWhereWithoutAddressInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutAddressInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    text: string
    seen?: MessageCreateseenInput | string[]
    replyto?: string | null
    edited?: boolean
    deleted?: boolean
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    text: string
    seen?: MessageCreateseenInput | string[]
    replyto?: string | null
    edited?: boolean
    deleted?: boolean
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserConversationCreateWithoutConversationInput = {
    user: UserCreateNestedOneWithoutConversationsInput
  }

  export type UserConversationUncheckedCreateWithoutConversationInput = {
    userId: string
  }

  export type UserConversationCreateOrConnectWithoutConversationInput = {
    where: UserConversationWhereUniqueInput
    create: XOR<UserConversationCreateWithoutConversationInput, UserConversationUncheckedCreateWithoutConversationInput>
  }

  export type UserConversationCreateManyConversationInputEnvelope = {
    data: UserConversationCreateManyConversationInput | UserConversationCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ClientConversationCreateWithoutConversationInput = {
    client: ClientCreateNestedOneWithoutConversationsInput
  }

  export type ClientConversationUncheckedCreateWithoutConversationInput = {
    clientId: string
  }

  export type ClientConversationCreateOrConnectWithoutConversationInput = {
    where: ClientConversationWhereUniqueInput
    create: XOR<ClientConversationCreateWithoutConversationInput, ClientConversationUncheckedCreateWithoutConversationInput>
  }

  export type ClientConversationCreateManyConversationInputEnvelope = {
    data: ClientConversationCreateManyConversationInput | ClientConversationCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    text?: StringFilter<"Message"> | string
    seen?: StringNullableListFilter<"Message">
    replyto?: StringNullableFilter<"Message"> | string | null
    edited?: BoolFilter<"Message"> | boolean
    deleted?: BoolFilter<"Message"> | boolean
  }

  export type UserConversationUpsertWithWhereUniqueWithoutConversationInput = {
    where: UserConversationWhereUniqueInput
    update: XOR<UserConversationUpdateWithoutConversationInput, UserConversationUncheckedUpdateWithoutConversationInput>
    create: XOR<UserConversationCreateWithoutConversationInput, UserConversationUncheckedCreateWithoutConversationInput>
  }

  export type UserConversationUpdateWithWhereUniqueWithoutConversationInput = {
    where: UserConversationWhereUniqueInput
    data: XOR<UserConversationUpdateWithoutConversationInput, UserConversationUncheckedUpdateWithoutConversationInput>
  }

  export type UserConversationUpdateManyWithWhereWithoutConversationInput = {
    where: UserConversationScalarWhereInput
    data: XOR<UserConversationUpdateManyMutationInput, UserConversationUncheckedUpdateManyWithoutConversationInput>
  }

  export type ClientConversationUpsertWithWhereUniqueWithoutConversationInput = {
    where: ClientConversationWhereUniqueInput
    update: XOR<ClientConversationUpdateWithoutConversationInput, ClientConversationUncheckedUpdateWithoutConversationInput>
    create: XOR<ClientConversationCreateWithoutConversationInput, ClientConversationUncheckedCreateWithoutConversationInput>
  }

  export type ClientConversationUpdateWithWhereUniqueWithoutConversationInput = {
    where: ClientConversationWhereUniqueInput
    data: XOR<ClientConversationUpdateWithoutConversationInput, ClientConversationUncheckedUpdateWithoutConversationInput>
  }

  export type ClientConversationUpdateManyWithWhereWithoutConversationInput = {
    where: ClientConversationScalarWhereInput
    data: XOR<ClientConversationUpdateManyMutationInput, ClientConversationUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserConversationCreateNestedManyWithoutConversationInput
    clients?: ClientConversationCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserConversationUncheckedCreateNestedManyWithoutConversationInput
    clients?: ClientConversationUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserConversationUpdateManyWithoutConversationNestedInput
    clients?: ClientConversationUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserConversationUncheckedUpdateManyWithoutConversationNestedInput
    clients?: ClientConversationUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutCompaniesInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    address?: AddressCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversations?: UserConversationCreateNestedManyWithoutUserInput
    clients?: UserClientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversations?: UserConversationUncheckedCreateNestedManyWithoutUserInput
    clients?: UserClientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCompaniesInput = {
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUpdateManyWithoutUserNestedInput
    clients?: UserClientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUncheckedUpdateManyWithoutUserNestedInput
    clients?: UserClientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutClientsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutClientsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutClientsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
  }

  export type ClientCreateWithoutCompaniesInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCompaniesInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCompaniesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCompaniesInput, ClientUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutClientsInput = {
    update: XOR<CompanyUpdateWithoutClientsInput, CompanyUncheckedUpdateWithoutClientsInput>
    create: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutClientsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutClientsInput, CompanyUncheckedUpdateWithoutClientsInput>
  }

  export type CompanyUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientUpsertWithoutCompaniesInput = {
    update: XOR<ClientUpdateWithoutCompaniesInput, ClientUncheckedUpdateWithoutCompaniesInput>
    create: XOR<ClientCreateWithoutCompaniesInput, ClientUncheckedCreateWithoutCompaniesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutCompaniesInput, ClientUncheckedUpdateWithoutCompaniesInput>
  }

  export type ClientUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    clients?: UserClientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    clients?: UserClientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type ConversationCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    clients?: ClientConversationCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    clients?: ClientConversationUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUsersInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUsersInput, ConversationUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    clients?: UserClientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    clients?: UserClientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationUpsertWithoutUsersInput = {
    update: XOR<ConversationUpdateWithoutUsersInput, ConversationUncheckedUpdateWithoutUsersInput>
    create: XOR<ConversationCreateWithoutUsersInput, ConversationUncheckedCreateWithoutUsersInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutUsersInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutUsersInput, ConversationUncheckedUpdateWithoutUsersInput>
  }

  export type ConversationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    clients?: ClientConversationUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    clients?: ClientConversationUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ClientCreateWithoutConversationsInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutConversationsInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutConversationsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
  }

  export type ConversationCreateWithoutClientsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    users?: UserConversationCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutClientsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    users?: UserConversationUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutClientsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutClientsInput, ConversationUncheckedCreateWithoutClientsInput>
  }

  export type ClientUpsertWithoutConversationsInput = {
    update: XOR<ClientUpdateWithoutConversationsInput, ClientUncheckedUpdateWithoutConversationsInput>
    create: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutConversationsInput, ClientUncheckedUpdateWithoutConversationsInput>
  }

  export type ClientUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ConversationUpsertWithoutClientsInput = {
    update: XOR<ConversationUpdateWithoutClientsInput, ConversationUncheckedUpdateWithoutClientsInput>
    create: XOR<ConversationCreateWithoutClientsInput, ConversationUncheckedCreateWithoutClientsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutClientsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutClientsInput, ConversationUncheckedUpdateWithoutClientsInput>
  }

  export type ConversationUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    users?: UserConversationUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    users?: UserConversationUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ClientCreateWithoutUsersInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
    notifications?: NotificationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUsersInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUsersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutClientsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversations?: UserConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversations?: UserConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
  }

  export type ClientUpsertWithoutUsersInput = {
    update: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutClientsInput = {
    update: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: UserConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DistributorCreateWithoutCompaniesInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    purchaseorders?: PurchaseOrderCreateNestedManyWithoutDistributorInput
    address?: AddressCreateNestedOneWithoutDistributorInput
  }

  export type DistributorUncheckedCreateWithoutCompaniesInput = {
    id?: string
    name: string
    images?: string | null
    status?: boolean
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    purchaseorders?: PurchaseOrderUncheckedCreateNestedManyWithoutDistributorInput
    address?: AddressUncheckedCreateNestedOneWithoutDistributorInput
  }

  export type DistributorCreateOrConnectWithoutCompaniesInput = {
    where: DistributorWhereUniqueInput
    create: XOR<DistributorCreateWithoutCompaniesInput, DistributorUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyCreateWithoutDistributorInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    notifications?: NotificationCreateNestedManyWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDistributorInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDistributorInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDistributorInput, CompanyUncheckedCreateWithoutDistributorInput>
  }

  export type DistributorUpsertWithoutCompaniesInput = {
    update: XOR<DistributorUpdateWithoutCompaniesInput, DistributorUncheckedUpdateWithoutCompaniesInput>
    create: XOR<DistributorCreateWithoutCompaniesInput, DistributorUncheckedCreateWithoutCompaniesInput>
    where?: DistributorWhereInput
  }

  export type DistributorUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: DistributorWhereInput
    data: XOR<DistributorUpdateWithoutCompaniesInput, DistributorUncheckedUpdateWithoutCompaniesInput>
  }

  export type DistributorUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorders?: PurchaseOrderUpdateManyWithoutDistributorNestedInput
    address?: AddressUpdateOneWithoutDistributorNestedInput
  }

  export type DistributorUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorders?: PurchaseOrderUncheckedUpdateManyWithoutDistributorNestedInput
    address?: AddressUncheckedUpdateOneWithoutDistributorNestedInput
  }

  export type CompanyUpsertWithoutDistributorInput = {
    update: XOR<CompanyUpdateWithoutDistributorInput, CompanyUncheckedUpdateWithoutDistributorInput>
    create: XOR<CompanyCreateWithoutDistributorInput, CompanyUncheckedCreateWithoutDistributorInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDistributorInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDistributorInput, CompanyUncheckedUpdateWithoutDistributorInput>
  }

  export type CompanyUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUpdateManyWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
  }

  export type VariantCreateWithoutVariantSizeBarcodeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    product: ProductCreateNestedOneWithoutVariantsInput
    items?: ItemCreateNestedManyWithoutVariantInput
    entries?: EntryCreateNestedManyWithoutVariantInput
    company: CompanyCreateNestedOneWithoutVariantsInput
  }

  export type VariantUncheckedCreateWithoutVariantSizeBarcodeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
    companyId: string
    items?: ItemUncheckedCreateNestedManyWithoutVariantInput
    entries?: EntryUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutVariantSizeBarcodeInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutVariantSizeBarcodeInput, VariantUncheckedCreateWithoutVariantSizeBarcodeInput>
  }

  export type VariantUpsertWithoutVariantSizeBarcodeInput = {
    update: XOR<VariantUpdateWithoutVariantSizeBarcodeInput, VariantUncheckedUpdateWithoutVariantSizeBarcodeInput>
    create: XOR<VariantCreateWithoutVariantSizeBarcodeInput, VariantUncheckedCreateWithoutVariantSizeBarcodeInput>
    where?: VariantWhereInput
  }

  export type VariantUpdateToOneWithWhereWithoutVariantSizeBarcodeInput = {
    where?: VariantWhereInput
    data: XOR<VariantUpdateWithoutVariantSizeBarcodeInput, VariantUncheckedUpdateWithoutVariantSizeBarcodeInput>
  }

  export type VariantUpdateWithoutVariantSizeBarcodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    items?: ItemUpdateManyWithoutVariantNestedInput
    entries?: EntryUpdateManyWithoutVariantNestedInput
    company?: CompanyUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type VariantUncheckedUpdateWithoutVariantSizeBarcodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutVariantNestedInput
    entries?: EntryUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type CompanyCreateWithoutNotificationsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    categories?: CategoryCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryCreateNestedManyWithoutCompanyInput
    bills?: BillCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    payment?: PaymentCreateNestedManyWithoutCompanyInput
    variants?: VariantCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    items?: ItemCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineCreateNestedOneWithoutCompanyInput
    address?: AddressCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    storecode?: number
    storeUniqueName?: string | null
    logo?: string | null
    description?: string | null
    shopifyStoreName?: string | null
    shopifyAccessToken?: string | null
    tiktokCipher?: string | null
    tiktokStoreName?: string | null
    tiktokAccessToken?: string | null
    tiktokAccessTokenExpireIn?: number | null
    tiktokRefreshToken?: string | null
    tiktokRefreshTokenExpireIn?: number | null
    images?: string | null
    isTaxIncluded?: boolean
    status?: boolean
    type: $Enums.CompanyType
    accHolderName?: string | null
    ifsc?: string | null
    accountNo?: string | null
    bankName?: string | null
    gstin?: string | null
    upiId?: string | null
    billCounter?: number
    barcodeCounter?: number
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: CompanyClientUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    categories?: CategoryUncheckedCreateNestedManyWithoutCompanyInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCompanyInput
    bills?: BillUncheckedCreateNestedManyWithoutCompanyInput
    tokenbills?: TokenEntryUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    payment?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    variants?: VariantUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    items?: ItemUncheckedCreateNestedManyWithoutCompanyInput
    pipeline?: PipelineUncheckedCreateNestedOneWithoutCompanyInput
    address?: AddressUncheckedCreateNestedOneWithoutCompanyInput
    distributor?: DistributorCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutNotificationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutNotificationsInput, CompanyUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    conversations?: UserConversationCreateNestedManyWithoutUserInput
    clients?: UserClientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    status?: boolean
    role?: $Enums.UserRole
    image?: string | null
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    conversations?: UserConversationUncheckedCreateNestedManyWithoutUserInput
    clients?: UserClientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type ClientCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    companies?: CompanyClientCreateNestedManyWithoutClientInput
    address?: AddressCreateNestedManyWithoutClientInput
    bill?: BillCreateNestedOneWithoutClientInput
    conversations?: ClientConversationCreateNestedManyWithoutClientInput
    users?: UserClientCreateNestedManyWithoutClientInput
    newPipeline?: PipelineCreateNestedOneWithoutNewClientsInput
    prospectPipeline?: PipelineCreateNestedOneWithoutProspectClientsInput
    viewingPipeline?: PipelineCreateNestedOneWithoutViewingClientsInput
    rejectPipeline?: PipelineCreateNestedOneWithoutRejectClientsInput
    closePipeline?: PipelineCreateNestedOneWithoutCloseClientsInput
  }

  export type ClientUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
    companies?: CompanyClientUncheckedCreateNestedManyWithoutClientInput
    address?: AddressUncheckedCreateNestedManyWithoutClientInput
    bill?: BillUncheckedCreateNestedOneWithoutClientInput
    conversations?: ClientConversationUncheckedCreateNestedManyWithoutClientInput
    users?: UserClientUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutNotificationsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutNotificationsInput, ClientUncheckedCreateWithoutNotificationsInput>
  }

  export type CompanyUpsertWithoutNotificationsInput = {
    update: XOR<CompanyUpdateWithoutNotificationsInput, CompanyUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CompanyCreateWithoutNotificationsInput, CompanyUncheckedCreateWithoutNotificationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutNotificationsInput, CompanyUncheckedUpdateWithoutNotificationsInput>
  }

  export type CompanyUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCompanyNestedInput
    bills?: BillUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUpdateManyWithoutCompanyNestedInput
    variants?: VariantUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    items?: ItemUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUpdateOneWithoutCompanyNestedInput
    address?: AddressUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storecode?: IntFieldUpdateOperationsInput | number
    storeUniqueName?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokCipher?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokStoreName?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokAccessTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    tiktokRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokRefreshTokenExpireIn?: NullableIntFieldUpdateOperationsInput | number | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxIncluded?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    accHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    accountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    billCounter?: IntFieldUpdateOperationsInput | number
    barcodeCounter?: IntFieldUpdateOperationsInput | number
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: CompanyClientUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutCompanyNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCompanyNestedInput
    bills?: BillUncheckedUpdateManyWithoutCompanyNestedInput
    tokenbills?: TokenEntryUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    variants?: VariantUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    items?: ItemUncheckedUpdateManyWithoutCompanyNestedInput
    pipeline?: PipelineUncheckedUpdateOneWithoutCompanyNestedInput
    address?: AddressUncheckedUpdateOneWithoutCompanyNestedInput
    distributor?: DistributorCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    conversations?: UserConversationUpdateManyWithoutUserNestedInput
    clients?: UserClientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    conversations?: UserConversationUncheckedUpdateManyWithoutUserNestedInput
    clients?: UserClientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClientUpsertWithoutNotificationsInput = {
    update: XOR<ClientUpdateWithoutNotificationsInput, ClientUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ClientCreateWithoutNotificationsInput, ClientUncheckedCreateWithoutNotificationsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutNotificationsInput, ClientUncheckedUpdateWithoutNotificationsInput>
  }

  export type ClientUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CompanyUserCreateManyCompanyInput = {
    userId: string
  }

  export type CompanyClientCreateManyCompanyInput = {
    clientId: string
  }

  export type ProductCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    categoryId?: string | null
    subcategoryId?: string | null
    purchaseorderId: string
  }

  export type CategoryCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    hsn?: string | null
    taxType?: $Enums.TaxType
    fixedTax?: number | null
    thresholdAmount?: number | null
    taxBelowThreshold?: number | null
    taxAboveThreshold?: number | null
  }

  export type SubcategoryCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    categoryId?: string | null
  }

  export type BillCreateManyCompanyInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    accountId?: string | null
    clientId?: string | null
    addressId?: string | null
  }

  export type TokenEntryCreateManyCompanyInput = {
    id?: string
    createdAt: Date | string
    tokenNo: string
    itemId: string
    variantId: string
    barcode: string
    categoryId: string
    size: string
    name: string
    qty: number
    rate: number
    discount: number
    tax: number
    value: number
    sizes: JsonNullValueInput | InputJsonValue
    totalQty: number
  }

  export type AccountCreateManyCompanyInput = {
    id?: string
    name: string
    phone: string
  }

  export type ExpenseCategoryCreateManyCompanyInput = {
    id?: string
    name: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyCompanyInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expensecategoryId: string
  }

  export type PaymentCreateManyCompanyInput = {
    id?: string
    paymentDate?: Date | string
    paymentMode: string
    paymentReference?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    productId: string
  }

  export type PurchaseOrderCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    distributorId?: string | null
    paymentType?: $Enums.paymentType | null
  }

  export type ItemCreateManyCompanyInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variantId: string
    status?: string
    size?: string | null
  }

  export type NotificationCreateManyCompanyInput = {
    id?: string
    userId?: string | null
    clientId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistributorCompanyCreateManyCompanyInput = {
    distributorId: string
  }

  export type CompanyUserUpdateWithoutCompanyInput = {
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyClientUpdateWithoutCompanyInput = {
    client?: ClientUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyClientUncheckedUpdateWithoutCompanyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyClientUncheckedUpdateManyWithoutCompanyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneWithoutProductsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    purchaseorder?: PurchaseOrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    products?: ProductUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    entries?: EntryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: EntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    fixedTax?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxBelowThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAboveThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SubcategoryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutSubcategoryNestedInput
    category?: CategoryUpdateOneWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUpdateManyWithoutBillNestedInput
    account?: AccountUpdateOneWithoutBillNestedInput
    client?: ClientUpdateOneWithoutBillNestedInput
    address?: AddressUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenEntryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
  }

  export type TokenEntryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
  }

  export type TokenEntryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    sizes?: JsonNullValueInput | InputJsonValue
    totalQty?: IntFieldUpdateOperationsInput | number
  }

  export type AccountUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bill?: BillUpdateManyWithoutAccountNestedInput
    address?: AddressUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bill?: BillUncheckedUpdateManyWithoutAccountNestedInput
    address?: AddressUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCategoryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutExpensecategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutExpensecategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expensecategory?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expensecategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expensecategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: StringFieldUpdateOperationsInput | string
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    items?: ItemUpdateManyWithoutVariantNestedInput
    entries?: EntryUpdateManyWithoutVariantNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutVariantNestedInput
    entries?: EntryUncheckedUpdateManyWithoutVariantNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    products?: ProductUpdateManyWithoutPurchaseorderNestedInput
    distributor?: DistributorUpdateOneWithoutPurchaseordersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    products?: ProductUncheckedUpdateManyWithoutPurchaseorderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
  }

  export type ItemUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: VariantUpdateOneRequiredWithoutItemsNestedInput
    entry?: EntryUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: EntryUncheckedUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
    client?: ClientUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributorCompanyUpdateWithoutCompanyInput = {
    distributor?: DistributorUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type DistributorCompanyUncheckedUpdateWithoutCompanyInput = {
    distributorId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCompanyUncheckedUpdateManyWithoutCompanyInput = {
    distributorId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCompanyCreateManyDistributorInput = {
    companyId: string
  }

  export type PurchaseOrderCreateManyDistributorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentType?: $Enums.paymentType | null
    companyId: string
  }

  export type DistributorCompanyUpdateWithoutDistributorInput = {
    company?: CompanyUpdateOneRequiredWithoutDistributorNestedInput
  }

  export type DistributorCompanyUncheckedUpdateWithoutDistributorInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCompanyUncheckedUpdateManyWithoutDistributorInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    products?: ProductUpdateManyWithoutPurchaseorderNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    companyId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutPurchaseorderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableEnumpaymentTypeFieldUpdateOperationsInput | $Enums.paymentType | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUserCreateManyUserInput = {
    companyId: string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    companyId: string
    clientId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConversationCreateManyUserInput = {
    conversationId: string
  }

  export type UserClientCreateManyUserInput = {
    clientId: string
  }

  export type CompanyUserUpdateWithoutUserInput = {
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutNotificationsNestedInput
    client?: ClientUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConversationUpdateWithoutUserInput = {
    conversation?: ConversationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserConversationUncheckedUpdateWithoutUserInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type UserConversationUncheckedUpdateManyWithoutUserInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientUpdateWithoutUserInput = {
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserClientUncheckedUpdateWithoutUserInput = {
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientUncheckedUpdateManyWithoutUserInput = {
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyClientCreateManyClientInput = {
    companyId: string
  }

  export type AddressCreateManyClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    street: string
    locality: string
    city: string
    state: string
    pincode: string
    active?: boolean
    userId?: string | null
    distributorId?: string | null
    companyId?: string | null
    accountId?: string | null
  }

  export type ClientConversationCreateManyClientInput = {
    conversationId: string
  }

  export type UserClientCreateManyClientInput = {
    userId: string
  }

  export type NotificationCreateManyClientInput = {
    id?: string
    companyId: string
    userId?: string | null
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyClientUpdateWithoutClientInput = {
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type CompanyClientUncheckedUpdateWithoutClientInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyClientUncheckedUpdateManyWithoutClientInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAddressNestedInput
    distributor?: DistributorUpdateOneWithoutAddressNestedInput
    company?: CompanyUpdateOneWithoutAddressNestedInput
    account?: AccountUpdateOneWithoutAddressNestedInput
    bill?: BillUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    distributorId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientConversationUpdateWithoutClientInput = {
    conversation?: ConversationUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientConversationUncheckedUpdateWithoutClientInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientConversationUncheckedUpdateManyWithoutClientInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientUpdateWithoutClientInput = {
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
  }

  export type UserClientUncheckedUpdateWithoutClientInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientUncheckedUpdateManyWithoutClientInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyNewPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
  }

  export type ClientCreateManyProspectPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
  }

  export type ClientCreateManyViewingPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    rejectPipelineId?: string | null
    closePipelineId?: string | null
  }

  export type ClientCreateManyRejectPipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    closePipelineId?: string | null
  }

  export type ClientCreateManyClosePipelineInput = {
    id?: string
    email?: string | null
    name: string
    password?: string | null
    phone: string
    status?: boolean
    pipelineStatus?: string
    newPipelineId?: string | null
    prospectPipelineId?: string | null
    viewingPipelineId?: string | null
    rejectPipelineId?: string | null
  }

  export type ClientUpdateWithoutNewPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutNewPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutNewPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpdateWithoutProspectPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProspectPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutProspectPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpdateWithoutViewingPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutViewingPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutViewingPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpdateWithoutRejectPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    closePipeline?: PipelineUpdateOneWithoutCloseClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutRejectPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutRejectPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    closePipelineId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpdateWithoutClosePipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    companies?: CompanyClientUpdateManyWithoutClientNestedInput
    address?: AddressUpdateManyWithoutClientNestedInput
    bill?: BillUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUpdateManyWithoutClientNestedInput
    users?: UserClientUpdateManyWithoutClientNestedInput
    newPipeline?: PipelineUpdateOneWithoutNewClientsNestedInput
    prospectPipeline?: PipelineUpdateOneWithoutProspectClientsNestedInput
    viewingPipeline?: PipelineUpdateOneWithoutViewingClientsNestedInput
    rejectPipeline?: PipelineUpdateOneWithoutRejectClientsNestedInput
    notifications?: NotificationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClosePipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: CompanyClientUncheckedUpdateManyWithoutClientNestedInput
    address?: AddressUncheckedUpdateManyWithoutClientNestedInput
    bill?: BillUncheckedUpdateOneWithoutClientNestedInput
    conversations?: ClientConversationUncheckedUpdateManyWithoutClientNestedInput
    users?: UserClientUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutClosePipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    pipelineStatus?: StringFieldUpdateOperationsInput | string
    newPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    viewingPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectPipelineId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    subcategoryId?: string | null
    purchaseorderId: string
  }

  export type SubcategoryCreateManyCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    status?: boolean
    image?: string | null
    companyId: string
  }

  export type EntryCreateManyCategoryInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    billId?: string | null
    itemId?: string | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    purchaseorder?: PurchaseOrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutSubcategoriesNestedInput
    products?: ProductUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type EntryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    variant?: VariantUpdateOneWithoutEntriesNestedInput
    bill?: BillUpdateOneWithoutEntriesNestedInput
    item?: ItemUpdateOneWithoutEntryNestedInput
  }

  export type EntryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManySubcategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    purchaseorderId: string
  }

  export type ProductUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    purchaseorder?: PurchaseOrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseorderId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code?: string | null
    status?: boolean
    sprice: number
    pprice?: number | null
    qty?: number | null
    discount?: number | null
    dprice?: number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantCreateimagesInput | string[]
    tax?: number
    companyId: string
  }

  export type VariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    items?: ItemUpdateManyWithoutVariantNestedInput
    entries?: EntryUpdateManyWithoutVariantNestedInput
    company?: CompanyUpdateOneRequiredWithoutVariantsNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutVariantNestedInput
    entries?: EntryUncheckedUpdateManyWithoutVariantNestedInput
    VariantSizeBarcode?: VariantSizeBarcodeUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    sprice?: FloatFieldUpdateOperationsInput | number
    pprice?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    dprice?: NullableFloatFieldUpdateOperationsInput | number | null
    sizes?: NullableJsonNullValueInput | InputJsonValue
    images?: VariantUpdateimagesInput | string[]
    tax?: FloatFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateManyVariantInput = {
    id?: string
    barcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    size?: string | null
    companyId: string
  }

  export type EntryCreateManyVariantInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    billId?: string | null
    itemId?: string | null
  }

  export type VariantSizeBarcodeCreateManyVariantInput = {
    id?: number
    size?: string | null
    barcode: string
  }

  export type ItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: EntryUpdateOneWithoutItemNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    entry?: EntryUncheckedUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type EntryUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: CategoryUpdateOneWithoutEntriesNestedInput
    bill?: BillUpdateOneWithoutEntriesNestedInput
    item?: ItemUpdateOneWithoutEntryNestedInput
  }

  export type EntryUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntryUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VariantSizeBarcodeUpdateWithoutVariantInput = {
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
  }

  export type VariantSizeBarcodeUncheckedUpdateWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
  }

  export type VariantSizeBarcodeUncheckedUpdateManyWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyPurchaseorderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    brand?: string | null
    status?: boolean
    rating?: number | null
    description?: string | null
    companyId: string
    categoryId?: string | null
    subcategoryId?: string | null
  }

  export type ProductUpdateWithoutPurchaseorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutPurchaseorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntryCreateManyBillInput = {
    id?: string
    name?: string | null
    barcode?: string | null
    qty?: number | null
    rate?: number | null
    discount?: number | null
    tax?: number | null
    value?: number | null
    size?: string | null
    variantId?: string | null
    outOfStock?: boolean | null
    categoryId?: string | null
    itemId?: string | null
  }

  export type EntryUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    variant?: VariantUpdateOneWithoutEntriesNestedInput
    category?: CategoryUpdateOneWithoutEntriesNestedInput
    item?: ItemUpdateOneWithoutEntryNestedInput
  }

  export type EntryUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntryUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    outOfStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillCreateManyAccountInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    clientId?: string | null
    addressId?: string | null
  }

  export type BillUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUpdateManyWithoutBillNestedInput
    company?: CompanyUpdateOneRequiredWithoutBillsNestedInput
    client?: ClientUpdateOneWithoutBillNestedInput
    address?: AddressUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateManyExpensecategoryInput = {
    id?: string
    expenseDate?: Date | string
    note?: string | null
    currency?: string
    paymentMode: $Enums.PaymentMode
    status?: string
    receipt?: string | null
    receiptName?: string | null
    taxAmount?: number | null
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ExpenseUpdateWithoutExpensecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutExpensecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUncheckedUpdateManyWithoutExpensecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    status?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    receiptName?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type BillCreateManyAddressInput = {
    id?: string
    createdAt: Date | string
    invoiceNumber?: number | null
    subtotal?: number | null
    discount?: number | null
    tax?: number | null
    grandTotal?: number | null
    deliveryFees?: number | null
    paymentMethod?: string | null
    paymentStatus?: $Enums.PaymentStatus
    transactionId?: string | null
    notes?: string | null
    type?: $Enums.OrderType | null
    status?: $Enums.OrderStatus | null
    deleted?: boolean | null
    bookingDate?: Date | string | null
    returnDeadline?: string | null
    companyId: string
    accountId?: string | null
    clientId?: string | null
  }

  export type BillUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUpdateManyWithoutBillNestedInput
    company?: CompanyUpdateOneRequiredWithoutBillsNestedInput
    account?: AccountUpdateOneWithoutBillNestedInput
    client?: ClientUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: EntryUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFees?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType | null
    status?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDeadline?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    text: string
    seen?: MessageCreateseenInput | string[]
    replyto?: string | null
    edited?: boolean
    deleted?: boolean
  }

  export type UserConversationCreateManyConversationInput = {
    userId: string
  }

  export type ClientConversationCreateManyConversationInput = {
    clientId: string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    seen?: MessageUpdateseenInput | string[]
    replyto?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationUpdateWithoutConversationInput = {
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type UserConversationUncheckedUpdateWithoutConversationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserConversationUncheckedUpdateManyWithoutConversationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientConversationUpdateWithoutConversationInput = {
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ClientConversationUncheckedUpdateWithoutConversationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientConversationUncheckedUpdateManyWithoutConversationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributorCountOutputTypeDefaultArgs instead
     */
    export type DistributorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PipelineCountOutputTypeDefaultArgs instead
     */
    export type PipelineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PipelineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubcategoryCountOutputTypeDefaultArgs instead
     */
    export type SubcategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VariantCountOutputTypeDefaultArgs instead
     */
    export type VariantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VariantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderCountOutputTypeDefaultArgs instead
     */
    export type PurchaseOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillCountOutputTypeDefaultArgs instead
     */
    export type BillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseCategoryCountOutputTypeDefaultArgs instead
     */
    export type ExpenseCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressCountOutputTypeDefaultArgs instead
     */
    export type AddressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributorDefaultArgs instead
     */
    export type DistributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PipelineDefaultArgs instead
     */
    export type PipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PipelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubcategoryDefaultArgs instead
     */
    export type SubcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubcategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VariantDefaultArgs instead
     */
    export type VariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VariantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderDefaultArgs instead
     */
    export type PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillDefaultArgs instead
     */
    export type BillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenEntryDefaultArgs instead
     */
    export type TokenEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntryDefaultArgs instead
     */
    export type EntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseCategoryDefaultArgs instead
     */
    export type ExpenseCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressDefaultArgs instead
     */
    export type AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyUserDefaultArgs instead
     */
    export type CompanyUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyClientDefaultArgs instead
     */
    export type CompanyClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserConversationDefaultArgs instead
     */
    export type UserConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientConversationDefaultArgs instead
     */
    export type ClientConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserClientDefaultArgs instead
     */
    export type UserClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributorCompanyDefaultArgs instead
     */
    export type DistributorCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributorCompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VariantSizeBarcodeDefaultArgs instead
     */
    export type VariantSizeBarcodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VariantSizeBarcodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailOtpDefaultArgs instead
     */
    export type EmailOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailOtpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}