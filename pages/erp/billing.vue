
<script setup>
import { BillingAddClient } from '#components';
import { useCreateBill,useFindUniqueClient,useCreateTokenEntry,useFindFirstItem,useFindManyTokenEntry, useFindManyCategory, useUpdateVariant,useUpdateItem, useCreateAccount,useFindManyAccount, useDeleteTokenEntry, useUpdateCompanyClient } from '~/lib/hooks';
import { v4 as uuidv4 } from 'uuid';
import { useQueryClient } from '@tanstack/vue-query';
import Quagga from '@ericblade/quagga2'
const queryClient = useQueryClient();

const currentRequestIds = ref({});
const lastResponse  = ref({});
const { printBill } = usePrint();
const CreateBill = useCreateBill({ optimisticUpdate: true });
const CreateTokenEntry = useCreateTokenEntry({ optimisticUpdate: true });
const CreateAccount = useCreateAccount({ optimisticUpdate: true });
const UpdateVariant = useUpdateVariant({ optimisticUpdate: true });
const UpdateItem = useUpdateItem({ optimisticUpdate: true });
const DeleteTokenEntry = useDeleteTokenEntry({ optimisticUpdate: true });
const UpdateCompanyClient = useUpdateCompanyClient({ optimisticUpdate: true });
const UpdateCompanyClientForRedeem = useUpdateCompanyClient();
const redeeming = ref(false);
const useAuth = () => useNuxtApp().$auth;
const toast = useToast();
const router = useRouter();
const isTaxIncluded = ref(useAuth().session.value?.isTaxIncluded);
const isBarcodeIncluded = ref(useAuth().session.value?.isBarcodeIncluded);
const isUserTrackIncluded = ref(useAuth().session.value?.isUserTrackIncluded);
const billNo = ref('1');
const loadingStates = ref([]);
const paymentOptionsInsplit = ['Cash', 'UPI', 'Card','Credit']
const paymentOptions = ref(['Cash', 'UPI', 'Card','Credit'])
const tempSplits = ref(
  Object.fromEntries(paymentOptionsInsplit.map(method => [method, { method, amount: null }]))
)

const date = ref(new Date().toISOString());
const discount = ref(0);
const redeemedAmt = ref(0);
const redeemedPoints = ref(0);
const paymentMethod = ref('Cash');
const phoneNo = ref('');
const points = ref(0);
const clientName = ref('');
const clientId = ref('');
const voucherNo = ref('');
const token = ref("")
const tokenEntries = ref([])
const splitPayments = ref([])
const isRedeemPoint = ref(false);
const selected = ref(null);
const isDeleteModalOpen = ref(false)
const deletingRowIdentity = ref({})

const account = ref({
    name: '',
    phone:'',
    street: '',
    locality: '',
    city: '',
    state: '',
    pincode: '',
});
const scannedBarcode = ref("");
const barcodeInputs = ref([]);
const categoryInputs = ref([]);
const nameInputs = ref([]);
const qtyInputs = ref([]);
const rateInputs = ref([]);
const discountInputs = ref([]);
const userInputs = ref([]);
const taxInputs = ref([]);
const discountref = ref();
const paymentref = ref();
const saveref = ref();
const savetokenref = ref();
const addTokenRef = ref();
const tokenInputs = ref(['']);
const categoryStore = useCategoryStore()
const userStore = useUserStore()

const isPrint = ref(false);
const isSaving = ref(false);
let printData = {}
const isMobile = ref(false);


const showSplitModal = ref(false)
const isOpen = ref(false);
const isSavingAcc = ref(false)
const isTokenOpen = ref(false);
const issalesReturnModelOpen = ref(false);
const isClientAddModelOpen = ref(false);

const returnAmt = computed(() => {
  return items.value.reduce((sum, item) => {
    if (item.return) {
      const itemTotal = (item.qty || 1) * (item.rate || 0);
      return sum + itemTotal;
    }
    return sum;
  }, 0);
});


const subtotal = computed(() => {
  return items.value.reduce((sum, item) => {
    const itemTotal = (item.qty || 1) * (item.rate || 0);
    return item.return ? sum - itemTotal : sum + itemTotal;
  }, 0);
});

const grandTotal = computed(() => {
  const baseTotal = items.value.reduce((sum, item) => {
    const itemValue = item.value || 0;
    return item.return ? sum - itemValue : sum + itemValue;
  }, 0);

  let afterDiscount = 0;

  if (discount.value < 0) {
    afterDiscount = parseFloat((baseTotal - Math.abs(discount.value)).toFixed(2));
  } else {
    afterDiscount = parseFloat((baseTotal - (baseTotal * discount.value) / 100).toFixed(2));
  }

  return afterDiscount - redeemedAmt.value;
});






const dateOnly = computed({
  get: () => date.value.split('T')[0],
  set: val => {
    // Preserve original time, but update the date
    const original = new Date(date.value)
    const updated = new Date(val + 'T' + original.toISOString().split('T')[1])
    date.value = updated.toISOString()
  }
})

watch(date, (newDate) => {
  console.log('Date changed:', newDate);
});


const items = ref([
  { id:'', variantId:'',name:'',sn: 1, barcode: '',category:[], size:'',item: '', qty: 1,rate: null, discount: null, tax: null, value: 0,sizes:{}, totalQty:0 ,return:false, userCode:null, userId:null, user:null},
]);

const selectedDraft = ref(null);
const draftBills = ref([]);
const LOCAL_BILLS_KEY = 'bills';


const result = ref('')
const showCamera = ref(false)
const videoRef = ref(null)

const requestCameraAccess = async () => {
  try {
    await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { exact: 'environment' },
      },
    })
    console.log('✅ Camera permission granted')
  } catch (err) {
    console.error('🚫 Error accessing camera:', err)
    toast.add({
      title: 'Camera Access Blocked',
      description:
        'Unable to access camera. Please allow permission from your browser settings.',
      color: 'red',
    })
  }
}

const askCameraPermission = async () => {
  if (!('permissions' in navigator)) return requestCameraAccess()

  try {
    const res = await navigator.permissions.query({ name: 'camera' })
    if (res.state === 'granted') {
      console.log('✅ Camera already granted')
    } else {
      requestCameraAccess()
    }
  } catch (e) {
    console.warn('❗Permissions API error:', e)
    requestCameraAccess()
  }
}

const startCamera = async () => {
  await askCameraPermission()

  result.value = ''
  showCamera.value = true

  try {
    await nextTick()

    Quagga.init(
      {
        inputStream: {
          type: 'LiveStream',
          target: videoRef.value,
          constraints: {
            facingMode: 'environment',
          },
        },
        locator: {
          patchSize: 'medium',
          halfSample: true,
        },
        decoder: {
          readers: ['code_128_reader', 'ean_reader', 'ean_8_reader'],
        },
        locate: true,
      },
      (err) => {
        if (err) {
          console.error('Quagga init error:', err)
          toast.add({
            title: 'Camera Error',
            description: err.message,
            color: 'red',
          })
          return
        }
        Quagga.start()
        console.log('📷 Quagga started')
      }
    )

    Quagga.onDetected((data) => {
      const scanned = data?.codeResult?.code
      if (!scanned) return

      result.value = scanned
      console.log('📦 Scanned:', result.value)

      const lastIndex = items.value.length - 1
      if (lastIndex >= 0) {
        items.value[lastIndex].barcode = result.value
        fetchItemData(result.value, lastIndex)
         addNewRow(lastIndex,true)  
      }

      stopCamera()
    })
  } catch (err) {
    console.error('Camera access error:', err)

    if (err.name === 'NotAllowedError') {
      toast.add({
        title: 'Camera Permission Denied',
        description: 'Please allow camera access in your browser settings.',
        color: 'red',
        icon: 'i-heroicons-exclamation-triangle',
      })
    } else if (err.name === 'NotFoundError') {
      toast.add({
        title: 'No Camera Found',
        description: 'We could not detect a camera on this device.',
        color: 'orange',
        icon: 'i-heroicons-video-camera-slash',
      })
    } else {
      toast.add({
        title: 'Unexpected Error',
        description:
          err.message || 'Something went wrong while accessing the camera.',
        color: 'gray',
        icon: 'i-heroicons-bug-ant',
      })
    }

    stopCamera()
  }
}

const stopCamera = () => {
  try {
    Quagga.stop()
    Quagga.offDetected()
    result.value = ''
  } catch (e) {
    console.warn('⚠️ Error while stopping Quagga:', e)
  }
  showCamera.value = false
}

onUnmounted(() => {
  stopCamera()
})

onMounted(() => {
  const bills = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY) || '[]');

  if (bills.length === 0) {
    const defaultBill = {
      billNo: '1',
      date: new Date().toISOString(),
      discount: 0,
      returnAmt: 0,
      redeemedAmt: 0,
      paymentMethod: 'Cash',
      phoneNo: '',
      points: 0,
      clientName: '',
      clientId: '',
      voucherNo: '',
      token: '',
      tokenEntries: [],
      splitPayments: [],
      isRedeemPoint: false,
      redeemedPoints: 0,
      selected: null,
      tempSplits: Object.fromEntries(paymentOptionsInsplit.map(method => [method, { method, amount: null }])),
      items: [{
        id: '', variantId: '', name: '', sn: 1, barcode: '', category: [], size: '',
        item: '', qty: 1, rate: null, discount: null, tax: null, value: 0,
        sizes: {}, totalQty: 0, return: false, userCode: null, userId: null, user: null
      }]
    };
    localStorage.setItem(LOCAL_BILLS_KEY, JSON.stringify([defaultBill]));
  }

  const updated = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY));
  if (updated.length > 0) {
    loadDraftBills();
    selectedDraft.value = updated[0];
    loadBill(updated[0].billNo);
  }
});

// ✅ Single computed object to track all changes
const currentBill = computed(() => ({
  billNo: billNo.value,
  date: date.value,
  discount: discount.value,
  returnAmt: returnAmt.value,
  redeemedAmt: redeemedAmt.value,
  paymentMethod: paymentMethod.value,
  phoneNo: phoneNo.value,
  points: points.value,
  clientName: clientName.value,
  clientId: clientId.value,
  voucherNo: voucherNo.value,
  token: token.value,
  tokenEntries: tokenEntries.value,
  splitPayments: splitPayments.value,
  isRedeemPoint: isRedeemPoint.value,
  redeemedPoints: redeemedPoints.value,
  selected: selected.value,
  tempSplits: tempSplits.value,
  items: items.value
}));

// ✅ Watch the whole bill and sync it
watch(currentBill, (newVal) => {
  const allBills = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY) || '[]');
  const index = allBills.findIndex(b => b.billNo === newVal.billNo);

  if (index !== -1) {
    allBills[index] = newVal;
    localStorage.setItem(LOCAL_BILLS_KEY, JSON.stringify(allBills));
  }

  // ✅ Refresh `draftBills` and `selectedDraft` from localStorage
  const updated = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY) || '[]');
  draftBills.value = updated;
  selectedDraft.value = updated.find(b => b.billNo === newVal.billNo);
}, { deep: true });


// ✅ Create new bill
function createNewBill() {
  const existing = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY) || '[]');
  const maxNo = Math.max(0, ...existing.map(b => parseInt(b.billNo) || 0));
  const newBillNo = (maxNo + 1).toString();

  billNo.value = newBillNo;
  date.value = new Date().toISOString();
  discount.value = 0;
  returnAmt.value = 0;
  redeemedAmt.value = 0;
  paymentMethod.value = 'Cash';
  phoneNo.value = '';
  points.value = 0;
  clientName.value = '';
  clientId.value = '';
  voucherNo.value = '';
  token.value = '';
  tokenEntries.value = [];
  splitPayments.value = [];
  isRedeemPoint.value = false;
  redeemedPoints.value = 0;
  selected.value = null;
  tempSplits.value = Object.fromEntries(paymentOptionsInsplit.map(method => [method, { method, amount: null }]));
  items.value = [{
    id: '', variantId: '', name: '', sn: 1, barcode: '', category: [], size: '',
    item: '', qty: 1, rate: null, discount: null, tax: null, value: 0,
    sizes: {}, totalQty: 0, return: false, userCode: null, userId: null, user: null
  }];

  const newBill = currentBill.value;
  existing.push(newBill);
  localStorage.setItem(LOCAL_BILLS_KEY, JSON.stringify(existing));
  loadDraftBills();
  selectedDraft.value = newBill;
}

// ✅ Load all drafts into memory
function loadDraftBills() {
  try {
    draftBills.value = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY) || '[]');
  } catch (e) {
    console.error('Failed to parse draft bills:', e);
    draftBills.value = [];
  }
}

// ✅ Load a specific bill
function loadBill(billNumber) {
  const bill = draftBills.value.find(b => b.billNo === billNumber);
  if (!bill) return;

  billNo.value = bill.billNo ?? '';
  date.value = new Date().toISOString();
  discount.value = bill.discount ?? 0;
  returnAmt.value = bill.returnAmt ?? 0;
  redeemedAmt.value = bill.redeemedAmt ?? 0;
  paymentMethod.value = bill.paymentMethod ?? 'Cash';
  phoneNo.value = bill.phoneNo ?? '';
  points.value = bill.points ?? 0;
  clientName.value = bill.clientName ?? '';
  clientId.value = bill.clientId ?? '';
  voucherNo.value = bill.voucherNo ?? '';
  token.value = bill.token ?? '';
  tokenEntries.value = bill.tokenEntries ?? [];
  splitPayments.value = bill.splitPayments ?? [];
  isRedeemPoint.value = bill.isRedeemPoint ?? false;
  redeemedPoints.value = bill.redeemedPoints ?? 0;
  selected.value = bill.selected ?? null;
  tempSplits.value = bill.tempSplits ?? {};
  items.value = bill.items ?? [];
}

// ✅ Delete bill
function deleteBill(billNumber) {
  const deleted = draftBills.value.filter(b => b.billNo !== billNumber);
  localStorage.setItem(LOCAL_BILLS_KEY, JSON.stringify(deleted));
  loadDraftBills();

  const updated = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY));
  if (updated.length > 0) {
    selectedDraft.value = updated[0];
  }
}

// ✅ Watch for selection change
watch(selectedDraft, (val) => {
  if (val && val.billNo !== billNo.value) {
    loadBill(val.billNo);
  }
});


const reset = () => {
  items.value = [
    {
      id: '',
      variantId: '',
      sn: 1,
      size: '',
      barcode: '',
      category: [],
      item: '',
      qty: 1,
      rate: 0,
      discount: 0,
      tax: 0,
      value: 0,
      sizes: {},
      totalQty: 0,
      return:false
    },
  ];
  discount.value = 0;
  paymentMethod.value = 'Cash';
  tokenEntries.value = [''];
  clientName.value = '';
  clientId.value = '';
  phoneNo.value = '';
  points.value = 0;
  grandTotal.value = 0;
  selected.value = null;
  date.value = new Date().toISOString();
  isRedeemPoint.value = false;
  redeemedAmt.value = 0;
  returnAmt.value = 0;

  // Focus the barcode input
  const input = barcodeInputs.value[0]?.$el?.querySelector('input');
  input?.focus();
};




watch(
  items,
  (newItems) => {
    newItems.forEach((item, index) => {
      if (item.category.length > 1) {
        // Keep only the latest selected category
        const lastCategory = item.category[item.category.length - 1];
        items.value[index].category = [lastCategory];
      }
    });
  },
  { deep: true }
);


const columns = computed(() => [
  { key: 'sn', label: 'S.N' },
  { key: 'barcode', label: 'BAR CODE' },
  { key: 'category', label: 'CATEGORY' },
  { key: 'name', label: 'NAME' },
  { key: 'rate', label: 'RATE' },
  { key: 'qty', label: 'QTY' },
  { key: 'discount', label: 'DISC %' },
  ...(isUserTrackIncluded.value ? [{ key: 'user', label: 'User' }] : []),
  { key: 'tax', label: 'TAX%' },
  { key: 'value', label: 'VALUE' },
]);



const resizableTable = ref(null); // Reference to the table element

let isResizing = false;
let startX = 0;
let startWidth = 0;
let columnIndex = 0;

watch(selected, (newSelected) => {
  if(newSelected){
    paymentMethod.value = 'Credit'
  }
})

watch(redeemedAmt.value, (newValue) => {
  if (newValue > 0) {
    grandTotal.value = grandTotal.value - newValue;
  }
});

watch(paymentMethod, (newMethod) => {
  if (newMethod !== 'Split') {
     const index = paymentOptions.value.indexOf('Split');
    if (index !== -1) {
      paymentOptions.value.splice(index, 1);
    }
  }else {
    if (!paymentOptions.value.includes('Split')) {
      paymentOptions.value.push('Split');
    }
  }
});




watch(items, async () => {
  for (let index = 0; index < items.value.length; index++) {
    const item = items.value[index];
    
    // ---------- Step 1: Calculate discounted rate ----------
    let discountedRate = item.rate;

    const discount = !isNaN(Number(item.discount)) ? Number(item.discount) : 0;

    if (discount < 0) {
      discountedRate -= Math.abs(discount);
    } else {
      discountedRate -= (discountedRate * discount) / 100;
    }

    // ---------- Step 2: Update tax according to value/qty ----------


    if (item.category[0]?.id) {
      const category = categoryStore.getCategoryById(item.category[0].id)
     
      if( category){
        const { taxType, fixedTax, thresholdAmount, taxBelowThreshold, taxAboveThreshold } = category;

      if (taxType === 'FIXED') {
        item.tax = fixedTax ?? 0;
      } else {
        const effectiveValue = item.value / (item.qty || 1); // avoid division by zero

        if (effectiveValue > thresholdAmount) {
          item.tax = taxAboveThreshold ?? 0;
        } else {
          item.tax = taxBelowThreshold ?? 0;
        }
      }
      }

    }

    
    // ---------- Step 3: Calculate base value ----------
    let baseValue = discountedRate * (item.qty || 1);
    
    if (!isTaxIncluded.value) {
      baseValue += (baseValue * item.tax) / 100;
    }

    item.value = parseFloat(baseValue.toFixed(2));
  }
}, { deep: true });


const tQty = computed(() =>
  items.value.reduce((sum, item) => {
    if (item.barcode || item.name || item.category.length > 0) {
      return sum + (item.qty || 1);
    }
    return sum
  }, 0)
)

const startResize = (index, event) => {
  isResizing = true;
  columnIndex = index;
  startX = event.clientX;
  startWidth = resizableTable.value.querySelectorAll('th')[index].offsetWidth;

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
};

const handleResize = (event) => {
  if (!isResizing) return;

  const currentX = event.clientX;
  const deltaX = currentX - startX;
  const newWidth = startWidth + deltaX;

  // Update the width of the column
  const th = resizableTable.value.querySelectorAll('th')[columnIndex];
  th.style.width = `${newWidth}px`;

  // Update the width of the corresponding cells
  const tds = resizableTable.value.querySelectorAll(`td:nth-child(${columnIndex + 1})`);
  tds.forEach((td) => {
    td.style.width = `${newWidth}px`;
  });
};

const stopResize = () => {
  isResizing = false;
  document.removeEventListener('mousemove', handleResize);
  document.removeEventListener('mouseup', stopResize);
};

const addNewRow = async (index,moveTonNextRow = true) => {
  const hasEmptyRow = items.value.some(item => {
    return !item.variantId?.trim() && !item.name?.trim() && !item.barcode?.trim() && !item.category?.length && item.qty > 0;
  });

  if (!hasEmptyRow) {
  items.value.push({
    id: '',
    variantId: '',
    sn: items.value.length + 1,
    barcode: '',
    category: {},
    size: '',
    name: '',
    qty: 1,
    rate: null,
    discount: null,
    tax: null,
    value: 0,
    sizes: {},
    totalQty: 0,
    return:false,
    userCode:null,
    user:null,
    userId:null
  });
  }


  await nextTick();
  if(moveTonNextRow){
    const component = barcodeInputs.value[index + 1];
    const input = component?.$el?.querySelector("input");
    if (input) input.focus();
  }
};


const removeRow = (event,index) => {
  const inputValue = event.target.value || null;
  if (!inputValue) {
    event.preventDefault();
    if (items.value.length > 1) {
    items.value.splice(index, 1);
    // Reorder serial numbers after deletion
    items.value.forEach((item, i) => {
      item.sn = i + 1;
    });
  }
  const component = barcodeInputs.value[index - 1 ];
  if (component?.$el) {
    const input = component.$el.querySelector("input");
    if (input) {
      input.focus();
    } else {
      console.warn("Input element not found inside barcodeInputs:", component.$el);
    }
  } else {
    console.warn("Barcode input component is not available:", component);
  }
  }

  
};



onMounted(() => {
  // Initialize column widths (optional)
  const ths = resizableTable.value.querySelectorAll('th');
  ths.forEach((th) => {
    th.style.width = `${th.offsetWidth}px`;
  });
});

const args = computed(() => ({
  where: {
    phone: `+91${phoneNo.value}`,
    companies: {
      some: {
        companyId: useAuth().session.value?.companyId,
      },
    },
  },
  include: {
    companies: {
      where: {
        companyId: useAuth().session.value?.companyId,
      },
      select: {
        points: true,
      },
    },
  },
}));



 const {
  data: client,
  isLoading:isClientLoading,
  error,
  refetch:refetchClient,
} = useFindUniqueClient(
  args,
  { enabled: false }
);


const {
    data: categories,
} = useFindManyCategory(
  {
    where:{companyId:useAuth().session.value?.companyId},
    select:{
      id:true,
      name:true,
      hsn:true,
    }
}
);


const itemargs = computed(() => ({
  where:  {
        barcode: scannedBarcode.value,
        companyId: useAuth().session.value?.companyId
      },
  select: {
    id: true,
    size: true,
    qty: true,
    variant: {
      select: {
        id: true,
        sprice: true,
        name: true,
        tax: true,
        discount: true,
        product: {
          select: {
            name: true,
            categoryId: true,
            category: {
              select: {
                taxType: true,
                fixedTax: true,
                thresholdAmount: true,
                taxBelowThreshold: true,
                taxAboveThreshold: true
              }
            }
          }
        }
      }
    }
  }
}));




const entryargs = computed(() => ({
    where: {
        tokenNo: { in: tokenEntries.value }  // Fetch all entries matching tokenNos
    }
}));

const { data: itemdata ,refetch:itemRefetch} = useFindFirstItem(itemargs);
const { data: entrydata ,refetch:entryRefetch} = useFindManyTokenEntry(entryargs,{enable:false});

const handleEnterBarcode = (barcode,index) => {
 const pattern = /^\d+[A-Z]\d{6}$/;

  if(!barcode){
    if(token.value){
      const component = savetokenref.value;
      const button = component.$el;
      button.focus();
    }
    else{
    const component = discountref.value;
    const input = component.$el.querySelector("input");
    input.focus();
    input.select();
    }
  }else{
    if(!pattern.test(barcode)){
      const categorystore = categoryStore.getCategoryByShortCut(barcode)
      items.value[index].category = categories.value.filter(category =>category.id === categorystore.id)
      items.value[index].barcode = '';
      const component = rateInputs.value[index];
      const input = component.$el.querySelector("input");
      input.select();
    }else{
      fetchItemData(barcode, index);
      addNewRow(index);
    }
}}

const handleEnterMainDiscount = () => {
  const component = paymentref.value;
  const select = component.$el.querySelector("select");
  select.focus();
};

const handleEnterPayment = () => {
  const component = saveref.value;
  const button = component.$el;
  button.focus();
};


const handleTokenInputEnter = async(index) => {
  if(!tokenEntries.value[index]){
    const component = addTokenRef.value;
    const button = component.$el;
    button.focus();
    
  }else{
    addEntry()
    await nextTick();
    const component = tokenInputs.value[index + 1];
    const input = component.$el.querySelector("input");
    input.focus();
    input.select();
  }
  
}

const handleTokenDelete = (index, event) => {
  if(!tokenEntries.value[index] && tokenEntries.value.length > 1){
    event.preventDefault()
    tokenEntries.value.splice(index,1)
    const component = tokenInputs.value[index-1];
    const input = component.$el.querySelector("input");
    input.focus();

  }
}

const selectAllText = (index) => {
  const component = barcodeInputs.value[index];
  if (component?.$el) {
    const input = component.$el.querySelector("input");
    if (input) {
      input.select();
    }
  }
};

watch(itemdata, (newData) => {
  if (!newData) return;
  
  lastResponse.value = {
    data: newData,
    requestId: scannedBarcode.value 
  };
  
  processItemResponse(newData);
});

const fetchItemData = async (barcode, index) => {
  if (!barcode) return;
 loadingStates.value[index] = true;
  // Store the current barcode and index
  currentRequestIds.value[index] = barcode;
  scannedBarcode.value = barcode;
  
  try {
    await itemRefetch();
    // Check if this is still the active request for this index
    if (currentRequestIds.value[index] !== barcode) {
      return; // Newer request has been made
    }
    
    // Process the response if we got one
    if (lastResponse.value?.requestId === barcode && itemdata.value) {
      processItemResponse(itemdata.value, index);
    } else if (!itemdata.value) {
      handleInvalidBarcode(index);
    }
  } catch (error) {
    console.error('Error fetching item:', error);
    if (currentRequestIds.value[index] === barcode) {
      handleInvalidBarcode(index);
    }
  } finally{
     loadingStates.value[index] = false;
  }
};

const fetchItemDataNonBarcode = async (categoryId, sPrice, index) => {
  if (!categoryId || !sPrice) return;

  try {
    const { data } = await useFetch('/api/items/findFirst', {
      query: {
        categoryId,
        sPrice: Math.abs(sPrice),
      }
    });

    if (data.value?.data) {
      const itemData = data.value.data;
      items.value[index] = {
        ...items.value[index],
        id: itemData.id || '',
        size: itemData.size || '',
        name: `${itemData.variant?.name}-${itemData.variant?.product?.name}` || '',
        rate: sPrice || 0,
        discount: itemData.variant?.discount || 0,
        tax: itemData.variant?.tax || 0,
        totalQty: itemData.variant?.qty || 0,
        sizes: itemData.variant?.sizes || null,
        variantId: itemData.variant?.id || ''
      };
    }
  } catch (error) {
    console.error('Error fetching item:', error);
  }
};

const processItemResponse = (itemData, index) => {
  if (!items.value[index]) {
    return;
  }

  const categoryId = itemData.variant.product.categoryId;

  items.value[index].id = itemData.id || '';
  items.value[index].size = itemData.size || '';
  items.value[index].name = `${itemData.variant?.name}-${itemData.variant.product.name}` || '';
  items.value[index].category = categories.value.filter(category => category.id === categoryId);
  items.value[index].rate = itemData.variant?.sprice || 0;
  items.value[index].discount = itemData.variant?.discount || 0;
  items.value[index].tax = itemData.variant?.tax || 0;
  items.value[index].totalQty = itemData.variant?.qty || 0;
  items.value[index].sizes = itemData.variant?.sizes || null;
  items.value[index].variantId = itemData.variant?.id || '';

  delete currentRequestIds.value[index];
};

const handleInvalidBarcode = (index) => {
  items.value[index].barcode = '';
  toast.add({
    title: 'Barcode is invalid or item is empty!',
    color: 'red',
  });
  delete currentRequestIds.value[index];
};

const reconstructBill = (data) => {
   const {
    payload,
    items,
    returnedItems,
    billPoints,
    clientId,
    companyId,
    userId,
    tokenEntries
  } = data
  const existing = JSON.parse(localStorage.getItem(LOCAL_BILLS_KEY) || '[]');
  const maxNo = Math.max(0, ...existing.map(b => parseInt(b.billNo) || 0));
  const newBillNo = (maxNo + 1).toString();

  billNo.value = newBillNo;
  date.value = new Date(payload.createdAt).toISOString();
  discount.value = payload.discount;
  returnAmt.value = payload.returnAmnt;
  redeemedAmt.value = payload.redeemedPoints;
  paymentMethod.value = payload.paymentMethod;
  phoneNo.value = '';
  points.value = 0;
  clientName.value = '';
  clientId.value = payload.client.connect.id;
  voucherNo.value = '';
  token.value = '';
  tokenEntries.value = [];
  splitPayments.value = payload.splitPayments;
  isRedeemPoint.value = payload.redeemedPoints ? true : false;;
  redeemedPoints.value = payload.redeemedPoints
  selected.value = payload.selected;
  tempSplits.value = Object.fromEntries(paymentOptionsInsplit.map(method => [method, { method, amount: null }]));
  items.value = items;

  const newBill = currentBill.value;
  existing.push(newBill);
  localStorage.setItem(LOCAL_BILLS_KEY, JSON.stringify(existing));
  loadDraftBills();
}


const handleSave = async () => {
  isSaving.value = true;

  try {
    // 1. Filter valid entries
    if (!navigator.onLine) {
    throw createError({
      statusCode: 0,
      statusMessage: 'No internet connection',
    })
  }
    items.value = items.value.filter(item =>
      item.name?.trim() || item.barcode?.trim() || item.category?.length > 0
    );

    if (items.value.length === 0) {
      items.value = [{
        id: '', variantId: '', sn: 1, size: '', barcode: '', category: [], item: '',
        qty: 1, rate: 0, discount: 0, tax: 0, value: 0, sizes: {}, totalQty: 0
      }];
      discount.value = 0;
      paymentMethod.value = 'Cash';
      tokenEntries.value = [''];
      throw new Error(`No valid Entry in bill.`);
    }

    items.value.forEach((item, index) => {
      if (!item.category?.[0]?.id) {
        throw new Error(`No category in entry ${index + 1}`);
      }
    });

    if (!isBarcodeIncluded.value) {
      await Promise.all(
        items.value.map((item, index) =>
          fetchItemDataNonBarcode(item.category[0]?.id, item.rate, index)
        )
      );
    }

    const billInv = `${useAuth().session.value?.code}/${useAuth().session.value?.billCounter}`;
    const pointsValue = Number(useAuth().session.value?.pointsValue || 0);
    const billPoints = pointsValue > 0 ? Number(grandTotal.value) / pointsValue : 0;
    const returnedItems = items.value.filter(item => item.return);

    const entriesData = items.value.map(item => {
      const entry = {
        name: item.name || '',
        qty: Number(item.qty || 1),
        rate: Number(item.rate || 0),
        discount: Number(item.discount || 0),
        tax: Number(item.tax || 0),
        value: Number(item.value || 0),
        return: item.return || false,
        ...(item.size && { size: item.size }),
        ...(item.barcode && { barcode: item.barcode }),
        ...(item.id && { item: { connect: { id: item.id } } }),
        ...(item.variantId && { variant: { connect: { id: item.variantId } } }),
        ...(item.category?.[0]?.id && {
          category: { connect: { id: item.category[0].id } }
        }),
        ...(item.userId && {
          userName: item.user,
          companyUser: {
            connect: {
              companyId_userId: {
                companyId: useAuth().session.value?.companyId,
                userId: item.userId,
              }
            }
          }
        })
      };
      return entry;
    });

    const payload = {
      invoiceNumber: billInv,
      subtotal: Number(subtotal.value) || 0,
      discount: Number(discount.value) || 0,
      grandTotal: Number(grandTotal.value) || 0,
      returnAmt: Number(returnAmt.value) || 0,
      paymentMethod: paymentMethod.value || 'Cash',
      ...(redeemedPoints.value && { redeemedPoints: redeemedPoints.value || 0 }),
      ...(!clientId.value ? { billPoints: 0 } : { billPoints }),
      createdAt: new Date(date.value).toISOString(),
      paymentStatus: paymentMethod.value === 'Credit' ? 'PENDING' : 'PAID',
      type: 'BILL',
      entries: { create: entriesData },
      company: {
        connect: {
          id: useAuth().session.value?.companyId,
        },
      },
      companyUser: {
        connect: {
          companyId_userId: {
            companyId: useAuth().session.value?.companyId,
            userId: useAuth().session.value?.id,
          }
        }
      },
      ...(clientId.value && {
        client: { connect: { id: clientId.value } }
      }),
      ...(selected.value && {
        account: { connect: { id: selected.value } }
      }),
      ...(paymentMethod.value === 'Split' && {
        splitPayments: splitPayments.value
      }),
    };

    // 🔁 Backend call to handle everything with Prisma transaction
    $fetch('/api/bill/create', {
      method: 'POST',
      body: {
        payload,
        items: items.value,
        returnedItems,
        billPoints,
        clientId: clientId.value,
        companyId: useAuth().session.value?.companyId,
        userId: useAuth().session.value?.id,
        tokenEntries: tokenEntries.value,
      }
    }).then(() => {
    toast.add({
      title: 'Bill created successfully!',
      color: 'green',
    });

      queryClient.invalidateQueries({
        queryKey: ['zenstack', 'Bill', 'findMany'],
        exact: false
      });
        queryClient.invalidateQueries({
        queryKey: ['zenstack', 'Product', 'findMany'],
        exact: false
      });
    }).catch(error => {
        reconstructBill(error.data.data)
       toast.add({
        title: 'Bill creation failed!',
        description:'Check the last draft',
        color: 'red',
      });
   
    }).finally(() => {
       isSaving.value = false
      updateBillCounter();
    })

    // 🧾 Trigger Print
    isPrint.value = true;
    printData = {
      invoiceNumber: billInv,
      date: new Date(date.value).toISOString(),
      entries: items.value.map(entry => {
        const discountVal = entry.discount < 0
          ? entry.discount
          : entry.discount > 0
            ? `${entry.discount}%`
            : 0;
        return {
          description: entry.barcode ? entry.name : entry.category[0].name,
          hsn: entry.category[0].hsn,
          qty: entry.qty,
          mrp: entry.rate,
          discount: discountVal,
          tax: entry.tax,
          value: entry.qty * entry.rate,
          size: entry.size,
          barcode: entry.barcode,
          tvalue: entry.value,
        };
      }),
      subtotal: subtotal.value,
      discount: Number(discount.value),
      grandTotal: grandTotal.value,
      paymentMethod: paymentMethod.value,
      companyName: useAuth().session.value?.companyName || '',
      companyAddress: useAuth().session.value?.address || {},
      gstin: useAuth().session.value?.gstin || '',
      ...(paymentMethod.value === 'Split' && {
        splitPayments: splitPayments.value
      }),
      accHolderName: useAuth().session.value?.accHolderName || '',
      upiId: useAuth().session.value?.upiId || '',
      clientName: clientName.value,
      clientPhone: phoneNo.value,
      tqty: items.value.reduce((sum, entry) => sum + entry.qty, 0),
      tvalue: items.value.reduce((sum, entry) => sum + (entry.qty * entry.rate), 0),
      ttvalue: items.value.reduce((sum, entry) => sum + entry.value, 0),
      tdiscount: items.value.reduce((sum, entry) => {
        if (entry.discount < 0) {
          return sum + (Math.abs(entry.discount) * entry.qty);
        } else {
          return sum + (((entry.rate * entry.discount) / 100) * entry.qty);
        }
      }, 0)
    };

    // 🔔 Notify users (FCM + backend)
    // await $fetch('/api/notifications/notify', {
    //   method: 'POST',
    //   body: {
    //     userId: useAuth().session.value?.id,
    //     type: 'BILL',
    //     companyId: useAuth().session.value?.companyId,
    //     invoiceNumber: billInv,
    //     amount: grandTotal.value
    //   }
    // });

     $fetch('/api/notifyfcm', {
      method: 'POST',
      body: {
        companyId: useAuth().session.value?.companyId,
        excludeDeviceId: localStorage.getItem('device_id'),
        title: `New Bill Created in ${useAuth().session.value?.companyName}`,
        body: `Invoice #${billInv} for ₹${grandTotal.value} has been created.`,
        data: {
          url: '/erp/sales'
        }
      }
    });

    reset();

  } catch (error) {
    console.error('Error creating bill', error);
    toast.add({
      title: 'Bill creation failed!',
      description: error.message,
      color: 'red',
    });
  }
};



const print = async() => {
  try{
  await printBill(printData)
  isPrint.value = false
  toast.add({
        title: 'Printing Sucess!',
        color: 'Green',
      });
  }catch(err){
      toast.add({
        title: 'Printing failed!',
        description: err.message,
        color: 'red',
      });
  }
}


const {
    data: accounts
} = useFindManyAccount({
      where: { companyId: useAuth().session.value?.companyId},
});


const submitForm = () => {
  isSavingAcc.value = true
  try {
    
    if (!account.value.name) {
        throw new Error(`Plase Fill name`);
      }
    const res = CreateAccount.mutateAsync({
      data: {
                id: uuidv4(),
                name: account.value.name,
                phone: account.value.phone,
                address: {
                    create: {
                        street: account.value.street,
                        locality: account.value.locality,
                        city: account.value.city,
                        state: account.value.state,
                        pincode: account.value.pincode,
                    },
                },
                company:{
                  connect:{
                        id:useAuth().session.value?.companyId
                      }
                  }
              }
    })
    toast.add({
            title: 'Account added !',
            id: 'modal-success',
        });
    isOpen.value = false
  }catch(error){
     toast.add({
        title: 'Account creation failed!',
        description: error.message,
        color: 'red',
      });
  }finally{
    isSavingAcc.value = false
  }
};



const handleTokenSave = async () => {
  items.value = items.value.filter(item => item.id || item.barcode);
  try {
    // Create the bill first
    const billResponse = await Promise.all(
    items.value.map(item => 
        CreateTokenEntry.mutateAsync({
            data: {
                tokenNo: token.value,
                createdAt: new Date().toISOString(),
                company: {
                    connect: {
                        id: useAuth().session.value?.companyId,
                    },
                },
                itemId: item.id || '',
                variantId: item.variantId || '',
                barcode: item.barcode || '',
                categoryId: item.category[0]?.id || '', 
                size: item.size || '',
                name: item.name || '',
                qty: item.qty,
                rate: item.rate,
                discount: item.discount,
                tax: item.tax,
                value: item.value,
                sizes: item.sizes, 
                totalQty: item.totalQty,
            }
        })
    )
);

    
  } catch (error) {
    console.error('Error creating bill', error);
  }


  try {
   
    for (const item of items.value) {
          await UpdateItem.mutateAsync({
            where: { id: item.id },
            data: {
              status: 'tokened',
            },
          });

         
        }
    } catch (error) {
    console.error('Error updating item and variant', error);
  }
    

    // Optionally, you can reset the form or perform other actions after successful creation
    items.value = [
    { id:'', variantId:'',sn: 1,size:'', barcode: '',category:[], item: '', qty: 1,rate: 0, discount: 0, tax: 0, value: 0, sizes:{}, totalQty:0,userCode:null,userId:null,user:null }
    ];
    token.value = '';
    discount.value = 0;
    paymentMethod.value = 'Cash';

};

const addEntry = () => {
  tokenEntries.value.push('')  // Add a new empty entry
}

const removeEntry = (index) => {
  if (tokenEntries.value.length > 1) {
    tokenEntries.value.splice(index, 1)
  }
}

const submitEntryForm = async () => {
    await entryRefetch();

    if (entrydata.value) {
        // Remove existing empty item if it exists
        items.value = items.value.filter(item => item.id || item.barcode);

        // Add fetched entries to existing items
        const newItems = entrydata.value.map((entry, index) => ({
            id: entry.id || '',
            variantId: entry.variantId || '',
            barcode: entry.barcode || '',
            category: categories.value.filter(category => category.id === entry.categoryId) || [],
            size: entry.size || '',
            item: entry.name || '',
            qty: entry.qty || 0,
            rate: entry.rate|| 0,
            discount: entry.discount|| 0,
            tax: entry.tax|| 0,
            value: entry.value|| 0,
            sizes: entry.sizes || '{}',
            totalQty: entry.totalQty|| 0,
        }));

        // Append the new items
        items.value = newItems;

        // Add an empty item at the end
        items.value.push({
            id: '', variantId: '', sn: items.value.length + 1, barcode: '',
            category: {}, size: '', item: '', qty: 1, rate: 0,
            discount: 0, tax: 0, value: 0, sizes: {}, totalQty: 0
        });

    } else {
        console.warn("entrydata is undefined");
    }
};

const newBill = () => {
  createNewBill()

  // items.value = [
  //   { id:'', variantId:'',sn: 1,size:'', barcode: '',category:[], item: '', qty: 1,rate: 0, discount: 0, tax: 0, value: 0, sizes:{}, totalQty:0 }
  // ];
  // discount.value = 0;
  // paymentMethod.value = 'Cash';

  // token.value = '';
  // tokenEntries.value = [''];
  // grandTotal.value = 0;
  // returnAmt.value = 0;
  // phoneNo.value = '';
  // points.value = 0;
  // name.value = '';
  // voucherNo.value = '';
  // selected.value = {};
  // account.value = {
  //   name: '',
  //   phone:'',
  //   street: '',
  //   locality: '',
  //   city: '',
  //   state: '',
  //   pincode: '',
  // };

};

const moveFocus = (currentRowIndex, currentField, direction) => {
  const baseFieldOrder = ['barcode', 'category', 'name', 'rate', 'qty', 'discount', 'tax'];
  const fieldOrder = isUserTrackIncluded ? [...baseFieldOrder.slice(0, 6), 'user', 'tax'] : baseFieldOrder;

  const currentFieldIndex = fieldOrder.indexOf(currentField);

  let nextRowIndex = currentRowIndex;
  let nextFieldIndex = currentFieldIndex;

  switch (direction) {
    case 'up':
      nextRowIndex = Math.max(0, currentRowIndex - 1);
      break;
    case 'down':
      nextRowIndex = Math.min(items.value.length - 1, currentRowIndex + 1);
      break;
    case 'left':
      nextFieldIndex = Math.max(0, currentFieldIndex - 1);
      break;
    case 'right':
      nextFieldIndex = Math.min(fieldOrder.length - 1, currentFieldIndex + 1);
      break;
  }

  // If we changed rows, keep the same column
  if (direction === 'up' || direction === 'down') {
    nextFieldIndex = currentFieldIndex;
  }

  focusInput(nextRowIndex, fieldOrder[nextFieldIndex]);
};

const focusInput = async (rowIndex, field) => {
  await nextTick();
  try {
    switch (field) {
      case 'barcode':
        barcodeInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        break;
      case 'category':
        categoryInputs.value[rowIndex]?.querySelector('button')?.focus();
        break;
      case 'name':
        nameInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        break;
      case 'qty':
        qtyInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        break;
      case 'rate':
        rateInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        break;
      case 'discount':
        discountInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        break;
      case 'user':
        if (isUserTrackIncluded) {
          userInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        }
        break;
      case 'tax':
        taxInputs.value[rowIndex]?.$el?.querySelector('input')?.select();
        break;
    }
  } catch (e) {
    console.error('Error focusing input:', e);
  }
};
const movecatgeory = (rowIndex) => {
  const td = categoryInputs.value[rowIndex];
  if (!td) return;

  const button = td.querySelector('button');
  if (!button) return;

  button.focus();
  button.click(); // Open the dropdown

  setTimeout(() => {
    const ul = td.querySelector('ul[role="listbox"]');
    if (!ul) return;

    // Set focus to the input inside the dropdown if available
    const comboInput = ul.querySelector('input[role="combobox"]');
    if (comboInput) {
      comboInput.focus();
    } else {
      ul.focus(); // fallback
    }

    // Add key listener to ul
    ul.addEventListener('keydown', function handler(e) {
      if (e.key === 'ArrowRight') {
        button.click(); 
        nameInputs.value[rowIndex].$el.querySelector('input')?.focus();
       
      
      }
    });

    ul.addEventListener('keydown', function handler(e) {
      if (e.key === 'ArrowLeft') {
        button.click(); 
        barcodeInputs.value[rowIndex].$el.querySelector('input').focus();
        requestAnimationFrame(() => {
          barcodeInputs.value[rowIndex].$el.querySelector('input').select();
        });
      }
    });
  }, 100); // enough time for dropdown to render
};

onMounted(() => {
  nextTick(() => {
    const input = barcodeInputs.value[0]?.$el?.querySelector('input');
    input?.focus();
  });
});

const handleReturnData = ({ returnedItems }) => {
  items.value = items.value.filter(item =>
      item.name?.trim() || item.barcode?.trim() || item.category?.length > 0
    );
    const baseIndex = items.value.length;

    returnedItems.forEach((item, i) => {
      item.sn = baseIndex + i + 1; // Ensure sn = position in array (1-based)
    });

    items.value.push(...returnedItems);
    addNewRow(items.value.length - 1);

};


const handleEnterPhone = async() => {
  const { data } = await refetchClient()
  clientName.value = data?.name
  clientId.value = data?.id
  points.value = data?.companies[0]?.points
  if(!data){
    isClientAddModelOpen.value = true;
  }
}

const handleClientAdded = (id,name) => {
  clientName.value = name
  clientId.value = id
  points.value = 0
  isClientAddModelOpen.value = false;
};





const handleAmountEntry = (method) => {
  const entry = tempSplits.value[method]
  const exists = splitPayments.value.find(p => p.method === method)

  if (entry.amount && !exists) {
    splitPayments.value.push({ method, amount: entry.amount })
  } else if (!entry.amount && exists) {
    // If amount cleared, remove from list
    splitPayments.value = splitPayments.value.filter(p => p.method !== method)
  } else if (entry.amount && exists) {
    // Update amount if already present
    exists.amount = entry.amount
  }
}



// Total calculation
const totalSplitAmount = computed(() =>
  splitPayments.value.reduce((sum, entry) => sum + Number(entry.amount || 0), 0)
)



const handleSplit = () => {
  showSplitModal.value = true
}



// Final submission
function submitSplitPayment() {
  if (totalSplitAmount.value !== grandTotal.value) {
    alert(`Total split amount must be exactly ${grandTotal.value}`)
    return
  }
  showSplitModal.value = false
   if (!paymentOptions.value.includes('Split')) {
    paymentOptions.value.push('Split');
    paymentMethod.value = 'Split';
  }
  
}

function handleCategoryChange(category, rowIndex) {
  const isEmpty = !category || Object.keys(category).length === 0;

  if (!isEmpty) {
    rateInputs.value[rowIndex]?.$el?.querySelector('input')?.focus();
      addNewRow(rowIndex,false)
  }
}

onMounted(() => {
  isMobile.value = window.innerWidth < 640;
  window.addEventListener('resize', () => {
    isMobile.value = window.innerWidth < 640;
  });
});

async function updateUserDetails(index, user) {
if(!user) return
  const userdetails = userStore.getuserByCode(user)

  if (userdetails) {
    console.log(userdetails)
    items.value[index].userCode = user
    items.value[index].user = userdetails.name || null
    items.value[index].userId = userdetails.id || null

  } else {
    items.value[index].user = null // Optional: clear name if user not found
     toast.add({
    title: 'user code invalid!',
    color: 'red',
  });
  }
}

const handleDiscountEnter = (index) => {
  if (isUserTrackIncluded.value) {
    moveFocus(index, 'discount', 'right');
  } else {
    addNewRow(index);
  }
};

const handleRedeemPoints = async () => {
  isRedeemPoint.value = !isRedeemPoint.value;
  redeeming.value = true;

  if (isRedeemPoint.value) {
    if (clientId.value) {
      try {
        // Determine the redeemable points (not more than grand total)
        const redeemablePoints = Math.min(points.value, grandTotal.value);

        const res = await UpdateCompanyClientForRedeem.mutateAsync({
          where: {
            companyId_clientId: {
              companyId: useAuth().session.value?.companyId,
              clientId: clientId.value
            }
          },
          data: {
            points: { decrement: redeemablePoints }
          }
        });

        redeemedPoints.value = redeemablePoints;
        redeemedAmt.value = redeemablePoints;
        points.value = res.points;
        console.log(res);

      } catch (error) {
        console.error('Error updating client points', error);
      }
    }
  } else {
    // Revert redeemed points
    if (clientId.value) {
      try {
        const res = await UpdateCompanyClientForRedeem.mutateAsync({
          where: {
            companyId_clientId: {
              companyId: useAuth().session.value?.companyId,
              clientId: clientId.value
            }
          },
          data: {
            points: { increment: redeemedPoints.value }
          }
        });

        points.value = res.points;
        redeemedPoints.value = 0;
        redeemedAmt.value = 0;
        console.log(res);

      } catch (error) {
        console.error('Error updating client points', error);
      }
    }
  }

  redeeming.value = false;
};


</script>


<template>
  <UDashboardPanelContent class="p-1">
      <UCard 
    :ui="{
      base: 'h-full flex flex-col',
      rounded: '',
      ring: 'ring-0 sm:ring-1 sm:ring-gray-200 sm:dark:ring-gray-800', // force no ring on mobile
      divide: 'divide-y divide-gray-200 dark:divide-gray-700',
      body: {
        padding: '',
        base: 'sm:flex-1 sm:flex sm:flex-col sm:overflow-hidden grow divide-y divide-gray-200 dark:divide-gray-700 z-10'
      },
      footer: {
        base: 'divide-y divide-gray-200 dark:divide-gray-700',
        padding: ''
      },
       header: {
        base: '',
        padding: ''
      }
    }"
  >
    <template #header>
         <div v-if="showCamera" ref="videoRef" class="w-full h-[300px] bg-black rounded" />
     <div class="w-full flex flex-wrap gap-4 sm:hidden  py-2 px-2">
          <UButton color="blue" class="flex-1" block @click="newBill" >New</UButton>
          <UButton  v-if="!token" :loading="isSaving" ref="saveref" color="green" class="flex-1" block @click="handleSave">Save</UButton>
          <UButton  v-if="token" ref="savetokenref" color="green" class="flex-1" block @click="handleTokenSave">Save</UButton>
          <UButton v-if="!token" class="flex-1" @click="issalesReturnModelOpen = true" block>Return</UButton>
        </div>
    
        <div  class="sm:hidden flex flex-row items-center justify-between lg:col-span-2 gap-2 py-2 px-2">
        <div class="flex-1 border border-primary-700 dark:border-primary-300 rounded-md">
          <div class="flex flex-col items-center justify-center py-3">
            <div class="text-s">Sub Total</div>
            <div class="text-primary-700 dark:text-primary-300 font-bold text-2xl leading-none">₹{{ subtotal.toFixed(2) }}</div>
          </div>
        </div>
            

          <!-- Grand Total Display -->
          <div class="flex-1 border border-green-700 dark:border-green-300 rounded-md">
          <div class="flex flex-col items-center justify-center py-3">
            <div class="text-s">Grand Total</div>
            <div class="text-green-700 dark:text-green-300 font-bold text-2xl leading-none ">₹{{ grandTotal.toFixed(2) }}</div>
          </div>
        </div>
        </div>
     
         <div class="sm:hidden col-span-2 flex flex-row gap-2 py-2 px-2">
            <UInput v-if="!token" v-model="dateOnly" type="date" label="Date" class="flex-1" />
            <UButton color="primary" icon="i-heroicons-camera" label="Scan" block class="flex-1" @click="startCamera"/>
          </div>
        
       <div class="sm:grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-12 gap-4 text-sm hidden py-2 px-2">
  <!-- Date Input: visible only if token is empty -->
  <UInput v-if="!token" v-model="dateOnly" type="date" label="Date" class="lg:col-span-2" />

  <!-- Token Input -->
  <UInput v-model="token" label="Token" type="text" placeholder="Token No" class="lg:col-span-2" />

  <!-- Token Entries Button -->
  <UButton
    color="primary"
    label="Token Entries"
    class="lg:col-start-9 lg:col-span-2"
    block
    @click="isTokenOpen = true"
  />

  <!-- Draft Selector + Reset -->
  <div class="lg:col-start-11 lg:col-span-3 flex flex-row items-center gap-2">
    <USelectMenu
      v-model="selectedDraft"
      :options="draftBills"
      placeholder="Select Draft Bill"
      class="flex-1"
    >
      <template #label>
        <span>Draft {{ selectedDraft?.billNo }}</span>
      </template>

      <template #option="{ option: bill }">
        <div class="flex justify-between items-center w-full px-2">
          <div class="font-medium">Draft {{ bill.billNo }}</div>
          <UButton
            v-if="draftBills.length > 1"
            class="text-red-500 hover:text-red-700 ml-2"
            icon="i-heroicons-x-circle"
            variant="ghost"
            @mousedown.prevent.stop="deleteBill(bill.billNo)"
          />
        </div>
      </template>
    </USelectMenu>

    <UButton
      color="primary"
      icon="i-heroicons-arrow-path"
      class="flex-shrink-0"
      @click="reset"
    />
  </div>
</div>


   </template>  

    
<div  v-if="isMobile" class="block sm:hidden space-y-4 py-1 px-2">
  <div
    v-for="(row, index) in items"
    :key="row.sn"    
    :class="[
      'p-4 text-sm space-y-3',   
      index % 2 === 0 
        ? 'bg-gray-300 dark:bg-zinc-700'  // Even rows
        : 'bg-gray-100 dark:bg-zinc-900'     // Odd rows
    ]"
  >
    <!-- SN, Name, Value row -->
    <div class="flex justify-between text-gray-800 dark:text-gray-200 font-medium">
      <span  :class="{ 'text-red-600': row.return }">SN: {{ row.sn }}</span>
      <span  :class="{ 'text-red-600': row.return }">{{ row.name }}</span>
      <span  :class="{ 'text-red-600': row.return }">₹{{ row.value }}</span>
    </div>

    <!-- Row 1: Barcode | Qty | Discount -->
    <div class="grid grid-cols-3 gap-2">
      <UInput
        v-model="row.barcode"
        placeholder="Barcode"
        size="sm"
        ref="barcodeInputs"
         :color="row.return ? 'red' : undefined"
        @blur="fetchItemData(row.barcode, index)"
        @focus="selectAllText(index)"
        @keyup.delete="removeRow($event, index)"
        enterkeyhint="enter"
        @keyup.enter.prevent="handleEnterBarcode(row.barcode, index)"
        @keyup.tab.prevent="handleEnterBarcode(row.barcode, index)"
      />
       <UInput
        v-model="row.rate"
        ref="rateInputs"
        placeholder="Rate"
        type="number"
        size="sm"
         enterkeyhint="enter"
          :color="row.return ? 'red' : undefined"
        @keyup.enter="moveFocus(index, 'rate', 'right')"
        @keyup.tab.prevent="moveFocus(index, 'rate', 'right')"
      />
      
      <UInput
        v-model="row.discount"
        placeholder="Discount"
        ref="discountInputs" 
        type="text"
        size="sm"
        inputmode="decimal"
        pattern="^-?[0-9]*[.,]?[0-9]*$"
         enterkeyhint="enter"
          :color="row.return ? 'red' : undefined"
        @keyup.enter="addNewRow(index)"
        @keyup.tab.prevent="addNewRow(index)"
      />
    </div>

    <!-- Row 2: Category | Rate | Tax -->
    <div class="grid grid-cols-3 gap-2 z-10 ">
      <USelectMenu
        v-model="row.category"
        :options="categories"
        option-attribute="name"
         :color="row.return ? 'red' : undefined"
        @update:modelValue="() => handleCategoryChange(row.category, index)"
        track-by="id"
        multiple
        searchable
        placeholder="Category"
      >
        <template #label>
          <span v-if="row.category.length">{{ row.category.map(c => c.name).join(', ') }}</span>
          <span v-else class="text-gray-400">Category</span>
        </template>
      </USelectMenu>
      <UInput
        v-model="row.qty"
        placeholder="Qty"
        ref="qtyInputs" 
        type="number"
        size="sm"
         :color="row.return ? 'red' : undefined"
         enterkeyhint="enter"
       @keyup.enter="moveFocus(index, 'qty', 'right')"
       @keyup.tab.prevent="moveFocus(index, 'qty', 'right')"
      />
     
      <UInput
        v-model="row.tax"
        ref="taxInputs"
        placeholder="Tax"
        type="number"
        size="sm"
         enterkeyhint="enter"
          :color="row.return ? 'red' : undefined"
       @keyup.enter="addNewRow(index)"
       @keyup.tab.prevent="addNewRow(index)"
      />
    </div>
  </div>
</div>

         <!-- pc view -->
        <div v-else class="overflow-x-auto p-3 hidden sm:block">    
          <table class="min-w-full divide-y divide-gray-50 dark:divide-gray-800" ref="resizableTable">
            <thead class="">
              <tr>
                <th
                  v-for="(column, index) in columns"
                  :key="column.key"
                  class="px-2 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider relative"
                >
                  {{ column.label }}
                  <!-- Draggable divider -->
                  <div
                    v-if="index < columns.length - 1"
                    class="absolute right-0 top-0 bottom-0 b-w cursor-col-resize dark:bg-gray-800 hover:bg-blue-300"
                    @mousedown="startResize(index, $event)"
                  ></div>
                </th>
              </tr>
            </thead>
            <tbody class="divide-y divide-gray-50 dark:divide-gray-800">
  <tr v-for="(row, index) in items" :key="row.sn">
    <td class="py-1 whitespace-nowrap" :class="{ 'text-red-600': row.return }" @click="(event) => {
      isDeleteModalOpen = true;
      deletingRowIdentity = { index, event };}">
      {{ row.sn }}
    </td>
    <td class="py-1 whitespace-nowrap">
      <UInput
        v-model="row.barcode"
        ref="barcodeInputs"
        size="sm"
        :loading="loadingStates[index] || false"
         :color="row.return ? 'red' : undefined"
        @focus="selectAllText(index)"
        @blur="fetchItemData(row.barcode, index)"
        @keydown.delete="removeRow($event, index)"
        @keydown.enter.prevent="handleEnterBarcode(row.barcode, index)"
        @keydown.up.prevent="moveFocus(index, 'barcode', 'up')"
        @keydown.down.prevent="moveFocus(index, 'barcode', 'down')"
        @keydown.left.prevent="moveFocus(index, 'barcode', 'left')"
        @keydown.right.prevent="moveFocus(index, 'barcode', 'right')"
      />
    </td>
    <td class="py-1 whitespace-nowrap"  ref="categoryInputs">
      <USelectMenu  
        v-model="row.category" 
        @update:modelValue="() => handleCategoryChange(row.category, index)"
        :options="categories" 
        option-attribute="name"  
        option-key="id" 
        track-by="id"
        multiple 
        searchable
        searchable-placeholder="Search a Category..."
         :color="row.return ? 'red' : undefined"
        @keydown.up.prevent="moveFocus(index, 'category', 'up')"
        @keydown.down.prevent="moveFocus(index, 'category', 'down')"
        @keydown.left.prevent="movecatgeory(index)"
        @keydown.right.prevent="movecatgeory(index)"
        @keydown.enter.prevent="movecatgeory(index)"
      >
        <template #label>
          <span v-if="row.category.length" class="truncate">
            {{ row.category.map(item => item.name).join(', ') }}
          </span>
          <span v-else>Select Category</span>
        </template>
        <template  #option="{ option: category }">
          <span class="truncate">{{ category.name }}</span>
        </template>
      </USelectMenu>
    </td>
    <td class="py-1 whitespace-nowrap">
      <UInput 
        v-model="row.name" 
        ref="nameInputs"
        size="sm"  
         :color="row.return ? 'red' : undefined"
        @keydown.enter="moveFocus(index, 'name', 'right')"
        @keydown.up.prevent="moveFocus(index, 'name', 'up')"
        @keydown.down.prevent="moveFocus(index, 'name', 'down')"
        @keydown.left.prevent="moveFocus(index, 'name', 'left')"
        @keydown.right.prevent="moveFocus(index, 'name', 'right')"
      />
    </td>
    <td class="py-1 whitespace-nowrap">
      <UInput 
        v-model="row.rate" 
        type="number" 
        ref="rateInputs"
        size="sm"  
         :color="row.return ? 'red' : undefined"
        @keydown.enter="moveFocus(index, 'rate', 'right')"
        @keydown.up.prevent="moveFocus(index, 'rate', 'up')"
        @keydown.down.prevent="moveFocus(index, 'rate', 'down')"
        @keydown.left.prevent="moveFocus(index, 'rate', 'left')"
        @keydown.right.prevent="moveFocus(index, 'rate', 'right')"
      />
    </td>
    <td class="py-1 whitespace-nowrap">
      <UInput 
        v-model="row.qty"  
        ref="qtyInputs" 
        type="number" 
        size="sm"  
         :color="row.return ? 'red' : undefined"
         @keydown.enter="moveFocus(index, 'qty', 'right')"
        @keydown.up.prevent="moveFocus(index, 'qty', 'up')"
        @keydown.down.prevent="moveFocus(index, 'qty', 'down')"
        @keydown.left.prevent="moveFocus(index, 'qty', 'left')"
        @keydown.right.prevent="moveFocus(index, 'qty', 'right')"
      />
    </td>
   <td class="py-1 whitespace-nowrap">
    <UInput 
      v-model="row.discount" 
      type="number"
      ref="discountInputs" 
      size="sm"  
       :color="row.return ? 'red' : undefined"
      @keydown.enter="handleDiscountEnter(index)"
      @keydown.up.prevent="moveFocus(index, 'discount', 'up')"
      @keydown.down.prevent="moveFocus(index, 'discount', 'down')"
      @keydown.left.prevent="moveFocus(index, 'discount', 'left')"
      @keydown.right.prevent="moveFocus(index, 'discount', 'right')"
    />
  </td>

    <td class="py-1 whitespace-nowrap" v-if="isUserTrackIncluded">
      <UInput 
        v-model="row.user" 
        type="text"
        ref="userInputs" 
        size="sm"  
         :color="row.return ? 'red' : undefined"
        @keydown.enter="addNewRow(index); updateUserDetails(index,row.user)"
        @keydown.up.prevent="moveFocus(index, 'user', 'up')"
        @keydown.down.prevent="moveFocus(index, 'user', 'down')"
        @keydown.left.prevent="moveFocus(index, 'user', 'left')"
        @keydown.right.prevent="moveFocus(index, 'user', 'right')"
      />
    </td>
    <td class="py-1 whitespace-nowrap">
      <UInput 
        v-model="row.tax" 
          ref="taxInputs"
        type="number" 
        size="sm" 
         :color="row.return ? 'red' : undefined"
        @keydown.enter="addNewRow(index)"
        @keydown.up.prevent="moveFocus(index, 'tax', 'up')"
        @keydown.down.prevent="moveFocus(index, 'tax', 'down')"
        @keydown.left.prevent="moveFocus(index, 'tax', 'left')"
        @keydown.right.prevent="moveFocus(index, 'tax', 'right')"
      />
    </td>
    <td class="py-1 ps-2 whitespace-nowrap"  :class="{ 'text-red-600': row.return }">
      {{ row.value }}
    </td>
  </tr>
</tbody>


          </table>
          
        </div>

         

  <template #footer>
    <div class=" w-full flex justify-between  px-3 py-2">
        <div>
           Qty: {{ tQty }}
        </div>
        <div>
          <div v-if="!isSaving">
            Inv #: {{ `${useAuth().session.value?.code}/${useAuth().session.value?.billCounter}` }}
          </div>
          <UButton v-else :loading="true" variant="ghost" color="grey"/>
        </div>
      </div>
        <!-- Other form elements -->
         <div v-if="!token && !isMobile" class="sm:grid hidden grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 text-sm px-3 py-3">

          <div class="">

        <!-- Discount Input -->
        <div class="mb-6">
          <label class="block text-gray-700 font-medium">Dis % (+) / Round Off (-)</label>
          <UInput
            ref="discountref"
            type="number"
            v-model="discount"
            @keydown.enter.prevent="handleEnterMainDiscount()"
            placeholder="Enter discount"
          />
        </div>

  <!-- Subtotal Display -->
  <div class="border border-primary-700 dark:border-primary-300 rounded-md mb-7">
  <div class="flex flex-col items-center justify-center py-3">
    <div class="text-s">Sub Total</div>
    <div class="text-primary-700 dark:text-primary-300 font-bold text-3xl leading-none">₹{{ subtotal.toFixed(2) }}</div>
  </div>
</div>
    

  <!-- Grand Total Display -->
   <div class="border border-green-700 dark:border-green-300 rounded-md">
  <div class="flex flex-col items-center justify-center py-3">
    <div class="text-s">Grand Total</div>
    <div class="text-green-700 dark:text-green-300 font-bold text-3xl leading-none ">₹{{ grandTotal.toFixed(2) }}</div>
  </div>
</div>

</div>

          <div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Sales Return AMT</label>
              <UInput v-model="returnAmt" />
            </div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Total Redeemed AMT</label>
              <UInput v-model = redeemedAmt  />
            </div>
             <div class="mb-4">
              <label class="block text-gray-700 font-medium">Payment Method</label>
              <div class="w-full flex flex-row gap-2">
                <USelect
                  ref="paymentref"
                  v-model="paymentMethod"
                  :options="paymentOptions"
                  @keydown.enter.prevent="handleEnterPayment(index)"
                  class="flex-1"
                />
                <UButton
                  icon="i-heroicons-scissors"
                  size="sm"
                  color="primary"
                  square
                  variant="solid"
                  class="w-auto"
                  @click="handleSplit"
                />
              </div>
            </div>


            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Account Name</label>
              <UInputMenu v-model="selected" :options="accounts" value-attribute="id" option-attribute="name"/>
            </div>    
          </div>

          <div>
            <div class="mb-4 mt-5">
              <UButton color="primary" block>Add Voucher</UButton>
            </div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Total Scanned</label>
              <UInput v-model="voucherNo" />
            </div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Total Value</label>
              <UInput v-model="voucherNo" />
            </div>
            <div class="mt-9">
              <UButton color="primary" block @click="isOpen=true" :loading="isSavingAcc">Add Account</UButton>
            </div>
          </div>
          
          <div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Cell No.</label>
              <UInput v-model="phoneNo" :loading="isClientLoading" icon="i-heroicons-magnifying-glass-20-solid" @keydown.enter.prevent="handleEnterPhone"/>
            </div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Name</label>
              <UInput v-model="clientName" />
            </div>
            <div class="mb-4">
              <label class="block text-gray-700 font-medium">Points</label>
              <UInput v-model="points" />
            </div>
            <div>
              <UButton v-if="!isRedeemPoint" color="green" class="mt-9" block @click="handleRedeemPoints" :loading="redeeming">Redeem Points</UButton>
              <UButton v-else-if="isRedeemPoint" color="red" class="mt-9" block @click="handleRedeemPoints" :loading="redeeming">Cancel Redeem</UButton>
            </div>
          </div>
        </div>

        <!-- mobile view -->
        <div  v-if="isMobile" class="sm:hidden flex flex-col gap-3 py-3 text-sm px-2" >
        <div class="">
          <label class="block text-gray-700 font-medium">Dis % (+) / Round Off (-)</label>
          <UInput
          ref="discountref"
          type="text"
          v-model="discount"
          inputmode="decimal"
          @keydown.enter.prevent="handleEnterMainDiscount()"
          placeholder="Enter discount"
          pattern="^-?[0-9]*[.,]?[0-9]*$"
          />
        </div>

        <div class="">
          <label class="block text-gray-700 font-medium">Payment Method</label>
          <div class="w-full flex flex-row gap-2">
            <USelect
            ref="paymentref"
            v-model="paymentMethod"
            :options="paymentOptions"
            @keydown.enter.prevent="handleEnterPayment(index)"
            class="flex-1"
            />
            <UButton
            icon="i-heroicons-scissors"
            size="sm"
            color="primary"
            square
            variant="solid"
            class="w-auto"
            @click="handleSplit"
            />
          </div>    
        </div>    

        <div class="">
          <label class="block text-gray-700 font-medium">Sales Return AMT</label>
          <UInput v-model="returnAmt" />
        </div>

        <div class=" flex flex-row gap-2">
          <div class="">
            <label class="block text-gray-700 font-medium">Cell No.</label>
            <UInput v-model="phoneNo" :loading="isClientLoading" icon="i-heroicons-magnifying-glass-20-solid" @keydown.enter.prevent="handleEnterPhone"/>
          </div>
          <div class="">
            <label class="block text-gray-700 font-medium">Name</label>
            <UInput v-model="clientName" />
          </div>
        </div>

        <div class="">
          <label class="block text-gray-700 font-medium">Account Name</label>
          <div class="w-full flex flex-row gap-2">
            <UInputMenu class="flex-1" v-model="selected" :options="accounts" value-attribute="id" option-attribute="name"/>
            <UButton
            icon="i-heroicons-plus"
            size="sm"
            color="primary"
            square
            variant="solid"
            class="w-auto"
            :loading="isSavingAcc"
            @click="isOpen=true"
            />
          </div>
        </div>

          <div>
            <label class="block text-gray-700 font-medium">Token</label>
            <div class=" flex flex-row items-center justify-between gap-2">
              <UInput v-model="token" label="Token" type="text" placeholder="Token No" class="w-full" />
              <UButton color="primary" label="Token Entries " hidden @click="isTokenOpen=true" class=""/>
            </div>
          </div>

        </div>

         

        <div v-else class="w-full flex-wrap gap-4  px-3 py-3 hidden sm:flex">
          <UButton color="blue" class="flex-1" block @click="newBill" >New</UButton>
          <UButton  v-if="!token" :loading="isSaving" ref="saveref" color="green" class="flex-1" block @click="handleSave">Save</UButton>
          <UButton  v-if="token" ref="savetokenref" color="green" class="flex-1" block @click="handleTokenSave">Save</UButton>
          <UButton color="gray" class="flex-1" block disabled>Delete</UButton>
          <UButton class="flex-1" block>Barcode Search</UButton>
          <UButton v-if="!token" class="flex-1" @click="issalesReturnModelOpen = true" block>Sales Return</UButton>
          <UButton v-if="!token" class="flex-1"  @click="isClientAddModelOpen = true" block>Add Client</UButton>
        </div>

          <div v-if="isMobile" class="w-full flex flex-wrap gap-4  px-3 py-3 sm:hidden">
          <UButton color="blue" class="flex-1" block @click="newBill" >New</UButton>
          <UButton  v-if="!token" :loading="isSaving" ref="saveref" color="green" class="flex-1" block @click="handleSave">Save</UButton>
          <UButton  v-if="token" ref="savetokenref" color="green" class="flex-1" block @click="handleTokenSave">Save</UButton>
          <UButton v-if="!token" class="flex-1" @click="issalesReturnModelOpen = true" block>Return</UButton>
        </div>
        </template>
      </UCard>
  </UDashboardPanelContent>

  <UModal v-model="isOpen">
        <div class="p-4 space-y-4">
          <h2 class="text-lg font-semibold">Enter Account Details</h2>

          <!-- Name -->
          <h3 class="text-md font-semibold">Personal Details</h3>
          <UInput v-model="account.name" label="Name" placeholder="Enter full name" required />
          <UInput v-model="account.phone" label="Phone No" placeholder="Enter Phone Number" required />

          <!-- Address -->
          <h3 class="text-md font-semibold mt-4">Address Details</h3>
          <UInput v-model="account.street" label="Street" placeholder="Enter street name" required />
          <UInput v-model="account.locality" label="Locality" placeholder="Enter locality" required />
          <UInput v-model="account.city" label="City" placeholder="Enter city name" required />
          <UInput v-model="account.state" label="State" placeholder="Enter state name" required />
          <UInput v-model="account.pincode" label="Pincode" placeholder="Enter pincode" required />


          <!-- Submit Button -->
          <UButton @click="submitForm" :loading="isSavingAcc" block>Submit</UButton>
        </div>
      </UModal>


     
<!-- sales return -->
<BillingSalesReturn
  v-model="issalesReturnModelOpen"
  @totalreturnvalue="handleReturnData"
/>
<BillingAddClient
  v-model:model="isClientAddModelOpen"
  v-model:phoneNo="phoneNo"
  :onVerify="handleEnterPhone"
  :clientAdded="handleClientAdded"
/>

<!-- token modal -->
    <UModal v-model="isTokenOpen">
        <div class="p-4 space-y-4">
          <div v-for="(entry, index) in tokenEntries" :key="index">
            <div class="flex flex-row items-center">
              <UInput ref="tokenInputs" v-model="tokenEntries[index]" size="sm" type="text" @keydown.enter="handleTokenInputEnter(index)"   @keydown.delete="(event) => handleTokenDelete(index, event)" />
              <UButton 
                icon="i-heroicons-trash" 
                color="red" 
                class="ms-2" 
                @click="removeEntry(index)"
                :disabled="tokenEntries.length === 1"
              />
            </div>
          </div>

          <div class="mt-4">
            <UButton  color="green" @click="addEntry" >Add</UButton>
          </div>

          <UButton ref="addTokenRef"  @click="submitEntryForm" block class="mt-4">Submit</UButton>
        </div>
    </UModal>

   <!-- split payment method modal -->
   <UModal v-model="showSplitModal">
  <div class="p-4 space-y-4">
    <h2 class="text-lg font-semibold">Split Payment</h2>

    <div
      v-for="(method, index) in paymentOptionsInsplit"
      :key="method"
      class="flex gap-2 items-center"
    >
      <div
        class="w-1/2"
      >
      {{ tempSplits[method].method }}
      </div>
      <UInput
        v-model.number="tempSplits[method].amount"
        type="number"
        placeholder="Enter amount"
        class="w-1/2"
        @update:modelValue="() => handleAmountEntry(method)"
      />
    </div>

    <div class="mt-4">
      <p class="text-sm font-medium">Total Entered: ₹{{ totalSplitAmount }}</p>
      <p
        class="text-sm"
        :class="{
          'text-green-600': totalSplitAmount === grandTotal,
          'text-red-600': totalSplitAmount !== grandTotal
        }"
      >
        Grand Total: ₹{{ grandTotal }}
      </p>
    </div>

    <UButton
      :disabled="totalSplitAmount !== grandTotal"
      color="green"
      block
      class="mt-4"
      @click="submitSplitPayment"
    >
      Submit Split Payment
    </UButton>
  </div>
</UModal>


    <UDashboardModal
        v-model="isPrint"
        title="Print Bill"
        description="Would You Like to print?"
        icon="i-heroicons-exclamation-circle"
        prevent-close
        :close-button="null"
        :ui="{
            icon: {
                base: 'text-red-500 dark:text-red-400',
            },
            footer: {
                base: 'ml-16',
            },
        }"
    >
        <template #footer>
            <UButton
                color="green"
                label="Yes"
                @click="print"
            />
            <UButton color="red" label="NO" @click="isPrint = false" />
        </template>
    </UDashboardModal>

     <UDashboardModal
        v-model="isDeleteModalOpen"
        title="Delete Entry"
        :description="`Are you sure you want to delete Entry No ${deletingRowIdentity.index}?`"
        icon="i-heroicons-exclamation-circle"
        prevent-close
        :close-button="null"
        :ui="{
            icon: {
                base: 'text-red-500 dark:text-red-400',
            },
            footer: {
                base: 'ml-16',
            },
        }"
    >
        <template #footer>
            <UButton
                color="red"
                label="Delete"
                @click="() => {removeRow( deletingRowIdentity.event,deletingRowIdentity.index);isDeleteModalOpen = false; }"
            />
            <UButton color="white" label="Cancel" @click="isDeleteModalOpen = false" />
        </template>
    </UDashboardModal>

</template>


<style scoped>
.relative {
  position: relative;
}

.cursor-col-resize {
  cursor: col-resize;
}

.hover\:bg-blue-300:hover {
  background-color: #93c5fd;
}

.b-w{
  width:1px;
}
</style>
